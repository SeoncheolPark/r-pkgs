---
layout: default
title: Compiled code
output: bookdown::html_chapter
---

# 컴파일된 코드 {#src}

고급, 표현 언어가 R이다. 하지만, 이러한 풍부한 표현성이 공짜로 오는 것은 아니라 댓가가 있다: 속도. 이것이 C 나 C++같은 저수준 컴파일 언어로 R 코드를 강력하게 보완하는 이유다.
C 와 C++ 언어로 동일한 문제를 해결하려면 더 많은 코드와 더 깊은 사고력을 필요하지만,
R보다 몇자리수가 더 빠르다.

불행하게도, C나 C++로 프로그램을 작성하는 방법을 가르치는 것은 이번 책 범위 밖이다.
만약 학습하고자 한다면, 저자는 C++와 Rcpp 팩키지로 시작하는 것을 추천한다.
Rcpp를 통해서 쉽게 C++와 R을 연결할 수 있다.
RStudio를 저자는 추천하는데 이유는 전체 과정을 원활히하는 많은 도구를 지원하기 때문이다. 
저자가 집필한 무료로 이용가능한 [고급 R (Advanced R)](http://amzn.com/1466586966?tag=devtools-20)에서 ["High performance functions with Rcpp"](http://adv-r.had.co.nz/Rcpp.html) 장으로 시작하라: 
친숙한 R 코드를 C++ 코드로 변환하면서 부드럽게 언어를 소개한다.
다음으로 [Rcpp book](http://www.rcpp.org/book)와 [learning more](http://adv-r.had.co.nz/Rcpp.html#rcpp-more)에 등재된 다른 참고서를 학습해 나간다.

## C++ {#cpp}

Rcpp로 작성한 팩키지 환경설정을 하려면, 다음을 실행한다:

```{r, eval = FALSE}
devtools::use_rcpp()
```

상기 명령어 실행결과는 다음과 같다:


* 작성한 `.cpp` 파일을 보관할 `src/` 디렉토리를 생성한다.

* `DESCRIPTION` 파일에 `LinkingTo` 와 `Imports` 필드에 `Rcpp`를 추가한다.

* `.gitignore` 파일에 환경설정해서 실수로 컴파일된 코드가 말아올려져
  체크인(check-in)되지 않도록 확실히 한다 ([git](#git)에서 자세한 사항 학습예정).

* 작성한 팩키지에 추가할 필요가 있는 roxygen 태그 2개를 알려준다:

    ```{r}
    #' @useDynLib your-package-name
    #' @importFrom Rcpp sourceCpp
    NULL
    ```

### 작업흐름 {#cpp-workflow}

설정을 마치면, 이제는 기본 작업흐름이 친숙할 것이다:

1.  신규 C++ 파일을 생성한다:

    ```{r, echo = FALSE}
    bookdown::embed_png("screenshots/new-cpp.png", dpi = 220)
    ```

    디폴트 기본 템플릿은 다음과 같다:
    
    ```cpp
    #include <Rcpp.h>
    using namespace Rcpp;
    
    // Below is a simple example of exporting a C++ function to R. You can
    // source this function into an R session using the Rcpp::sourceCpp 
    // function (or via the Source button on the editor toolbar)
    
    // For more on using Rcpp click the Help button on the editor toolbar
    
    // [[Rcpp::export]]
    int timesTwo(int x) {
       return x * 2;
    }
    ```
    
    기본함수와 시작에 필요한 기본 안내지침을 포함되어 있다.
    가장 중요한 두 부분은 헤더 `#includes`와 특수 속성 `// [[Rcpp::export]]`이다.

1. Ctrl/Cmd + Shift + D 단축키를 눌러 문서화해서 `NAMESPACE`에 필요한 변경사항을 생성한다.

1.  빌드 창에서 `Build & Reload`을 클릭하거나, Ctrl/Cmd + Shift + B 단축키를 누른다.
    표준 `devtools::load_all()` 명령어를 사용해서 계속할 수 있지만 더 위험하다.
    C 코드를 메모리에 적재해서 올리고 내리기 때문에 메모리를 손상시킬 가능성이 높다.
    그리고 `safer`로 나아질 수는 있지만 느리다. 
    왜냐하면, "Build & Reload"은 팩키지를 설치하고 나서 R을 다시 시작하기 때문이다.

1.  콘솔에서 `timesTwo(10)`을 실행해서 정상적으로 동작되는지 확인하라.

무대뒤에서, "Build and reload"는 개발자를 위해서 엄청난 작업을 수행한다:


* 코드를 컴파일하는데 필요한 R 환경을 설정하고, 
  만약 필요한 부분을 놓쳤다면 경고를 준다.


* `Rcpp::compileAttributes()`을 호출한다. `.cpp` 함수를 점검해서 
  `// [[Rcpp::export]]` 양식에서 __속성(attributes)__을 찾는다.
  속성을 찾게되면, R 에서 코드를 생성해서 함수를 이용가능하게 만들고,
  `src/RcppExports.cpp`와 `R/RcppExports.R` 파일을 생성한다.
  절대로 수작업으로 이런 파일을 변경해서는 안된다.


* DLL (dynamically linked library, 동적 링크 라이브러리)를 빌드해서 R에서 이용가능하게 만든다.


### 문서화 {#cpp-man}

각기 내보내진 C++ 함수는 자동으로 포장함수(wrapper function)를 얻는다 (`R/RcppExports.R`에 위치한다). 예를 들어, R `timesTwo()` 함수는 다음과 같이 생겼다:

```{r}
timesTwo <- function(x) {
  .Call('timesTwo', PACKAGE = 'mypackage', x)
}
```

`.Call()` 기저 함수 (base function)을 사용해서 작성한 팩키지 `timesTwo` C 함수를 실행한다.
roxygen2를 사용해서 정규 R 함수처럼 문서화할 수 있다.
하지만, 주석으로 `#'`을 사용하는 대신에 C++에서 관례로 사용되는 `//'`을 사용한다:

```cpp
//' Multiply a number by two
//' 
//' @param x A single integer.
//' @export
// [[Rcpp::export]]
int timesTwo(int x) {
   return x * 2;
}
```

상기 실행결과는 `R/RcppExports.R` 파일에 roxygen 주석을 생성한다:

```{r}
#' Multiply a number by two
#' 
#' @param x A single integer.
#' @export
timesTwo <- function(x) {
  .Call('timesTwo', PACKAGE = 'mypackage', x)
}
```

두 내보내기 지시어 간에 차이점은 중요하다:


* `[[Rcpp::export]]`은 R에 C++ 함수를 이용가능하게 한다. 
  만약 정확한 세부사항을 기억하는데 어려움이 있다면, 
  모든 것이 twos에 온다는데 주목한다: Two `/`, two `[`, two `:` and two `]`.

* `NAMESPACE` 파일에 `@export` 태그를 추가해서 작성한 팩키지 외부에 R 포장함수를 
  이용할 수 있게 만든다.

### C++ 코드 내보내기 {#cpp-export}

다른 팩키지에서 있는 C++ 코드로부터 C++ 코드를 호출할 수 있게 만들려면, 
다음을 추가한다:


```cpp
// [[Rcpp::interfaces(r, cpp)]]
```

상기 명령어는 다른 팩키지에 포함될 수 있는 헤더파일, `inst/include/mypackage.h`을 생성한다 (저수준 상세내용은 [Exporting C code]{#c-export}에 기술되어 있다).
수작업을 작성한 헤더파일과 자동으로 생성된 헤더파일을 조합하는 방법을 포함한 보다 상세한 내용은 "[Rcpp Attributes](http://dirk.eddelbuettel.com/code/rcpp/Rcpp-attributes.pdf)"을 참조한다.

### C++ 코드 가져오기 {#cpp-import}

또다른 팩키지로부터 C++ 코드를 사용하기 위해서는:


1. `DESCRIPTION` 파일에 `LinkingTo: otherPackage`을 추가한다.
  혼동스럽게도 링커(linker)와 아무 관련이 없다.
  `LinkingTo`라고 불리는 이유는 경로에 `otherPackage/include`를 추가해서
  동적으로 헤더를 통해 다른 코드에 "링크(link to)"되도록 하기 때문이다.

1. C++ 파일에 다음을 추가한다:

    ```cpp
    #include <otherPackage.h>
    ```

1. 다른 팩키지(otherPackage)에 있는 C++ 함수가 `otherPackage` 네임스페이스에 포함된다.
   함수에 접근하려면, `otherPackage::foo()`을 사용하거나, 
   `using namespace otherPackage` 명령어로 전역에서 이용할 수 있게 만든다.

### 모범사례 (Best practices) {#cpp-best-practices}

* 출력결과를 출력하려면 (`cout << ...`이 아닌) `Rcout << ...`을 사용하라.
  GUI 콘솔 혹은 (만약 `sink()`가 활성화되었다면) 파일에, 이것을 통해 
  올바른 위치에 출력한다.


* 오랜 시간이 걸리는 반복 루프(loop)에 대해서, 
  정기적으로 `Rcpp::checkUserInterrupt()`을 실행한다.
  이른 통해서 사용자가 Ctrl + C 단축키를 누르게 되면 C++ 실행을
  중단하거나 R에서 빠져나오게 한다.

* 헤더에 `.h` 확장자를 사용하고 파일에 포함하라.
  (만약 그렇지 않으면, `R CMD check` 명령어를 실행하면 불평이 터져 나온다).

* [R 팩키지를 위한 이식성 높은 C++ (Portable C++ for R packages)](http://journal.r-project.org/archive/2011-2/RJournal_2011-2_Plummer.pdf)에 나오는 마틴 플러머(Martyn Plummer) 권장사항을 따른다.

* 적성한 팩키지에서 C++ 코드를 사용할 때마다, 
  팩키지를 적재하지 않고 내릴 때 본인 스스로 청소를 할 필요가 있다.
  DLL 파일을 적재하지 않고 내리는 `.onUnload()` 함수를 작성해서 해당 작업을 수행한다:


    ```{r}
    .onUnload <- function (libpath) {
      library.dynam.unload("mypackage", libpath)
    }
    ```

* C++ 코드를 컴파일하는데 `gcc` 대신에 `clang`을 사용한다:
  이유는 훨씬 더 좋은 오류 메시지를 전달한다.
  홈디렉토리에 다음을 포함하는 파일을 리눅스와 맥에서는 `.R/Makevars` (linux and mac),
  윈도우에서는 `.R/Makevars.win` 이름으로 생성해서 `clang`을 디폴트 기본설정한다:


    ```bash
    CXX=clang++
    ```
    
    (만약 본인 홈디렉토리를 알지 못한다면, `path.expand("~")` 명령어를 통해서
    확인할 수 있다.)

* 리눅스 혹은 맥에서 컴파일 속도를 높이기 위해서 `ccache`를 설치하고 나서,
  `~/.R/Makevars` 파일을 다음으로 대체한다. 

    ```bash
    CC=ccache clang -Qunused-arguments
    CXX=ccache clang++ -Qunused-arguments
    CCACHE_CPP2=yes
    ```

## C {#clang}

만약 신규로 컴파일된 코드를 작성하려면, Rcpp를 사용하는 것이 거의 항상 더 낫다.
이유는 더 적은 작업과, 더 일관성을 갖고, 문서화도 더 잘 되고, 더 좋은 도구도 있기 때문이다. 하지만, C를 선택해야되는 사유가 몇가지 있다:


* 이미 C API를 사용하고 있는 이전 팩키지를 가지고 작업할 때.
* 기존 C 라이브러리에 바인딩될 때.

R로부터 C 함수를 호출하는 방법은 두가지다: `.C()`와 `.Call()`.
`.C()`는 R에 관해 어떤 것도 알지못하는 C 함수를 호출하는 약식으로 간편한 방식이다. 
왜냐하면 `.C()`를 통해 R 벡터를 자동으로 해당 C 자료형으로 전환하기 때문이다.
`.Call()`은 좀더 유연하지만, 조금더 작업이 요구된다: 
작성한 C 함수가 R API를 사용해서 입력값을 표준 C 자료형으로 전환한다.


### Getting started with `.Call()`

To call a C function from R, you first need a C function! In an R package, C code lives in `.c` files in `src/`. You'll need to include two header files:

```c
#include <R.h>
#include <Rinternals.h>
```

(Yes, including `<Rinternals.h>` seems like bad form. On top of that, doing so doesn't actually give you access to the "internal" internal API unless you set some additional flags. The default just gives you access to the "public" internal API, which is both necessary and done for safety's sake. Yes, this is confusing.)

These headers allow you to access R's C API. Unfortunately this API is not well documented. I'd recommend starting with my notes at [R's C interface](http://adv-r.had.co.nz/C-interface.html). After that, read "[The R API](http://cran.rstudio.com/doc/manuals/r-devel/R-exts.html#The-R-API)" in "Writing R Extensions". A number of exported functions are not documented, so you'll also need to read the [R source code](https://github.com/wch/r-source) to figure out the details.

Here's the bare minimum you need to know: C functions that talk to R must use the `SEXP` type for both inputs and outputs. `SEXP`, short for S expression, is the C struct used to represent every type of object in R. A C function typically starts by converting `SEXP`s to atomic C objects, and ends by converting C objects back to a `SEXP`. (The R API is designed so that these conversions often don't require copying.) The following table lists the functions that convert length one R vectors to and from C scalars:

R type      | C type      | R -> C            |  C -> R 
------------|-------------|-------------------|-------------------
integer     | int         | `asInteger(x)`    | `ScalarInteger(x)`
numeric     | double      | `asReal(x)`       | `ScalarReal(x)`
logical     | int         | `asLogical(x)`    | `ScalarLogical(x)`
character   | const char* | `CHAR(asChar(x))` | `mkString(x)`

We now have enough information to write a simple C function that can add two numbers:

```c
#include <R.h>
#include <Rinternals.h>

SEXP add_(SEXP x_, SEXP y_) {
  double x = asReal(x_);
  double y = asReal(y_);
  
  double sum = x + y;
  
  return ScalarReal(sum);
}
```

We call this from R with `.Call()`: 

```{r}
#' @useDynLib mypackage add_
add <- function(x, y) .Call(add_, x, y)
```

Where does the first argument to `.Call()`, `add_`, come from? It comes from `@useDynLib`, which creates a line in the NAMESPACE that looks like:

```
useDynLib(mypackage, add_)
```

This directive instructs R to create an object called `add_` which describes a C function pointer:

```{r, eval = FALSE}
mypackage:::add_
#> $name
#> [1] "add_"
#> 
#> $address
#> <pointer: 0x107be3f40>
#> $package
#> NULL
#> 
#> attr(,"class")
#> [1] "NativeSymbolInfo"
```

`.Call()` takes the pointer to a C function and calls it. All R objects have the same C type (the `SEXP`) you need to make sure the arguments are of the type you expect. Either do that in the R function, in the C function, or just accept that R will crash every time you accidentally supply the wrong type of input.

The most complicated part of working with the `.Call()` interface is memory-management. Whenever you create an R-level data structure, you must `PROTECT()` it so the garbage collector doesn't try and free it, then `UNPROTECT()` it at the end of the function. This topic is beyond the scope of this chapter, but you can learn more about it at <http://adv-r.had.co.nz/C-interface.html#c-vectors>.

### Getting starting with `.C()`

`.C()` is simpler than `.Call()` and can be useful if you already have standard C code. Since you never create R objects in `.C()`, you never need to worry about memory management. To use it, you first write a void C function, using in-place modification of function parameters to return values:

```c
void add_(double* x, double* y, double* out) {
  out[0] = x[0] + y[0];
}
```

Then like `.Call()` you create an R wrapper:

```{r, eval = FALSE}
#' @useDynLib mypackage add_
add <- function(x, y) {
  .C(add_, x, y, numeric(1))[[3]]
}
```

(Here we extract the 3rd element of the result because that corresponds to the out parameter.)

`.C()` automatically converts back and forth between R vectors and their C equivalents:

R type      | C type   
------------|----------
logical     | `int*`
integer     | `int*`
double	    | `double*`
character	  | `char**`
raw	        | `unsigned char*`

Note that `.C()` assumes your function doesn't know how to deal with missing values and will throw an error if any arguments contain an NA. If it can correctly handle missing values, set `NAOK = TRUE` in the call to `.C()`. 

You can learn more about `.C()` in its help, `?.C` and in [R-extensions](http://cran.rstudio.com/doc/manuals/r-devel/R-exts.html#Interface-functions-_002eC-and-_002eFortran).

### Workflow {#c-workflow}

The usual workflow still applies:

1.  Modify the C code.
1.  Build and reload the package with Ctrl/Cmd + Shift + B
1.  Experiment at the console.

The first time you add `@useDynLib`, you'll also need to run `devtools::document()` (Ctrl/Cmd + Shift + D) and reload the package.

### Exporting C code {#c-export}

R packages need to provide DLLs that can be relocated; DLLs that work regardless of where they live on disk. This is because most R users don't build packages from source. Instead, they get binaries from CRAN that can get installed in many different places. This need for relocatable DLLs adds a few more steps to the job of importing and exporting C code for R packages (the same problem arises for C++, but Rcpp attributes automate the manual steps described below). 

R solves this problem using __function registration__. To export a `.Call()` C function, you register it with `R_RegisterCCallable()`. To import a `.Call()` C function, you get a pointer to it with `R_GetCCallable()`. Similar techniques are available for `.C()` C functions, but are beyond the scope of this book. As we'll see below, a user-friendly package will do both these tasks, so users of the package can ignore the details and simply include a header a file.

[Sidebar: Confusingly, there's another type of function registration. Instead of registering C functions using the namespace (i.e. `@useDynLib pkg fun`), you can register them with `R_registerRoutines()` and `@useDynLib mypackage, .registration = TRUE`. To learn the details read [Registering native extensions](http://cran.r-project.org/doc/manuals/R-exts.html#Registering-native-routines) in "Writing R extensions".]

To register a function, call `R_RegisterCCallable()`, defined in `<R_ext/Rdynload.h>`. Function registration should be done in a function called `R_init_<mypackage>`. This function is called automatically when the "mypackage" DLL is loaded. `R_RegisterCCallable()` has three arguments:

* A pointer to the DLL.
* The name of the function.
* A pointer to the function, cast as `DL_FUNC` (i.e. a **d**ynamically 
  **l**oaded **func**tion).

The following code registers the `add()` function defined above:

```c
#include "add.h"
#include <R_ext/Rdynload.h>

void R_init_mypackage(DllInfo *info) {
  R_RegisterCCallable(info, "add_",  (DL_FUNC) &add_)
}
```

It doesn't matter where this code lives, but it's usually put in a file called `src/mypackage-init.c`. 

To access a registered function from another package, call `R_GetCCallable()`. It has two arguments, the function name and the package name. It returns a function pointer. The function pointer has no type information, so it should always be wrapped in a helper function that defines the inputs:

```c
#include <R_ext/Rdynload.h>
#include <R.h>
#include <Rinternals.h>

SEXP add_(SEXP x, SEXP y) {
  static SEXP(fun*)(SEXP, SEXP) = NULL;
  if (fun == NULL)
    fun = (SEXP(*)(SEXP, SEXP)) R_GetCCallable("add", "mypackage");
  return fun(x, y);
}
```

Rather than relying on each package that imports your C code to do this correctly, you should instead do it for them. Write `inst/include/mypackageAPI.h` which provides a wrapper function for each exported function. A popular package that does that is [xts](http://cran.r-project.org/web/packages/xts/). Download the source package and look in the `include/` directory to see what it does.

### Importing C code {#c-import}

Using C code from another package varies based on how the package is implemented:

* If it uses the system described above, all you need is `LinkingTo: otherPackage` 
  in the `DESCRIPTION`, and `#include otherPackageAPI.h` in the C file. (Remember 
  `LinkingTo` is not about the linker, but actually affects the include path).
   
* If it registers the functions, but doesn't provide a header file, you'll
  need to write the wrapper yourself. Since you're not using any header
  files from the package, use `Imports` and not `LinkingTo`. You also need to 
  make sure the package is loaded. You can do this by importing any function 
  with `@importFrom mypackage foo`, or by adding `requireNamespace("mypackage", 
  quietly = TRUE)` to `.onLoad()`.
  
* If it doesn't register the functions, you can't use them. You'll have to
  ask the maintainer nicely or even provide a pull request.

### Best practices {#c-best-practices}

* Avoid calls to `assert()`, `abort()` and `exit()`: these will kill the 
  R process, not just your C code. Instead, use `error()` which is 
  equivalent to calling `stop()` in R.

* To print output use `Rprintf()`, not `printf()`. Doing so always prints to 
  the right place, whether it's the GUI console or a file (if `sink()` is 
  active).

* In long-running loops, regularly call `R_CheckUserInterrupt()` to allow
  the user to interrupt the C code.

* Don't use C's random number generators (like `rand()` or `random()`), 
  instead use the C API to R's rngs: `unif_rand()`, `norm_rand()`, etc. 
  Note the caveats in ["Random number generation"](http://cran.rstudio.com/doc/manuals/r-devel/R-exts.html#Random-numbers) - you must call `GetRNGstate()` before and 
  `PutRNGstate()` after.

* Use R macros `ISNAN(x)` and `R_FINITE(x)` to check for NaNs and infinite
  values. These work on more platforms than the C99 `isnan()` and `isfinite()`.

* Like with C++, whenever you use C code in your package, you should unload the 
  DLL when the package is unloaded:

    ```{r}
    .onUnload <- function (libpath) {
      library.dynam.unload("mypackage", libpath)
    }
    ```

* Use `clang` instead of `gcc` to compile your C code: it gives much 
  better error messages. You can make `clang` the default by creating a
  `~/.R/Makevars` that contains:

    ```bash
    C=clang
    ```

## Debugging compiled code {#src-debugging}

It's possible, with a little extra work, to use an interactive debugger to debug your C/C++ in the same way that you can use `browser()` and `debug()` to debug your R code. Unfortunately you won't be able to use RStudio, you'll have to run R from the command line. 

Open a shell (e.g. with Tools | Shell...) and start R by typing:

```bash
# If you compile with clang
R --debugger=lldb
# If you compile with gcc
R --debugger=gdb
```

This will start either [lldb](http://lldb.llvm.org) or [gdb](http://www.gnu.org/software/gdb/), the debuggers that work with code produced by `clang` or `gcc` respectively. Like R, `lldb` and `gdb` provide a REPL, a run-eval-print loop where you enter commands and then look at the results. In the examples below I'll show the results of `lldb`, which is what I use (the output from `gdb` is similar). For each interactive command I'll tell you the explicit, but long, `lldb` command and the short, but cryptic, `gdb` command. Because `lldb` understand all `gdb` commands, you can use choose to be explicit of terse.

Once you've started the debugger, start R by typing `process start` (lldb) or `run` (gdb). Now when your C/C++ code crashes you'll be dumped into an interactive debugger instead of getting a cryptic error message and a crash. 

Let's start with a simple C++ function that writes to memory it doesn't "own":

```{r, eval = FALSE}
Rcpp::cppFunction("
bool mistake() {
  NumericVector x(1);
  int n = INT_MAX;
  x[n] = 0;
  return true;
}
", plugins = "debug", verbose = TRUE, rebuild = TRUE)
mistake()
```


Use `devtools::load_all()` to load the current package. Then copy and paste the code that creates the bug. Here's a crash report from a package I was working on:

```
Process 32743 stopped
* thread #1: tid = 0x1f79f6, 0x... gggeom.so...`
   frame #0: 0x0.. gggeom.so`vw_distance(x=..., y=...) + ... at vw-distance.cpp:54
   51        int prev_idx = prev[idx];
   52  	
   53  	    next[prev[idx]] = next_idx;
-> 54  	    prev[next[idx]] = prev_idx;
   55  	    prev[idx] = -1;
   56  	    next[idx] = -1;
   57
```

It tells us that the crash occurred because of a `EXC_BAD_ACCESS` - this is one of the most common types of crash in C/C++ code. Helpfully, lldb shows exactly which line of C++ code caused the problem: `vw-distance.cpp:54`. Often just knowing where the problem occurs is enough to fix it. But we're also now at an interactive prompt. There are many commands you can run here to explore what's going on. The most useful are listed below:

* See a list of all commands: `help`.

* Show your location on the callstack with `thread backtrace`/`bt`. This
  will print a list of calls leading up to the error, much like `traceback()`
  does in R. Navigate the callstack with `frame select <n>`/`frame <n>`, or 
  `up` and `down`.

* Evaluate the next expression with `thread step-over`/`next`, or step into it
  with `thread step-in`/`step`. Continue executing the rest of the code with
  `thread step-out`/`finish`

* Show all variables defined in the current frame with `frame variable`/
  `info locals`, or print the value of a single variable with 
  `frame variable <var>`/`p <var>`.

Instead of waiting for a crash to occur you can also set breakpoints in your code. To do so, start the debugger, run R, then:

1. Press `Ctrl + C`

1. Type `breakpoint set --file foo.c --line 12`/`break foo.c:12`.

1. `process continue`/`c` to go back to the R console. Now run the C code
   you're interested in, and the debugger will stop when it gets to the 
   specified line.

Finally, you can also use the debugger if your code is stuck in an infinite loop. Press `Ctrl + C` to break into the debugger and you'll see which line of code is causing the problem.

## Makefiles {#make}

While makefiles are beyond the scope of this book, they are a useful tool. A good, gentle introduction with a focus on reproducible research is Karl Broman's ["Minimal make"](http://kbroman.org/minimal_make/).

Generally, R packages should avoid a custom `Makefile`. Instead, use `Makevars`. `Makevars` is a make file that overrides the default make file generated by R (which is located at `file.path(R.home("etc"), "Makeconf")`). This allows you to take advantage of R's default behaviour (it's over 150 lines, and battle-tested across many years and many systems, so you want to!) while being able to set the flags you need. The most commonly used flags are:

* `PKG_LIBS`: Linker flags. A common use is `PKG_LIBS = $(BLAS_LIBS)`. This
  allows you to use the same BLAS library as R.

* `PKG_CFLAGS` & `PKG_CXXFLAGS`: C and C++ flags. Most commonly used to set 
  define directives with `-D`.

* `PKG_CPPFLAGS`: Pre-processor flags (not C++ flags!). Most commonly used to
  set include directories with `-I`. Any package listed in the `LinkingTo` field
  in the `DESCRIPTION` will be automatically included - you do not need to
  explicitly add it.

To set flags only on Windows, use `Makevars.win`. To build a `Makevars` with `configure`, use `Makevars.in`.

By default, R will use the system make, which is not always GNU compatible (i.e. on Solaris). If you want to use GNU extensions (which are extremely common), add `SystemRequirements: GNU make` to `DESCRIPTION`. If you're not sure if you're using GNU extensions, play it safe and add it to the system requirement.

## Other languages {#src-other}

It is possible to connect R to other languages, but the interfaces are not as nice as the one for C++:

* __Fortran__: It's possible to call Fortran subroutines directly with 
  `.Fortran()`, or via C or C++ with `.Call()`. See `?.Fortran` and 

* __Java__: The [rJava](https://github.com/s-u/rJava) package makes it 
  possible to call Java code from within R. Note that unlike with C and C++,
  passing an R object to a Java call will involve a copy operation, something 
  which has serious performance implications.

## Licensing {#src-licensing}

Because it's common to use other peoples' libraries when writing compiled code, you need to make sure that your package license is compatible with the licenses of all included code:

* The simplest solution is to use the same license as the included code. Since 
  you can't relicense someone else's code, you may need to change your license.

* If you don't want to use the same license, you're best sticking
  with common cases where the interactions are well known. For example, 
  [Various Licenses and Comments about Them](https://www.gnu.org/licenses/license-list.html)
  describes what licenses are compatible with the GPL license.
  
  In this case your description should contain 
  `License: <main license> + FILE license` where `<main license>` is a license 
  that is valid for the entire package (both R and compiled code), and the 
  `license` file describes the licenses of individual components.

* For non-standard cases, you'll need to consult a lawyer.

In all cases, make sure you include copyright and license statements from the original code.

## Development workflow {#src-workflow}

When developing C or C++ code, it's usually better to use RStudio's Build & Reload instead of `devtools::load_all()`. If you have C objects that persist between reloads, and you change the data structure, then it's 

## CRAN issues {#src-cran}

Packages with compiled code are much more likely to have difficulties getting on CRAN than those without. The reason? Your package must build from source on all major platforms (Linux, Mac and Windows). This is hard! 

* CRAN provides an automated service for checking R packages on windows: 
  [win-builder](http://win-builder.r-project.org). You can easily access this
  by running `devtools::build_win()`, which builds and uploads a package bundle.
  
* I've tried to include the most important advice in this chapter, but I'd
  recommend reading the entire section on [writing portable C and C++ code](http://cran.rstudio.com/doc/manuals/r-devel/R-exts.html#Portable-C-and-C_002b_002b-code) in "Writing
  R extensions".

* In exceptional circumstances, like binding to Windows-only functionality, 
  you may be able to opt-out of cross-platform requirement, but be prepared    
  to make a strong case for it.

The interface between CRAN's automated and manual checking can be particularly frustrating for compiled code. Requirements vary from submission to submission, based on which maintainer you get and how much free time they have. The rules are inconsistently applied, but if your package doesn't pass, it's better to bite the bullet and make the change rather than trying to argue about it:

  * Sometimes you will need to list all authors and copyright holders of included 
    code in the DESCRIPTION. 
  
  * Sometimes your package will need to work on Solaris. But due to the difficulty 
    of accessing a computer running Solaris, fixing Solaris issues can be hard. 
    However, you will be in a stronger negotiating position if the package has no 
    problems on other platforms. 
  
    One common gotcha: gcc/clang flags `-Wall`, `-pedantic` and `-O0` do not work 
    with the default compiler on Solaris.

