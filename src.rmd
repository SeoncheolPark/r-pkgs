---
layout: default
title: Compiled code
output: bookdown::html_chapter
---

# 컴파일된 코드 {#src}

고급, 표현 언어가 R이다. 하지만, 이러한 풍부한 표현성이 공짜로 오는 것은 아니라 댓가가 있다: 속도. 이것이 C 나 C++같은 저수준 컴파일 언어로 R 코드를 강력하게 보완하는 이유다.
C 와 C++ 언어로 동일한 문제를 해결하려면 더 많은 코드와 더 깊은 사고력을 필요하지만,
R보다 몇자리수가 더 빠르다.

불행하게도, C나 C++로 프로그램을 작성하는 방법을 가르치는 것은 이번 책 범위 밖이다.
만약 학습하고자 한다면, 저자는 C++와 Rcpp 팩키지로 시작하는 것을 추천한다.
Rcpp를 통해서 쉽게 C++와 R을 연결할 수 있다.
RStudio를 저자는 추천하는데 이유는 전체 과정을 원활히하는 많은 도구를 지원하기 때문이다. 
저자가 집필한 무료로 이용가능한 [고급 R (Advanced R)](http://amzn.com/1466586966?tag=devtools-20)에서 ["High performance functions with Rcpp"](http://adv-r.had.co.nz/Rcpp.html) 장으로 시작하라: 
친숙한 R 코드를 C++ 코드로 변환하면서 부드럽게 언어를 소개한다.
다음으로 [Rcpp book](http://www.rcpp.org/book)와 [learning more](http://adv-r.had.co.nz/Rcpp.html#rcpp-more)에 등재된 다른 참고서를 학습해 나간다.

## C++ {#cpp}

Rcpp로 작성한 팩키지 환경설정을 하려면, 다음을 실행한다:

```{r, eval = FALSE}
devtools::use_rcpp()
```

상기 명령어 실행결과는 다음과 같다:


* 작성한 `.cpp` 파일을 보관할 `src/` 디렉토리를 생성한다.

* `DESCRIPTION` 파일에 `LinkingTo` 와 `Imports` 필드에 `Rcpp`를 추가한다.

* `.gitignore` 파일에 환경설정해서 실수로 컴파일된 코드가 말아올려져
  체크인(check-in)되지 않도록 확실히 한다 ([git](#git)에서 자세한 사항 학습예정).

* 작성한 팩키지에 추가할 필요가 있는 roxygen 태그 2개를 알려준다:

    ```{r}
    #' @useDynLib your-package-name
    #' @importFrom Rcpp sourceCpp
    NULL
    ```

### 작업흐름 {#cpp-workflow}

설정을 마치면, 이제는 기본 작업흐름이 친숙할 것이다:

1.  신규 C++ 파일을 생성한다:

    ```{r, echo = FALSE}
    bookdown::embed_png("screenshots/new-cpp.png", dpi = 220)
    ```

    디폴트 기본 템플릿은 다음과 같다:
    
    ```cpp
    #include <Rcpp.h>
    using namespace Rcpp;
    
    // Below is a simple example of exporting a C++ function to R. You can
    // source this function into an R session using the Rcpp::sourceCpp 
    // function (or via the Source button on the editor toolbar)
    
    // For more on using Rcpp click the Help button on the editor toolbar
    
    // [[Rcpp::export]]
    int timesTwo(int x) {
       return x * 2;
    }
    ```
    
    기본함수와 시작에 필요한 기본 안내지침을 포함되어 있다.
    가장 중요한 두 부분은 헤더 `#includes`와 특수 속성 `// [[Rcpp::export]]`이다.

1. Ctrl/Cmd + Shift + D 단축키를 눌러 문서화해서 `NAMESPACE`에 필요한 변경사항을 생성한다.

1.  빌드 창에서 `Build & Reload`을 클릭하거나, Ctrl/Cmd + Shift + B 단축키를 누른다.
    표준 `devtools::load_all()` 명령어를 사용해서 계속할 수 있지만 더 위험하다.
    C 코드를 메모리에 적재해서 올리고 내리기 때문에 메모리를 손상시킬 가능성이 높다.
    그리고 `safer`로 나아질 수는 있지만 느리다. 
    왜냐하면, "Build & Reload"은 팩키지를 설치하고 나서 R을 다시 시작하기 때문이다.

1.  콘솔에서 `timesTwo(10)`을 실행해서 정상적으로 동작되는지 확인하라.

무대뒤에서, "Build and reload"는 개발자를 위해서 엄청난 작업을 수행한다:


* 코드를 컴파일하는데 필요한 R 환경을 설정하고, 
  만약 필요한 부분을 놓쳤다면 경고를 준다.


* `Rcpp::compileAttributes()`을 호출한다. `.cpp` 함수를 점검해서 
  `// [[Rcpp::export]]` 양식에서 __속성(attributes)__을 찾는다.
  속성을 찾게되면, R 에서 코드를 생성해서 함수를 이용가능하게 만들고,
  `src/RcppExports.cpp`와 `R/RcppExports.R` 파일을 생성한다.
  절대로 수작업으로 이런 파일을 변경해서는 안된다.


* DLL (dynamically linked library, 동적 링크 라이브러리)를 빌드해서 R에서 이용가능하게 만든다.


### 문서화 {#cpp-man}

각기 내보내진 C++ 함수는 자동으로 포장함수(wrapper function)를 얻는다 (`R/RcppExports.R`에 위치한다). 예를 들어, R `timesTwo()` 함수는 다음과 같이 생겼다:

```{r}
timesTwo <- function(x) {
  .Call('timesTwo', PACKAGE = 'mypackage', x)
}
```

`.Call()` 기저 함수 (base function)을 사용해서 작성한 팩키지 `timesTwo` C 함수를 실행한다.
roxygen2를 사용해서 정규 R 함수처럼 문서화할 수 있다.
하지만, 주석으로 `#'`을 사용하는 대신에 C++에서 관례로 사용되는 `//'`을 사용한다:

```cpp
//' Multiply a number by two
//' 
//' @param x A single integer.
//' @export
// [[Rcpp::export]]
int timesTwo(int x) {
   return x * 2;
}
```

상기 실행결과는 `R/RcppExports.R` 파일에 roxygen 주석을 생성한다:

```{r}
#' Multiply a number by two
#' 
#' @param x A single integer.
#' @export
timesTwo <- function(x) {
  .Call('timesTwo', PACKAGE = 'mypackage', x)
}
```

두 내보내기 지시어 간에 차이점은 중요하다:


* `[[Rcpp::export]]`은 R에 C++ 함수를 이용가능하게 한다. 
  만약 정확한 세부사항을 기억하는데 어려움이 있다면, 
  모든 것이 twos에 온다는데 주목한다: Two `/`, two `[`, two `:` and two `]`.

* `NAMESPACE` 파일에 `@export` 태그를 추가해서 작성한 팩키지 외부에 R 포장함수를 
  이용할 수 있게 만든다.

### C++ 코드 내보내기 {#cpp-export}

다른 팩키지에서 있는 C++ 코드로부터 C++ 코드를 호출할 수 있게 만들려면, 
다음을 추가한다:


```cpp
// [[Rcpp::interfaces(r, cpp)]]
```

상기 명령어는 다른 팩키지에 포함될 수 있는 헤더파일, `inst/include/mypackage.h`을 생성한다 (저수준 상세내용은 [Exporting C code]{#c-export}에 기술되어 있다).
수작업을 작성한 헤더파일과 자동으로 생성된 헤더파일을 조합하는 방법을 포함한 보다 상세한 내용은 "[Rcpp Attributes](http://dirk.eddelbuettel.com/code/rcpp/Rcpp-attributes.pdf)"을 참조한다.

### C++ 코드 가져오기 {#cpp-import}

또다른 팩키지로부터 C++ 코드를 사용하기 위해서는:


1. `DESCRIPTION` 파일에 `LinkingTo: otherPackage`을 추가한다.
  혼동스럽게도 링커(linker)와 아무 관련이 없다.
  `LinkingTo`라고 불리는 이유는 경로에 `otherPackage/include`를 추가해서
  동적으로 헤더를 통해 다른 코드에 "링크(link to)"되도록 하기 때문이다.

1. C++ 파일에 다음을 추가한다:

    ```cpp
    #include <otherPackage.h>
    ```

1. 다른 팩키지(otherPackage)에 있는 C++ 함수가 `otherPackage` 네임스페이스에 포함된다.
   함수에 접근하려면, `otherPackage::foo()`을 사용하거나, 
   `using namespace otherPackage` 명령어로 전역에서 이용할 수 있게 만든다.

### 모범사례 (Best practices) {#cpp-best-practices}

* 출력결과를 출력하려면 (`cout << ...`이 아닌) `Rcout << ...`을 사용하라.
  GUI 콘솔 혹은 (만약 `sink()`가 활성화되었다면) 파일에, 이것을 통해 
  올바른 위치에 출력한다.


* 오랜 시간이 걸리는 반복 루프(loop)에 대해서, 
  정기적으로 `Rcpp::checkUserInterrupt()`을 실행한다.
  이른 통해서 사용자가 Ctrl + C 단축키를 누르게 되면 C++ 실행을
  중단하거나 R에서 빠져나오게 한다.

* 헤더에 `.h` 확장자를 사용하고 파일에 포함하라.
  (만약 그렇지 않으면, `R CMD check` 명령어를 실행하면 불평이 터져 나온다).

* [R 팩키지를 위한 이식성 높은 C++ (Portable C++ for R packages)](http://journal.r-project.org/archive/2011-2/RJournal_2011-2_Plummer.pdf)에 나오는 마틴 플러머(Martyn Plummer) 권장사항을 따른다.

* 적성한 팩키지에서 C++ 코드를 사용할 때마다, 
  팩키지를 적재하지 않고 내릴 때 본인 스스로 청소를 할 필요가 있다.
  DLL 파일을 적재하지 않고 내리는 `.onUnload()` 함수를 작성해서 해당 작업을 수행한다:


    ```{r}
    .onUnload <- function (libpath) {
      library.dynam.unload("mypackage", libpath)
    }
    ```

* C++ 코드를 컴파일하는데 `gcc` 대신에 `clang`을 사용한다:
  이유는 훨씬 더 좋은 오류 메시지를 전달한다.
  홈디렉토리에 다음을 포함하는 파일을 리눅스와 맥에서는 `.R/Makevars` (linux and mac),
  윈도우에서는 `.R/Makevars.win` 이름으로 생성해서 `clang`을 디폴트 기본설정한다:


    ```bash
    CXX=clang++
    ```
    
    (만약 본인 홈디렉토리를 알지 못한다면, `path.expand("~")` 명령어를 통해서
    확인할 수 있다.)

* 리눅스 혹은 맥에서 컴파일 속도를 높이기 위해서 `ccache`를 설치하고 나서,
  `~/.R/Makevars` 파일을 다음으로 대체한다. 

    ```bash
    CC=ccache clang -Qunused-arguments
    CXX=ccache clang++ -Qunused-arguments
    CCACHE_CPP2=yes
    ```

## C {#clang}

만약 신규로 컴파일된 코드를 작성하려면, Rcpp를 사용하는 것이 거의 항상 더 낫다.
이유는 더 적은 작업과, 더 일관성을 갖고, 문서화도 더 잘 되고, 더 좋은 도구도 있기 때문이다. 하지만, C를 선택해야되는 사유가 몇가지 있다:


* 이미 C API를 사용하고 있는 이전 팩키지를 가지고 작업할 때.
* 기존 C 라이브러리에 바인딩될 때.

R로부터 C 함수를 호출하는 방법은 두가지다: `.C()`와 `.Call()`.
`.C()`는 R에 관해 어떤 것도 알지못하는 C 함수를 호출하는 약식으로 간편한 방식이다. 
왜냐하면 `.C()`를 통해 R 벡터를 자동으로 해당 C 자료형으로 전환하기 때문이다.
`.Call()`은 좀더 유연하지만, 조금더 작업이 요구된다: 
작성한 C 함수가 R API를 사용해서 입력값을 표준 C 자료형으로 전환한다.


### Getting started with `.Call()`

R로부터 C 함수를 호출하려면, 먼저 C 함수가 필요하다! R 팩키지에서 C 코드는 `src/` 디렉토리에 
`.c` 파일 형태로 존재한다. 헤더파일 두개를 포함할 필요가 있다.

```c
#include <R.h>
#include <Rinternals.h>
```
(맞습니다. `<Rinternals.h>`을 포함하는 것은 나쁜 형태처럼 보입니다.
이것에 더해서, 몇가지 추가 플래그 설정을 하지 않으면, 그와 같은 방식으로 "internal" 내부 API에 실제로 접근할 수가 없다. 단지 디폴트 기본만 "public" 내부 API에 접근할 수 있게 하는데 필요하기도 하고 보안을 위해서 
그렇게 한다. 맞습니다. 이 방법은 혼동을 불러일으키기에 충분하다.)

상기 헤더를 통해서 R의 C API에 접근할 수 있다.
불행하게도, 해당 API는 문서화가 잘 되어있지 않다.
저자가 작성한 [R's C interface](http://adv-r.had.co.nz/C-interface.html)에 있는 주석으로 시작해보는 것을 추천한다. 그 다음에 "R 확장 작성하기 (Writing R Extensions)"에 있는 "[The R API](http://cran.rstudio.com/doc/manuals/r-devel/R-exts.html#The-R-API)"를 읽어본다. 
내보내기 함수 일부가 문서화되지 않아서 자세한 사항을 이해하기 위해서 실제 [R 소스코드](https://github.com/wch/r-source)를 읽어볼 필요도 있다.


여기에 알아야 될 최소 지식을 적어봤다: R과 대화하는 C 함수는 입력과 출력 모두 `SEXP` 자료형을 사용해야 된다.
S 표현식(S expression)을 간략하게 줄인 `SEXP`는 C 구조체로 R에 있는 모든 객체 자료형을 표현하는데 사용된다.
일반적으로 C 함수는 `SEXP` 자료형을 (원자, atomic) C 객체로 변환해서 시작해서, C 객체를 다시 `SEXP` 자료형으로 변환해서 끝맺는다. (R API가 설계되서 이와 같은 변환에 복사는 필요하지 않게 되었다.)
다음 표에 길이가 1인 R 벡터를 C 스칼라로, 혹은 역으로 변환하는 함수 목록이 나와 있다:

  구분      | R 자료형    | C 자료형    | R -> C            |  C -> R 
------------|-------------|-------------|-------------------|-------------------
 정수형     | integer     | int         | `asInteger(x)`    | `ScalarInteger(x)`
 부동소수형 | numeric     | double      | `asReal(x)`       | `ScalarReal(x)`
 논리형     | logical     | int         | `asLogical(x)`    | `ScalarLogical(x)`
 문자형     | character   | const char* | `CHAR(asChar(x))` | `mkString(x)`

이제 두 숫자를 더할 수 있는 간단한 C 함수를 작성할 충분한 정보를 갖게 되었다:

```c
#include <R.h>
#include <Rinternals.h>

SEXP add_(SEXP x_, SEXP y_) {
  double x = asReal(x_);
  double y = asReal(y_);
  
  double sum = x + y;
  
  return ScalarReal(sum);
}
```

`.Call()` 으로 R로부터 상기 함수를 호출한다.


```{r}
#' @useDynLib mypackage add_
add <- function(x, y) .Call(add_, x, y)
```

`.Call()` 함수에 첫번째 인자, `add_`는 어디서 왔을까?
`@useDynLib`에서 왔는데 네임스페이스에 다음과 같은 행을 생성한다:


```
useDynLib(mypackage, add_)
```

상기 지시어는 R에게 하여금 C 함수 포인터를 기술하는 `add_` 라고 불리는 객체를 생성하게끔 한다:

```{r, eval = FALSE}
mypackage:::add_
#> $name
#> [1] "add_"
#> 
#> $address
#> <pointer: 0x107be3f40>
#> $package
#> NULL
#> 
#> attr(,"class")
#> [1] "NativeSymbolInfo"
```

`.Call()`는 C 함수에 포인터를 받아서 호출한다.
모든 R 객체는 동일한 C 자료형 (`SEXP`) 을 갖는데 인자가 예상한 자료형이라는 것을 확실히 할 필요가 있다.
R 함수에서 혹은 C 함수에서도, 우연히 틀린 자료형이 입력값으로 넘겨질 때마다 R이 시스템 충돌로 말미암아 정상 동작하지 못한다는 것을 받아드려라. 

`.Call()` 인터페이스를 작업할 때 가장 복잡한 부분이 메모리 관리다.
R-수준에서 자료구조를 생성할 때마다,
`PROTECT()` 함수로 보호해서 쓰레기 수집기(garbage collector)가 동작하지 못하게 해야된다. 그리고 나서, 함수 마지막에 `UNPROTECT()` 함수로 보호를 풀어준다.
이 주제는 이번 장 범위 밖이다. 하지만 <http://adv-r.had.co.nz/C-interface.html#c-vectors>에서 좀더 많은 사항을 학습할 수 있다.


### `.C()`으로 시작하기

`.C()`는 `.Call()` 보다 더 단순하다. 만약 표준 C 코드가 있다면 유용할 수 있다.
`.C()`에 R 객체를 결코 생성할 수 없기 때문에,
메모리 관리는 걱정할 필요가 전혀 없다.
`.C()`을 사용하려면, 빈 보이드(void) C 함수를 먼저 작성한다. 값을 반환하기 위해서 함수 매개변수 제자리(inplace) 변형을 사용한다: 


```c
void add_(double* x, double* y, double* out) {
  out[0] = x[0] + y[0];
}
```

그리고 나서, `.Call()` 처럼, R 포장(wrapper)함수를 생성한다:


```{r, eval = FALSE}
#' @useDynLib mypackage add_
add <- function(x, y) {
  .C(add_, x, y, numeric(1))[[3]]
}
```

(여기서 out 매개변수에 대응되기 때문에 연산결과 세번째 요소를 추출한다.)

`.C()`는 자동으로 R 벡터와 상응하는 C 자료형을 왔다갔다 하면서 변환한다:


    구분        |   R 자료형    | C 자료형
----------------|---------------|----------
 논리형         |   logical     | `int*`
 정수형         |   integer     | `int*`
부동소수형      |   double	    | `double*`
  문자형        |   character   | `char**`
부호없는 문자형 |   raw	        | `unsigned char*`

`.C()`는 함수가 결측값 처리방법을 알지 못한다고 가정해서 만약 특정 인자가 NA를 포함하면 오류를 던지는데 주의한다.
결측값을 올바르게 처리하려면, `.C()` 호출에 `NAOK = TRUE` 를 설정한다.

`.C()` 관한 더 많은 정보는 `?.C` 도움말과 [R-extensions](http://cran.rstudio.com/doc/manuals/r-devel/R-exts.html#Interface-functions-_002eC-and-_002eFortran)에서 찾을 수 있다.


### 작업흐름 {#c-workflow}

여전히 일반적인 작업흐름이 여기서도 적용된다:

1.  C 코드를 변현한다.
1.  Ctrl/Cmd + Shift + B 단축키로 팩키지를 빌드하고 다시 적재한다.
1.  콘솔에서 실험해 나간다.

`@useDynLib` 태그를 처음으로 추가할 때, `devtools::document()` (단축키는 Ctrl/Cmd + Shift + D) 명령어도 실행해서 팩키지를 다시 적재할 필요가 있다.


### C 코드 내보내기 {#c-export}

R 팩키지는 재배치(relocate)될 수 있는 DLLs을 제공할 필요가 있다: 하드디스크 위치에 관계없이 동작하는 DLLs.
이유는 R 사용자 대부분이 소스코드에서 팩키지를 빌드하지는 않기 때문이다.
대신에, 사용자는 통상 다양한 장소에서 설치될 수 있는 바이너리를 CRAN에서 얻는다.
재배치될 수 있는 DLLs에 대한 필요로 말미암아 R 팩키지에 C 코드를 가져오고 내보내기하는 작업에 몇 단계가 추가된다
(동일한 문제가 C++에도 발생하지만, Rcpp 속성을 통해서 다음에 기술되는 수작업 단계를 자동화한다).


__함수등록(function registration)__을 사용해서 R에서는 이 문제를 해결한다.
`.Call()` C 함수를 내보내려면, `R_RegisterCCallable()` 명령어로 함수를 등록한다.
`.Call()` C 함수를 가져오려면, `R_GetCCallable()` 명령어로 해당하는 포인터를 가져온다.
유사한 기법이 `.C()` C 함수에도 가능하지만, 이 책 범위를 벗어난다.
다음에 살펴보듯이, 사용자 친화적인 팩키지는 이런 작업을 모두 수행한다. 그래서,
세부사항을 팩키지 사용자는 무시하고 넘어갈 수 있고 단지 헤더 파일만 포함한다.


[관련 기사: 혼동스럽게도, 또다른 유형의 함수 등록이 있다.
네임스페이스를 사용해서 C 함수를 등록(예를 들어, `@useDynLib pkg fun`)하는 대신에, 
C 함수를 `R_registerRoutines()`와 `@useDynLib mypackage, .registration = TRUE`으로 등록할 수 있다.
자세한 사항을 학습하기 위해서 "R 확장 작성하기 (Writing R extensions)"에 나와있는 [Registering native extensions](http://cran.r-project.org/doc/manuals/R-exts.html#Registering-native-routines)을 읽어본다.


함수를 등록하려면, `<R_ext/Rdynload.h>`에 정의된 `R_RegisterCCallable()`을 호출한다.
함수등록은 `R_init_<mypackage>`로 불리는 함수에서 수행되어야 된다.
작성중인 "mypackage" DLL이 적재될 때 이 함수가 자동으로 호출된다.
`R_RegisterCCallable()`는 인자가 세개 있다:

* DLL을 향한 포인터
* 함수 명칭
* `DL_FUNC`(즉, **d**ynamically **l**oaded **func**tion)으로 자료형 변환되는 함수를 향한 포인터. 

다음 코드는 위에서 정의한 `add()` 함수를 등록한다:

```c
#include "add.h"
#include <R_ext/Rdynload.h>

void R_init_mypackage(DllInfo *info) {
  R_RegisterCCallable(info, "add_",  (DL_FUNC) &add_)
}
```

상기 코드 위치는 문제되지 않지만, 일반적으로 `src/mypackage-init.c` 라는 파일에 넣어둔다.

또다른 팩키지로부터 등록된 함수에 접근하려면, `R_GetCCallable()` 함수를 호출한다.
함수명칭과 팩키지 명칭, 인자를 두개 갖고, 함수 포인터를 반환한다.
함수 포인터는 자료형에 대한 정보가 없다. 그래서, 입력값을 정의하는 도움말 함수에 항상 포장되어 감싸져야(wrap)만 된다:

```c
#include <R_ext/Rdynload.h>
#include <R.h>
#include <Rinternals.h>

SEXP add_(SEXP x, SEXP y) {
  static SEXP(fun*)(SEXP, SEXP) = NULL;
  if (fun == NULL)
    fun = (SEXP(*)(SEXP, SEXP)) R_GetCCallable("add", "mypackage");
  return fun(x, y);
}
```

이 작업을 올바르게 수행하도록 작성한 C 코드를 가져오는 각 팩키지에 의존하기 보다,
대신에 그 작업을 수행해야 한다.
가져온 각 함수에 포장 함수(wrapper function)를 제공하는 `inst/include/mypackageAPI.h` 파일을 작성한다.
이 작업을 수행하는 대중적인 팩키지가 [xts](http://cran.r-project.org/web/packages/xts/)다.
소스코드 팩키지를 다운로드해서 무슨 작업을 수행하는지 `include/` 디렉토리 내부를 들여다 보라.


### C 코드 가져오기 {#c-import}

Using C code from another package varies based on how the package is implemented:

* If it uses the system described above, all you need is `LinkingTo: otherPackage` 
  in the `DESCRIPTION`, and `#include otherPackageAPI.h` in the C file. (Remember 
  `LinkingTo` is not about the linker, but actually affects the include path).
   
* If it registers the functions, but doesn't provide a header file, you'll
  need to write the wrapper yourself. Since you're not using any header
  files from the package, use `Imports` and not `LinkingTo`. You also need to 
  make sure the package is loaded. You can do this by importing any function 
  with `@importFrom mypackage foo`, or by adding `requireNamespace("mypackage", 
  quietly = TRUE)` to `.onLoad()`.
  
* If it doesn't register the functions, you can't use them. You'll have to
  ask the maintainer nicely or even provide a pull request.

### Best practices {#c-best-practices}

* Avoid calls to `assert()`, `abort()` and `exit()`: these will kill the 
  R process, not just your C code. Instead, use `error()` which is 
  equivalent to calling `stop()` in R.

* To print output use `Rprintf()`, not `printf()`. Doing so always prints to 
  the right place, whether it's the GUI console or a file (if `sink()` is 
  active).

* In long-running loops, regularly call `R_CheckUserInterrupt()` to allow
  the user to interrupt the C code.

* Don't use C's random number generators (like `rand()` or `random()`), 
  instead use the C API to R's rngs: `unif_rand()`, `norm_rand()`, etc. 
  Note the caveats in ["Random number generation"](http://cran.rstudio.com/doc/manuals/r-devel/R-exts.html#Random-numbers) - you must call `GetRNGstate()` before and 
  `PutRNGstate()` after.

* Use R macros `ISNAN(x)` and `R_FINITE(x)` to check for NaNs and infinite
  values. These work on more platforms than the C99 `isnan()` and `isfinite()`.

* Like with C++, whenever you use C code in your package, you should unload the 
  DLL when the package is unloaded:

    ```{r}
    .onUnload <- function (libpath) {
      library.dynam.unload("mypackage", libpath)
    }
    ```

* Use `clang` instead of `gcc` to compile your C code: it gives much 
  better error messages. You can make `clang` the default by creating a
  `~/.R/Makevars` that contains:

    ```bash
    C=clang
    ```

## Debugging compiled code {#src-debugging}

It's possible, with a little extra work, to use an interactive debugger to debug your C/C++ in the same way that you can use `browser()` and `debug()` to debug your R code. Unfortunately you won't be able to use RStudio, you'll have to run R from the command line. 

Open a shell (e.g. with Tools | Shell...) and start R by typing:

```bash
# If you compile with clang
R --debugger=lldb
# If you compile with gcc
R --debugger=gdb
```

This will start either [lldb](http://lldb.llvm.org) or [gdb](http://www.gnu.org/software/gdb/), the debuggers that work with code produced by `clang` or `gcc` respectively. Like R, `lldb` and `gdb` provide a REPL, a run-eval-print loop where you enter commands and then look at the results. In the examples below I'll show the results of `lldb`, which is what I use (the output from `gdb` is similar). For each interactive command I'll tell you the explicit, but long, `lldb` command and the short, but cryptic, `gdb` command. Because `lldb` understand all `gdb` commands, you can use choose to be explicit of terse.

Once you've started the debugger, start R by typing `process start` (lldb) or `run` (gdb). Now when your C/C++ code crashes you'll be dumped into an interactive debugger instead of getting a cryptic error message and a crash. 

Let's start with a simple C++ function that writes to memory it doesn't "own":

```{r, eval = FALSE}
Rcpp::cppFunction("
bool mistake() {
  NumericVector x(1);
  int n = INT_MAX;
  x[n] = 0;
  return true;
}
", plugins = "debug", verbose = TRUE, rebuild = TRUE)
mistake()
```


Use `devtools::load_all()` to load the current package. Then copy and paste the code that creates the bug. Here's a crash report from a package I was working on:

```
Process 32743 stopped
* thread #1: tid = 0x1f79f6, 0x... gggeom.so...`
   frame #0: 0x0.. gggeom.so`vw_distance(x=..., y=...) + ... at vw-distance.cpp:54
   51        int prev_idx = prev[idx];
   52  	
   53  	    next[prev[idx]] = next_idx;
-> 54  	    prev[next[idx]] = prev_idx;
   55  	    prev[idx] = -1;
   56  	    next[idx] = -1;
   57
```

It tells us that the crash occurred because of a `EXC_BAD_ACCESS` - this is one of the most common types of crash in C/C++ code. Helpfully, lldb shows exactly which line of C++ code caused the problem: `vw-distance.cpp:54`. Often just knowing where the problem occurs is enough to fix it. But we're also now at an interactive prompt. There are many commands you can run here to explore what's going on. The most useful are listed below:

* See a list of all commands: `help`.

* Show your location on the callstack with `thread backtrace`/`bt`. This
  will print a list of calls leading up to the error, much like `traceback()`
  does in R. Navigate the callstack with `frame select <n>`/`frame <n>`, or 
  `up` and `down`.

* Evaluate the next expression with `thread step-over`/`next`, or step into it
  with `thread step-in`/`step`. Continue executing the rest of the code with
  `thread step-out`/`finish`

* Show all variables defined in the current frame with `frame variable`/
  `info locals`, or print the value of a single variable with 
  `frame variable <var>`/`p <var>`.

Instead of waiting for a crash to occur you can also set breakpoints in your code. To do so, start the debugger, run R, then:

1. Press `Ctrl + C`

1. Type `breakpoint set --file foo.c --line 12`/`break foo.c:12`.

1. `process continue`/`c` to go back to the R console. Now run the C code
   you're interested in, and the debugger will stop when it gets to the 
   specified line.

Finally, you can also use the debugger if your code is stuck in an infinite loop. Press `Ctrl + C` to break into the debugger and you'll see which line of code is causing the problem.

## Makefiles {#make}

While makefiles are beyond the scope of this book, they are a useful tool. A good, gentle introduction with a focus on reproducible research is Karl Broman's ["Minimal make"](http://kbroman.org/minimal_make/).

Generally, R packages should avoid a custom `Makefile`. Instead, use `Makevars`. `Makevars` is a make file that overrides the default make file generated by R (which is located at `file.path(R.home("etc"), "Makeconf")`). This allows you to take advantage of R's default behaviour (it's over 150 lines, and battle-tested across many years and many systems, so you want to!) while being able to set the flags you need. The most commonly used flags are:

* `PKG_LIBS`: Linker flags. A common use is `PKG_LIBS = $(BLAS_LIBS)`. This
  allows you to use the same BLAS library as R.

* `PKG_CFLAGS` & `PKG_CXXFLAGS`: C and C++ flags. Most commonly used to set 
  define directives with `-D`.

* `PKG_CPPFLAGS`: Pre-processor flags (not C++ flags!). Most commonly used to
  set include directories with `-I`. Any package listed in the `LinkingTo` field
  in the `DESCRIPTION` will be automatically included - you do not need to
  explicitly add it.

To set flags only on Windows, use `Makevars.win`. To build a `Makevars` with `configure`, use `Makevars.in`.

By default, R will use the system make, which is not always GNU compatible (i.e. on Solaris). If you want to use GNU extensions (which are extremely common), add `SystemRequirements: GNU make` to `DESCRIPTION`. If you're not sure if you're using GNU extensions, play it safe and add it to the system requirement.

## Other languages {#src-other}

It is possible to connect R to other languages, but the interfaces are not as nice as the one for C++:

* __Fortran__: It's possible to call Fortran subroutines directly with 
  `.Fortran()`, or via C or C++ with `.Call()`. See `?.Fortran` and 

* __Java__: The [rJava](https://github.com/s-u/rJava) package makes it 
  possible to call Java code from within R. Note that unlike with C and C++,
  passing an R object to a Java call will involve a copy operation, something 
  which has serious performance implications.

## Licensing {#src-licensing}

Because it's common to use other peoples' libraries when writing compiled code, you need to make sure that your package license is compatible with the licenses of all included code:

* The simplest solution is to use the same license as the included code. Since 
  you can't relicense someone else's code, you may need to change your license.

* If you don't want to use the same license, you're best sticking
  with common cases where the interactions are well known. For example, 
  [Various Licenses and Comments about Them](https://www.gnu.org/licenses/license-list.html)
  describes what licenses are compatible with the GPL license.
  
  In this case your description should contain 
  `License: <main license> + FILE license` where `<main license>` is a license 
  that is valid for the entire package (both R and compiled code), and the 
  `license` file describes the licenses of individual components.

* For non-standard cases, you'll need to consult a lawyer.

In all cases, make sure you include copyright and license statements from the original code.

## Development workflow {#src-workflow}

When developing C or C++ code, it's usually better to use RStudio's Build & Reload instead of `devtools::load_all()`. If you have C objects that persist between reloads, and you change the data structure, then it's 

## CRAN issues {#src-cran}

Packages with compiled code are much more likely to have difficulties getting on CRAN than those without. The reason? Your package must build from source on all major platforms (Linux, Mac and Windows). This is hard! 

* CRAN provides an automated service for checking R packages on windows: 
  [win-builder](http://win-builder.r-project.org). You can easily access this
  by running `devtools::build_win()`, which builds and uploads a package bundle.
  
* I've tried to include the most important advice in this chapter, but I'd
  recommend reading the entire section on [writing portable C and C++ code](http://cran.rstudio.com/doc/manuals/r-devel/R-exts.html#Portable-C-and-C_002b_002b-code) in "Writing
  R extensions".

* In exceptional circumstances, like binding to Windows-only functionality, 
  you may be able to opt-out of cross-platform requirement, but be prepared    
  to make a strong case for it.

The interface between CRAN's automated and manual checking can be particularly frustrating for compiled code. Requirements vary from submission to submission, based on which maintainer you get and how much free time they have. The rules are inconsistently applied, but if your package doesn't pass, it's better to bite the bullet and make the change rather than trying to argue about it:

  * Sometimes you will need to list all authors and copyright holders of included 
    code in the DESCRIPTION. 
  
  * Sometimes your package will need to work on Solaris. But due to the difficulty 
    of accessing a computer running Solaris, fixing Solaris issues can be hard. 
    However, you will be in a stronger negotiating position if the package has no 
    problems on other platforms. 
  
    One common gotcha: gcc/clang flags `-Wall`, `-pedantic` and `-O0` do not work 
    with the default compiler on Solaris.

