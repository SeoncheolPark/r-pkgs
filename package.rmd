---
layout: default
title: Package structure
output: bookdown::html_chapter
---

# 팩키지 구조 {#package-structure}

이번 장은 첫번째 팩키지를 생성함으로써 여러분을 팩키지 개발을 시작한다. 또한, 팩키지를 설치할 때 발생하는 것을 포함하여 팩키지가 있을 수 있는 다양한 상태에 관해서도 학습할 것이다. 마지막으로, 팩키지(package)와 라이브러리(library) 차이점, 그리고 왜 이러한 차이점에 주목하는지도 배울 것이다.


## 팩키지 작명 (Naming package) {#naming}

> "컴퓨터 과학에서 두가지 어려운 것이 있다: 작명(naming)과 캐쉬 무효화(cache invalidation)"
> "There are only two hard things in Computer Science: cache invalidation and 
> naming things." 
>
> --- Phil Karlton

첫번째 팩키지를 생성하기 전에, 팩키지에 대한 이름을 제시할 필요가 있다.
개인적으로 팩키지 생성에 가장 어려운 부분이라고 생각한다! (`devtools`가 여러분을 위해 자동화를 수행할 수 없기 때문에 그런 것은 최소한 아니다.)


### 명칭에 대한 요구사항 

세가지 형식 요건이 있다: 명칭은 문자, 숫자, 그리고 `.` 즉, 마침표으로만 구성될 수 있고; 문자로 시작되어야 하고; 마침표로 끝날 수 없다.
불행하게도, 이것이 의미하는 바는 팩키지 명칭으로 하이픈(`-`)과 밑줄(`_`) 어떤 것도 사용할 수 없다는 것이다.
팩키지 명칭에는 마침표를 사용하지 않는 것을 추천하는데 사유는 혼란을 줄 수 있는 의미를 내포하기 때문이다. (즉, 파일 확장자 혹은 S3 메쏘드)


### 작명 전략

만약 팩키지 출시 계획을 가지고 있다면, 최소 몇분 정도 시간을 갖고 좋은 명칭을 생각해 보는 것이 좋다.
다음에 작명하는 방법에 대한 몇가지 추천사항이 있다:

* 쉽게 인터넷 검색(구글링, 네이버 검색)할 수 있는 유일한 이름을 선정한다.
  이렇게 함으로써 잠재적 사용자가 개발한 팩키지와 연관된 정보를 쉽게 찾게 하고, 개발자는 누가 팩키지를 사용하는지 쉽게 알 수 있게 한다.
  <http://cran.r-project.org/web/packages/[PACKAGE_NAME]>을 통해서 이름이 이미 CRAN에 점유되었는지도 확인할 수 있다.

* 대문자와 소문자를 함께 사용하는 것은 피한다: 대소문자를 섞게하면 팩키지 명칭을 타이핑하기 어렵게 하고 기억하는 것조차도 더 어렵다.
  예를 들어, Rgtk2 혹은 RGTK2 혹은 RGtk2 인지 절대로 기억할 수 없다.

* 문제를 야기할 수 있는 단어를 찾아서 변형해서 유일하게 만든다: 

    * `plyr`은 apply 패밀리의 일반화이며 pliers를 떠올리게 한다.
    * `lubridate`는 날짜와 시간을 더 쉽게 만든다.
    * `knitr` (knit + r) 은 `sweave` (s + weave) 보다 더 "단아(neater)"하다.
    * `testdat`는 데이터가 올바른 형식인지 테스트한다.

* 축약을 사용한다: 

    * `Rcpp` = R + C++ (plus plus)
    * `lvplot` = letter value plots. 

* 추가로 R을 더한다:

    * `stringr`은 문자열 도구다.
    * `tourr`은 시각화 메쏘드로 두루 보여준다.
    * `gistr`은 GitHub gists 서비스를 프로그램적으로 생성하고 변형하게 한다.

상업 서비스로 연결되는 팩키지를 생성한다면, 이후로 발생할 문제를 회피하고자 브랜딩 지침을 확실히 점검한다.
예를 들어 `rDrop`은 `rDropbox`로 불릴 수 없는데 이유는 Dropbox가 어떤 응용프로그램도 전체 상표이름을 사용하지 못하게 금하고 있기 때문이다.


## Creating a package {#getting-started}

Once you've come up with a name, there are two ways to create the package. You can use RStudio:

1. Click File | New Project.

2. Choose "New Directory":

    ```{r, echo = FALSE}
    bookdown::embed_png("screenshots/create-1.png", dpi = 220)
    ```
   
2. Then "R Package":

    ```{r, echo = FALSE}
    bookdown::embed_png("screenshots/create-2.png", dpi = 220)
    ```

2. Then give your package a name and click "Create Project":

    ```{r, echo = FALSE}
    bookdown::embed_png("screenshots/create-3.png", dpi = 220)
    ```
    
Alternatively, you can create a new package from within R by running

```{r, eval = FALSE}
devtools::create("path/to/package/pkgname")
```
    
Either route gets you to the same place: the smallest usable package, one with three components:

1. An `R/` directory, which you'll learn about in [R code](#r).

1. A basic `DESCRIPTION` file, which you'll learn about in 
   [package metadata](#description).

1. A basic `NAMESPACE` file, which you'll learn about in 
   [the namespace](#namespace).

It will also include an RStudio project file, `pkgname.Rproj`, that makes your package easy to use with RStudio, as described below.

Don't use `package.skeleton()` to create a package. Following that workflow actually creates more work for you because it creates extra files that you'll have to delete or modify before you can have a working package.

## RStudio projects {#projects}

To get started with your new package in RStudio, double-click the `pkgname.Rproj` file that `create()` just made. This will open a new RStudio project for your package. Projects are a great way to develop packages because:

*   Each project is isolated; code run in one project does not affect any 
    other project.

*   You get handy code navigation tools like `F2` to jump to a function
    definition and `Ctrl + .` to look up functions by name.

*   You get useful keyboard shortcuts for common package development tasks.
    You'll learn about them throughout the book. But to see them all, press 
    Alt + Shift + K or use the Help | Keyboard shortcuts menu.
    
    ```{r, echo = FALSE}
    bookdown::embed_png("screenshots/keyboard-shortcuts.png")
    ```
   
(If you want to learn more RStudio tips and tricks, follow @[rstudiotips](https://twitter.com/rstudiotips) on twitter.)

Both RStudio and `devtools::create()` will make an `.Rproj` file for you. If you have an existing package that doesn't have an `.Rproj` file, you can use `devtools::use_rstudio("path/to/package")` to add it. If you don't use RStudio, you can get many of the benefits by starting a new R session and ensuring the working directory is set to the package directory. 

### What is an RStudio project file?

An `.Rproj` file is just a text file. The project file created by devtools looks like this:

```
Version: 1.0

RestoreWorkspace: No
SaveWorkspace: No
AlwaysSaveHistory: Default

EnableCodeIndexing: Yes
Encoding: UTF-8

AutoAppendNewline: Yes
StripTrailingWhitespace: Yes

BuildType: Package
PackageUseDevtools: Yes
PackageInstallArgs: --no-multiarch --with-keep.source
PackageRoxygenize: rd,collate,namespace
```

You don't need to modify this file by hand. Instead, use the friendly project options dialog box, accessible from the projects menu in the top-right corner of RStudio.

```{r, echo = FALSE}
bookdown::embed_png("screenshots/project-options-1.png", dpi = 220)
bookdown::embed_png("screenshots/project-options-2.png", dpi = 220)
```

## What is a package? {#package}

To make your first package, all you need to know is what you've learnt above. To master package development, particularly when you're distributing a package to others, it really helps to understand the five states a package can be in across its lifecycle: source, bundled, binary, installed and in-memory. Understanding the differences between these states will help you form a better mental model of what `install.packages()` and `devtools::install_github()` do, and will make it easier to debug problems when they arise.

### Source packages

So far, we've just worked with a __source__ package: the development version of a package that lives on your computer. A source package is just a directory with components like `R/`, `DESCRIPTION`, and so on.

### Bundled packages

A __bundled__ package is a package that's been compressed into a single file. By convention (from Linux), package bundles in R use the extension `.tar.gz`. This means that multiple files have been reduced to a single file (`.tar`) and then compressed using gzip (`.gz`). While a bundle is not that useful on its own, it's a useful intermediary between the other states. In the rare case that you do need a bundle, call `devtools::build()` to make it. 

If you decompress a bundle, you'll see it looks almost the same as your source package. The main differences between an uncompressed bundle and a source package are:

* Vignettes are built so that you get HTML and PDF output instead of 
  Markdown or LaTeX input.

* Your source package might contain temporary files used to save time during
  development, like compilation artefacts in `src/`. These are never found in 
  a bundle.
  
* Any files listed in `.Rbuildignore` are not included in the bundle.

`.Rbuildignore` prevents files in the source package from appearing in the bundled package. It allows you to have additional directories in your source package that will not be included in the package bundle. This is particularly useful when you generate package contents (e.g. data) from other files. Those files should be included in the source package, but only the results need to be distributed. This is particularly important for CRAN packages (where the set of allowed top-level directories is fixed). Each line gives a Perl-compatible regular expression that is matched, without regard to case, against the path to each file (i.e. `dir(full.names = TRUE)` run from the package root directory) - if the regular expression matches, the file is excluded. 

If you wish to exclude a specific file or directory (the most common use case), you __MUST__ anchor the regular expression. For example, to exclude a directory called notes, use `^notes$`. The regular expression `notes` will match any file name containing notes, e.g. `R/notes.R`, `man/important-notes.R`, `data/endnotes.Rdata`, etc. The safest way to exclude a specific file or directory is to use `devtools::use_build_ignore("notes")`, which does the escaping for you.

Here's a typical `.Rbuildignore` file from one of my packages:

```
^.*\.Rproj$         # Automatically added by RStudio,
^\.Rproj\.user$     # used for temporary files. 
^README\.Rmd$       # An Rmarkdown file used to generate README.md
^cran-comments\.md$ # Comments for CRAN submission
^NEWS\.md$          # A news file written in Markdown
^\.travis\.yml$     # Used for continuous integration testing with travis
```

I'll mention when you need to add files to `.Rbuildignore` whenever it's important.

### Binary packages

If you want to distribute your package to an R user who doesn't have package development tools, you'll need to make a __binary__ package. Like a package bundle, a binary package is a single file. But if you uncompress it, you'll see that the internal structure is rather different from a source package: 

* There are no `.R` files in the `R/` directory - instead there are three
  files that store the parsed functions in an efficient file format. This is
  basically the result of loading all the R code and then saving the
  functions with `save()`. (In the process, this adds a little extra metadata to 
  make things as fast as possible).

* A `Meta/` directory contains a number of `Rds` files. These files contain 
  cached metadata about the package, like what topics the help files cover and
  parsed versions of the `DESCRIPTION` files. (You can use `readRDS()` to see 
  exactly what's in those files). These files make package loading faster
  by caching costly computations.

* An `html/` directory contains files needed for HTML help.

* If you had any code in the `src/` directory there will now be a `libs/`
  directory that contains the results of compiling 32 bit (`i386/`) and 64 bit 
  (`x64/`) code.
  
* The contents of `inst/` are moved to the top-level directory.

Binary packages are platform specific: you can't install a Windows binary package on a Mac or vice versa. Also, while Mac binary packages end in `.tgz`, Windows binary packages end in `.zip`. You can use `devtools::build(binary = TRUE)` to make a binary package. 

The following diagram summarises the files present in the root directory for source, bundled and binary versions of devtools.

```{r, echo = FALSE}
bookdown::embed_png("diagrams/package-files.png")
```

### Installed packages {#install}

An __installed__ package is just a binary package that's been decompressed into a package library (described below). The following diagram illustrates the many ways a package can be installed. This diagram is complicated! In an ideal world, installing a package would involve stringing together a set of simple steps: source -> bundle, bundle -> binary, binary -> installed. In the real world, it's not this simple because there are often (faster) shortcuts available.

```{r, echo = FALSE}
bookdown::embed_png("diagrams/installation.png")
```

The tool that powers all package installation is the command line tool `R CMD INSTALL` - it can install a source, bundle or a binary package. Devtools functions provide wrappers that allow you to access this tool from R rather than from the command line. `devtools::install()` is effectively a wrapper for `R CMD INSTALL`. `devtools::build()` is a wrapper for `R CMD build` that turns source packages into bundles. `devtools::install_github()` downloads a source package from GitHub, runs `build()` to make vignettes, and then uses `R CMD INSTALL` to do the install. `devtools::install_url()`, `devtools::install_gitorious()`, `devtools::install_bitbucket()` work similarly for packages found elsewhere on the internet.

`install.packages()` and `devtools::install_github()` allow you to install a remote package. Both work by downloading and then installing the package. This makes installation very speedy. `install.packages()` is used to download and install binary packages built by CRAN. `install_github()` works a little differently - it downloads a source package, builds it and then installs it.

You can prevent files in the package bundle from being included in the installed package using `.Rinstignore`. This works the same way as `.Rbuildignore`, described above. It's rarely needed.

### In memory packages

To use a package, you must load it into memory. To use it without providing the package name (e.g. `install()` instead of `devtools::install()`), you need to attach it to the search path. R loads packages automatically when you use them. `library()` (and the later discussed `require()`) load, then attach an installed package.

```{r, eval = FALSE}
# Automatically loads devtools
devtools::install()
    
# Loads and _attaches_ devtools to the search path
library(devtools)
install()
```

The distinction between loading and attaching packages is not important when you're writing scripts, but it's very important when you're writing packages. You'll learn more about the difference and why it's important in [search path](#search-path).

`library()` is not useful when you're developing a package because you have to install the package first. In future chapters you'll learn about `devtools::load_all()` and RStudio's "Build and reload", which allows you to skip install and load a source package directly into memory:

```{r, echo = FALSE}
bookdown::embed_png("diagrams/loading.png")
```

## What is a library? {#library}

A library is simply a directory containing installed packages. You can have multiple libraries on your computer. In fact, almost every one has at least two: one for packages you’ve installed, and one for the packages that come with every R installation (like base, stats, etc). Normally, the directories with user-installed packages vary based on the version of R that you’re using. That's why it seems like you lose all of your packages when you reinstall R --- they're still on your hard drive, but R can't find them. 

You can use `.libPaths()` to see which libraries are currently active. Here are mine:

```{r, eval = FALSE}
.libPaths()
#> [1] "/Users/hadley/R"                                               
#> [2] "/Library/Frameworks/R.framework/Versions/3.1/Resources/library"
lapply(.libPaths(), dir)
#> [[1]]
#>   [1] "AnnotationDbi"   "ash"             "assertthat"     
#>   ...      
#> [163] "xtable"          "yaml"            "zoo"            
#> 
#> [[2]]
#>  [1] "base"         "boot"         "class"        "cluster"     
#>  [5] "codetools"    "compiler"     "datasets"     "foreign"     
#>  [9] "graphics"     "grDevices"    "grid"         "KernSmooth"  
#> [13] "lattice"      "MASS"         "Matrix"       "methods"     
#> [17] "mgcv"         "nlme"         "nnet"         "parallel"    
#> [21] "rpart"        "spatial"      "splines"      "stats"       
#> [25] "stats4"       "survival"     "tcltk"        "tools"       
#> [29] "translations" "utils"
```

The first lib path is for the packages I've installed (I've installed at lot!). The second is for so-called "recommended" packages that come with every installation of R.

When you use `library(pkg)` or `require(pkg)` to load a package, R looks through each path in `.libPaths()` to see if a directory called `pkg` exists. If it doesn't exist, you'll get an error message:

```{r, error = TRUE}
library(blah)
# or:
require(blah)
```

The main difference between `library()` and `require()` is what happens if a package isn't found. While `library()` throws an error, `require()` prints a warning message and returns FALSE. In practice, this distinction isn't important because when building a package you should __NEVER__ use either inside a package. See [package dependencies](#dependencies) for what you should do instead.

When you start learning R, it's easy to get confused between libraries and packages because you use `library()` function to load a _package_. However, the distinction between the two is important and useful. For example, one important application is packrat, which automates the process of managing project specific libraries. With packrat, when you upgrade a package in one project, it only affects that project, not every project on your computer. This is useful because it allows you to play around with cutting-edge packages without affecting other projects' use of older, more reliable packages. This is also useful when you're both developing and using a package.
