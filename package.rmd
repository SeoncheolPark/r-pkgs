---
layout: default
title: Package structure
output: bookdown::html_chapter
---

# 팩키지 구조 {#package-structure}

이번 장은 첫번째 팩키지를 생성함으로써 여러분을 팩키지 개발을 시작한다. 또한, 팩키지를 설치할 때 발생하는 것을 포함하여 팩키지가 있을 수 있는 다양한 상태에 관해서도 학습할 것이다. 마지막으로, 팩키지(package)와 라이브러리(library) 차이점, 그리고 왜 이러한 차이점에 주목하는지도 배울 것이다.


## 팩키지 작명 (Naming package) {#naming}

> "컴퓨터 과학에서 두가지 어려운 것이 있다: 작명(naming)과 캐쉬 무효화(cache invalidation)"
> "There are only two hard things in Computer Science: cache invalidation and 
> naming things." 
>
> --- Phil Karlton

첫번째 팩키지를 생성하기 전에, 팩키지에 대한 이름을 제시할 필요가 있다.
개인적으로 팩키지 생성에 가장 어려운 부분이라고 생각한다! (`devtools`가 여러분을 위해 자동화를 수행할 수 없기 때문에 그런 것은 최소한 아니다.)


### 명칭에 대한 요구사항 

세가지 형식 요건이 있다: 명칭은 문자, 숫자, 그리고 `.` 즉, 마침표으로만 구성될 수 있고; 문자로 시작되어야 하고; 마침표로 끝날 수 없다.
불행하게도, 이것이 의미하는 바는 팩키지 명칭으로 하이픈(`-`)과 밑줄(`_`) 어떤 것도 사용할 수 없다는 것이다.
팩키지 명칭에는 마침표를 사용하지 않는 것을 추천하는데 사유는 혼란을 줄 수 있는 의미를 내포하기 때문이다. (즉, 파일 확장자 혹은 S3 메쏘드)


### 작명 전략

만약 팩키지 출시 계획을 가지고 있다면, 최소 몇분 정도 시간을 갖고 좋은 명칭을 생각해 보는 것이 좋다.
다음에 작명하는 방법에 대한 몇가지 추천사항이 있다:

* 쉽게 인터넷 검색(구글링, 네이버 검색)할 수 있는 유일한 이름을 선정한다.
  이렇게 함으로써 잠재적 사용자가 개발한 팩키지와 연관된 정보를 쉽게 찾게 하고, 개발자는 누가 팩키지를 사용하는지 쉽게 알 수 있게 한다.
  <http://cran.r-project.org/web/packages/[PACKAGE_NAME]>을 통해서 이름이 이미 CRAN에 점유되었는지도 확인할 수 있다.

* 대문자와 소문자를 함께 사용하는 것은 피한다: 대소문자를 섞게하면 팩키지 명칭을 타이핑하기 어렵게 하고 기억하는 것조차도 더 어렵다.
  예를 들어, Rgtk2 혹은 RGTK2 혹은 RGtk2 인지 절대로 기억할 수 없다.

* 문제를 야기할 수 있는 단어를 찾아서 변형해서 유일하게 만든다: 

    * `plyr`은 apply 패밀리의 일반화이며 pliers를 떠올리게 한다.
    * `lubridate`는 날짜와 시간을 더 쉽게 만든다.
    * `knitr` (knit + r) 은 `sweave` (s + weave) 보다 더 "단아(neater)"하다.
    * `testdat`는 데이터가 올바른 형식인지 테스트한다.

* 축약을 사용한다: 

    * `Rcpp` = R + C++ (plus plus)
    * `lvplot` = letter value plots. 

* 추가로 R을 더한다:

    * `stringr`은 문자열 도구다.
    * `tourr`은 시각화 메쏘드로 두루 보여준다.
    * `gistr`은 GitHub gists 서비스를 프로그램적으로 생성하고 변형하게 한다.

상업 서비스로 연결되는 팩키지를 생성한다면, 이후로 발생할 문제를 회피하고자 브랜딩 지침을 확실히 점검한다.
예를 들어 `rDrop`은 `rDropbox`로 불릴 수 없는데 이유는 Dropbox가 어떤 응용프로그램도 전체 상표이름을 사용하지 못하게 금하고 있기 때문이다.


## 팩키지 생성하기 {#getting-started}

팩키지 명칭을 정했으면, 팩키지를 생성하는 두가지 방법이 있다.
RStuio를 사용할 수 있다:

1. `File` | `New Project` 를 클릭한다.

2. "New Directory" 를 선택한다:

    ```{r, echo = FALSE}
    bookdown::embed_png("screenshots/create-1.png", dpi = 220)
    ```
   
2. 그리고 나서 "R Package" 를 선택한다.:

    ```{r, echo = FALSE}
    bookdown::embed_png("screenshots/create-2.png", dpi = 220)
    ```

2. 그리고 나서 팩키지 명칭을 부여하고, "Create Project" 를 클릭한다:

    ```{r, echo = FALSE}
    bookdown::embed_png("screenshots/create-3.png", dpi = 220)
    ```
    
대안으로, R 내부에서 다음 명령어를 실행해서 신규 팩키지를 생성한다.

```{r, eval = FALSE}
devtools::create("path/to/package/pkgname")
```

어느 경로를 택하든 동일한 장소에 도달한다: 세개 구성요소를 갖는 가장 작은 유용한 팩키지가 생성된다:


1. `R/` 디렉토리, [R code](#r) 에서 학습 예정.

1. 기본 `DESCRIPTION` 파일, [package metadata](#description) 에서 학습 예정.

1. 기본 `NAMESPACE` 파일, [the namespace](#namespace) 에서 학습 예정.

`pkgname.Rproj` RStudio 프로젝트 파일도 포함되어서 다음에 기술되듯이 RStudio로 팩키지 생성을 쉽게 한다.

팩키지 생성에 `package.skeleton()`을 사용하지 말라.
이유는 제안하는 작업흐름(workflow)를 따르게 되면 더 많은 작업이 생성되는데 실제 동작되는 팩키지를 갖기 전에 삭제하거나 변형해야 되는 잉여 파일이 생성되기 때문이다.


## RStudio 프로젝트 {#projects}

RStudio로 신규 팩키지 개발을 시작하기 위해서,
`create()`가 방금 전에 생성한 `pkgname.Rproj` 파일을 두번 클릭한다.
팩키지를 개발을 위한 신규 RStudio 프로젝트를 열 것이다.
프로젝트는 팩키지 개발을 위한 훌륭한 방법인데 이유는 :  

*   각 프로젝트가 격리된다; 한 프로젝트에서 실행된 코드는 다른 어떤 프로젝트도 영향을 미치지 않는다.

*   `F2` 같은 손쉬운 코드 이동 도구로 함수 정의로 바로 찾아 들어갈 수 있고, `Ctrl + .` 단축키를 사용해서 명칭으로 함수를 찾는다.

*   일반적인 팩키지 개발 작업을 위해서 유용한 키보드 단축키를 학습한다. 단축키에 대해서는 이책을 통해서 더 배울 것이다. 하지만, 전체 단축키를 보기 위해서 `Alt + Shift + K`를 누르거나 | 키보드 단축키 메뉴( Help | Keyboard shortcuts)를 사용한다.
    
    ```{r, echo = FALSE}
    bookdown::embed_png("screenshots/keyboard-shortcuts.png")
    ```

(만약 RStudio 비법과 요령에 대해 더 배우고자 한다면, 트위터 @[rstudiotips](https://twitter.com/rstudiotips) 계정을 팔로잉한다.)

RStudio와 `devtools::create()`이  `.Rproj` 파일을 자동 생성한다.
`.Rproj`를 갖지 않는 기존 팩키지가 있다면, `devtools::use_rstudio("path/to/package")` 명령어로 추가한다. 만약 RStudio를 사용하지 않는다면, 신규 R 세션을 생성하고 작업 디렉토리가 팩키지 디렉토리에 맞춰졌는지 확실히 하고 개발을 착수한다.


### RStudio 프로젝트 파일은 무엇인가?

`.Rproj` 파일은 다를 것 없는 텍스트 파일이다. `devtools`로 생성된 프로젝트 파일은 다음이 생겼다:


```
Version: 1.0

RestoreWorkspace: No
SaveWorkspace: No
AlwaysSaveHistory: Default

EnableCodeIndexing: Yes
Encoding: UTF-8

AutoAppendNewline: Yes
StripTrailingWhitespace: Yes

BuildType: Package
PackageUseDevtools: Yes
PackageInstallArgs: --no-multiarch --with-keep.source
PackageRoxygenize: rd,collate,namespace
```

수작업으로 해당 프로젝트 파일을 변경할 필요는 없다. 대신에, RStudio 오른쪽 하단에 프로젝트 메뉴에서 접급할 수 있는 `Project Options...`를 클릭하고 대화창으로 사용한다.


```{r, echo = FALSE}
bookdown::embed_png("screenshots/project-options-1.png", dpi = 220)
bookdown::embed_png("screenshots/project-options-2.png", dpi = 220)
```

## 팩키지는 무엇인가? {#package}

첫번째 팩키지를 만들기 위해서, 알아야 되는 모든 것이 위에서 학습한 것이다. 팩키지 개발에 통달하기 위해서, 특히, 외부에 배포할 팩키지를 개발할 때, __5단계 팩키지 생애주기(lifecycle)__를 이해하는 것이 정말 도움이 된다: 소스코드(source), 번들(bundled), 바이너리(binary), 설치(installed), 메모리(in-memory). 생애주기 단계 사이 차이를 이해하는 것이 `install.packages()` 와 `devtools::install_github()`이 무엇을 하는지에 대한 더 나은 정신세계를 갖추도록 도움을 줄 것이고 문제가 발생할 때 디버깅을 더 쉽게 도와준다.

### 소스코드(Source) 팩키지

지금까지, __소스코드(source)__ 팩키지로 작업했다: 로컬 개발자 컴퓨터에 작업하고 있는 개발 버젼 팩키지. 소스코드 팩키지는 다름 아닌  `R/`, `DESCRIPTION`, 등을 구성요소로 갖는 디렉토리다.

### 번들(Bundled) 팩키지

__번들(bundled)__

A  package is a package that's been compressed into a single file. By convention (from Linux), package bundles in R use the extension `.tar.gz`. This means that multiple files have been reduced to a single file (`.tar`) and then compressed using gzip (`.gz`). While a bundle is not that useful on its own, it's a useful intermediary between the other states. In the rare case that you do need a bundle, call `devtools::build()` to make it. 

If you decompress a bundle, you'll see it looks almost the same as your source package. The main differences between an uncompressed bundle and a source package are:

* Vignettes are built so that you get HTML and PDF output instead of 
  Markdown or LaTeX input.

* Your source package might contain temporary files used to save time during
  development, like compilation artefacts in `src/`. These are never found in 
  a bundle.
  
* Any files listed in `.Rbuildignore` are not included in the bundle.

`.Rbuildignore` prevents files in the source package from appearing in the bundled package. It allows you to have additional directories in your source package that will not be included in the package bundle. This is particularly useful when you generate package contents (e.g. data) from other files. Those files should be included in the source package, but only the results need to be distributed. This is particularly important for CRAN packages (where the set of allowed top-level directories is fixed). Each line gives a Perl-compatible regular expression that is matched, without regard to case, against the path to each file (i.e. `dir(full.names = TRUE)` run from the package root directory) - if the regular expression matches, the file is excluded. 

If you wish to exclude a specific file or directory (the most common use case), you __MUST__ anchor the regular expression. For example, to exclude a directory called notes, use `^notes$`. The regular expression `notes` will match any file name containing notes, e.g. `R/notes.R`, `man/important-notes.R`, `data/endnotes.Rdata`, etc. The safest way to exclude a specific file or directory is to use `devtools::use_build_ignore("notes")`, which does the escaping for you.

Here's a typical `.Rbuildignore` file from one of my packages:

```
^.*\.Rproj$         # Automatically added by RStudio,
^\.Rproj\.user$     # used for temporary files. 
^README\.Rmd$       # An Rmarkdown file used to generate README.md
^cran-comments\.md$ # Comments for CRAN submission
^NEWS\.md$          # A news file written in Markdown
^\.travis\.yml$     # Used for continuous integration testing with travis
```

I'll mention when you need to add files to `.Rbuildignore` whenever it's important.

### Binary packages

If you want to distribute your package to an R user who doesn't have package development tools, you'll need to make a __binary__ package. Like a package bundle, a binary package is a single file. But if you uncompress it, you'll see that the internal structure is rather different from a source package: 

* There are no `.R` files in the `R/` directory - instead there are three
  files that store the parsed functions in an efficient file format. This is
  basically the result of loading all the R code and then saving the
  functions with `save()`. (In the process, this adds a little extra metadata to 
  make things as fast as possible).

* A `Meta/` directory contains a number of `Rds` files. These files contain 
  cached metadata about the package, like what topics the help files cover and
  parsed versions of the `DESCRIPTION` files. (You can use `readRDS()` to see 
  exactly what's in those files). These files make package loading faster
  by caching costly computations.

* An `html/` directory contains files needed for HTML help.

* If you had any code in the `src/` directory there will now be a `libs/`
  directory that contains the results of compiling 32 bit (`i386/`) and 64 bit 
  (`x64/`) code.
  
* The contents of `inst/` are moved to the top-level directory.

Binary packages are platform specific: you can't install a Windows binary package on a Mac or vice versa. Also, while Mac binary packages end in `.tgz`, Windows binary packages end in `.zip`. You can use `devtools::build(binary = TRUE)` to make a binary package. 

The following diagram summarises the files present in the root directory for source, bundled and binary versions of devtools.

```{r, echo = FALSE}
bookdown::embed_png("diagrams/package-files.png")
```

### Installed packages {#install}

An __installed__ package is just a binary package that's been decompressed into a package library (described below). The following diagram illustrates the many ways a package can be installed. This diagram is complicated! In an ideal world, installing a package would involve stringing together a set of simple steps: source -> bundle, bundle -> binary, binary -> installed. In the real world, it's not this simple because there are often (faster) shortcuts available.

```{r, echo = FALSE}
bookdown::embed_png("diagrams/installation.png")
```

The tool that powers all package installation is the command line tool `R CMD INSTALL` - it can install a source, bundle or a binary package. Devtools functions provide wrappers that allow you to access this tool from R rather than from the command line. `devtools::install()` is effectively a wrapper for `R CMD INSTALL`. `devtools::build()` is a wrapper for `R CMD build` that turns source packages into bundles. `devtools::install_github()` downloads a source package from GitHub, runs `build()` to make vignettes, and then uses `R CMD INSTALL` to do the install. `devtools::install_url()`, `devtools::install_gitorious()`, `devtools::install_bitbucket()` work similarly for packages found elsewhere on the internet.

`install.packages()` and `devtools::install_github()` allow you to install a remote package. Both work by downloading and then installing the package. This makes installation very speedy. `install.packages()` is used to download and install binary packages built by CRAN. `install_github()` works a little differently - it downloads a source package, builds it and then installs it.

You can prevent files in the package bundle from being included in the installed package using `.Rinstignore`. This works the same way as `.Rbuildignore`, described above. It's rarely needed.

### In memory packages

To use a package, you must load it into memory. To use it without providing the package name (e.g. `install()` instead of `devtools::install()`), you need to attach it to the search path. R loads packages automatically when you use them. `library()` (and the later discussed `require()`) load, then attach an installed package.

```{r, eval = FALSE}
# Automatically loads devtools
devtools::install()
    
# Loads and _attaches_ devtools to the search path
library(devtools)
install()
```

The distinction between loading and attaching packages is not important when you're writing scripts, but it's very important when you're writing packages. You'll learn more about the difference and why it's important in [search path](#search-path).

`library()` is not useful when you're developing a package because you have to install the package first. In future chapters you'll learn about `devtools::load_all()` and RStudio's "Build and reload", which allows you to skip install and load a source package directly into memory:

```{r, echo = FALSE}
bookdown::embed_png("diagrams/loading.png")
```

## What is a library? {#library}

A library is simply a directory containing installed packages. You can have multiple libraries on your computer. In fact, almost every one has at least two: one for packages you’ve installed, and one for the packages that come with every R installation (like base, stats, etc). Normally, the directories with user-installed packages vary based on the version of R that you’re using. That's why it seems like you lose all of your packages when you reinstall R --- they're still on your hard drive, but R can't find them. 

You can use `.libPaths()` to see which libraries are currently active. Here are mine:

```{r, eval = FALSE}
.libPaths()
#> [1] "/Users/hadley/R"                                               
#> [2] "/Library/Frameworks/R.framework/Versions/3.1/Resources/library"
lapply(.libPaths(), dir)
#> [[1]]
#>   [1] "AnnotationDbi"   "ash"             "assertthat"     
#>   ...      
#> [163] "xtable"          "yaml"            "zoo"            
#> 
#> [[2]]
#>  [1] "base"         "boot"         "class"        "cluster"     
#>  [5] "codetools"    "compiler"     "datasets"     "foreign"     
#>  [9] "graphics"     "grDevices"    "grid"         "KernSmooth"  
#> [13] "lattice"      "MASS"         "Matrix"       "methods"     
#> [17] "mgcv"         "nlme"         "nnet"         "parallel"    
#> [21] "rpart"        "spatial"      "splines"      "stats"       
#> [25] "stats4"       "survival"     "tcltk"        "tools"       
#> [29] "translations" "utils"
```

The first lib path is for the packages I've installed (I've installed at lot!). The second is for so-called "recommended" packages that come with every installation of R.

When you use `library(pkg)` or `require(pkg)` to load a package, R looks through each path in `.libPaths()` to see if a directory called `pkg` exists. If it doesn't exist, you'll get an error message:

```{r, error = TRUE}
library(blah)
# or:
require(blah)
```

The main difference between `library()` and `require()` is what happens if a package isn't found. While `library()` throws an error, `require()` prints a warning message and returns FALSE. In practice, this distinction isn't important because when building a package you should __NEVER__ use either inside a package. See [package dependencies](#dependencies) for what you should do instead.

When you start learning R, it's easy to get confused between libraries and packages because you use `library()` function to load a _package_. However, the distinction between the two is important and useful. For example, one important application is packrat, which automates the process of managing project specific libraries. With packrat, when you upgrade a package in one project, it only affects that project, not every project on your computer. This is useful because it allows you to play around with cutting-edge packages without affecting other projects' use of older, more reliable packages. This is also useful when you're both developing and using a package.
