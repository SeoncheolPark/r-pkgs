---
title: Package basics
layout: default
output: bookdown::html_chapter
---

# 팩키지 메타데이터 {#description}

`DESCRIPTION` 파일 임무는 팩키지에 관한 중요한 메타데이터를 저장하는 것이다.
처음 팩키지를 작성하기 시작할 때, 팩키지 메타데이터 파일을 사용해서 작성한 팩키지를 실행하는데
필요한 팩키지 목록을 기록한다. 하지만, 시간이 흐르고 다른 분들과 팩키지를 공유하기 시작하면 메타데이터 파일이 점점 중요해지는데 이유는 누가 팩키지를 사용할 수 있는지(라이선스), 팩키지 관련해서 문제가 생기거나, 문의사항이 생기면 누구(개발자 본인!)에게 연락해야 하는지 지정하기 때문이다.

모든 팩키지는 `DESCRIPTION`을 갖추고 있어야 한다. 사실, 팩키지를 정의하는 기능을 한다. (RStudio와 `devtools`는 `DESCRIPTION`을 담고 있는 임의 디렉토리가 팩키지라고 생각한다.)
시작하면, 자동으로 `devtools::create("mypackage")`가 뼈대만 갖는 기술(description) 파일을 추가한다.
이렇게 함으로써 필요해질 때까지 아무 걱정없이 팩키지 개발을 시작할 수 있게 한다.
최소 기술(description) 파일은 개인 설정정보에 따라 다소 차이가 있지만, 다음과 같을 것이다:

```yaml
Package: mypackage
Title: What The Package Does (one line, title case required)
Version: 0.1
Authors@R: person("First", "Last", email = "first.last@example.com",
                  role = c("aut", "cre"))
Description: What the package does (one paragraph)
Depends: R (>= 3.1.0)
License: What license is it under?
LazyData: true
```

(만약 정말 많은 팩키지를 개발한다고 하면, `devtools.desc.author`, `devtools.desc.license`, `devtools.desc.suggests`, `devtools.desc`을 전역 옵션으로 설정한다. 
자세한 사항은 `package?devtools`를 참조한다.)

`DESCRIPTION`은 데비안 제어형식(DCF, Debian Control Format)을 사용한다.
다음에 나오는 간단한 예제를 통해서 구조 대부분을 볼 수 있다.
각 행은 콜론으로 구분되는 __필드(field)__ 명칭과 값(value)으로 구분된다.
값이 여러 행에 걸쳐질 때는 들여쓰기 한다:

```yaml
Description: The description of a package is usually long,
    spanning multiple lines. The second and subsequent lines
    should be indented, usually with four spaces.
```

이번 장에서 가장 중요한 `DESCRIPTION` 필드를 사용하는 방법을 제시한다.

## 의존성 : 팩키지가 무엇을 필요로 하는가? {#dependencies}

팩키지가 동작하는데 필요한 팩키지 목록 정보를 담는 것이 `DESCRIPTION` 파일 책무다.
R은 잠재적 의존성(dependencies)을 기술하는 풍부한 방법을 제공한다.
예를 들어, 다음에 팩키지가 동작하는데 `ggvis`와 `dplyr` 필요하다는 것을 나타낸다:

```yaml
Imports:
    dplyr,
    ggvis
```

반면에, 다음에 팩키지가 `ggvis`와 `dplyr`를 활용할 수는 있지만, 팩키지가 동작하는데 꼭 요구되지는 않는다는 것을 나타낸다:

```yaml
Suggests:
    dplyr,
    ggvis,
```

`Imports`와 `Suggests` 팩키지 모두 명칭을 모두 콤마 구분자로 사용한다.
저자가 추천하는 방식은 각 행마다 팩키지 하나를 두고, 알파벳 숫으로 정렬한다. 그러면 눈으로 한번 일별하기가 좋다.

`Imports`와 `Suggests`는 의존성 강도에서 차이가 난다:



*   `Imports`: 목록에 나온 팩키지는 작성한 팩키지가 제대로 동작하는데 __있어야만 한다.__
    사실, 팩키지가 설치되는 시점에, 아직 설치가 되지 않았다면, 사용자 로컬 컴퓨터에 설치될 것이다.
    (`devtools::load_all()`도 팩키지가 설치되었는지 점검한다).
    
    팩키지 의존성을 `Imports`에 추가하면 팩키지 설치를 확실히 할 수 있다.
    하지만, (예를 들어, `library(x)`) 팩키지를 따라 붙착(attach)된다는 것을 의미하는 것은 _아니다._
    모범 사례로 `package::function()` 구문을 사용해서 명시적으로 외부 함수를 참조하게 한다.
    이렇게 하면 어떤 함수가 외부 팩키지에서 제공되는지 식별하기 쉽게 한다.
    미래에 코드를 읽을 때도 특히 유용하다.
    
    만약 다른 팩키지에서 함수를 아주 많이 사용한다면, 다소 코드가 장황하다.
    또한 `::`와 연관된 일부 성능이 저하되는 벌칙도 있다 
    (5µ 초 정도로, 함수를 수백만번 호출하면 문제가 될 수 있다).
    [namespace imports](#imports)에서 다른 팩키지에 담긴 함수를 호출하는 
    대안을 학습할 것이다.

*   `Suggests`: 작성한 패키지에서 `Suggests` 목록에 올린 팩키지를 사용할 수도 있으나,
    반듯이 필요로 하는 것은 아니다. 예제 데이터셋으로, 테스트를 실행하려고, 소품문(Vignettes)을 빌드하는데
    추천(suggested) 팩키지를 사용할 수도 있다. 혹은 아마도 해당 팩키지를 필요로 하는 함수가 단 하나 존재할지도 모른다.
    
    `Suggests` 목록에 오른 팩키지는 작성한 팩키지를 따라 함께 자동으로 설치가 되지 않는다.
    이것이 함의하는 바는 팩키지를 사용하기 전에 팩키지가 이용가능한지 점검하는 것이 필요하다는 것이다. 
    (`requireNamespace(x, quietly = TRUE)` 명령어를 사용). 다음에 두가지 기본 시나리오가 있다. 
  
    ```{r}
    # 다음 함수에는 추천(suggested) 팩키지가 필요하다.
    my_fun <- function(a, b) {
      if (!requireNamespace("pkg", quietly = TRUE)) {
        stop("Pkg needed for this function to work. Please install it.",
          call. = FALSE)
      }
    }
    
    # 팩키지를 이용할 수 없다면, 방비책이 되는 메쏘드가 있다. 
    my_fun <- function(a, b) {
      if (requireNamespace("pkg", quietly = TRUE)) {
        pkg::f()
      } else {
        g()
      }
    }
    ```

로컬에서 팩키지를 개발할 때, `Suggests`를 사용할 필요는 결코 없다.
팩키지를 출시할 때, `Suggests`를 사용하는 것이 응당 사용자에 대한 예의다.
거의 필요하지 않는 팩키지를 사용자가 다운로드하지 않아도 되고, 가능한 빨리 개발된 팩키지를 사용할 수 있도록 한다.

`Imports`와 `Suggests`를 팩키지에 추가하는 가장 쉬운 방법은 `devtools::use_package()`을 사용하는 것이다. 이렇게 되면 자동적으로 `DESCRIPTION` 파일에 올바른 장소에 위치하게 된다.
그리고 어떻게 팩키지를 사용하는지 상기시키는 역할을 한다.

```{r, eval = FALSE}
devtools::use_package("dplyr") # 디폴트 초기설정은 imports로 되어있다.
#> dplyr을 Imports에 추가한다.
#> dplyr::fun()을 통해 함수를 참조한다.
devtools::use_package("dplyr", "Suggests")
#> dplyr을 Suggests에 추가한다.
#> requireNamespace("dplyr", quietly = TRUE)을 사용해서 팩키지가 설치되었는지 
#> 테스트한다. 그리고 나서 dplyr::fun()을 사용해서 함수를 참조한다.
```

### 버져닝(Versioning)

만약 특정 팩키지 버젼이 필요하면, 팩키지 명칭 뒤에 괄호에 명시한다:

```yaml
Imports:
    ggvis (>= 0.2),
    dplyr (>= 0.3.0.1)
Suggests:
    MASS (>= 7.3.0)
```

거의 항상 정확한 버젼 (예를 들어, `MASS (== 7.3.0)`) 보다는 최소 버젼을 지정한다.
R로 동일 팩키지 다수 버젼을 동시에 적재할 수 없기 때문에, 정확한 의존성을 명시하면 버젼 충돌 가능성을 급격히 높인다.

팩키지를 출시할 때 버져닝이 매우 중요해진다.
대체로 개발자가 설치한 것과 동일한 패키지 버젼을 일반 사용자가 정확히 갖지는 않을 것이다.
만약 개발한 팩키지가 필요한 함수를 이전 버젼을 일반 사용자가 갖고 있다면,
도움되지 않는 오류 메시지만 발생할 것이다.
하지만, 팩키지 개발자가 버젼 번호를 제공한다면, 오류 메시지를 보게 되는 것은 동일하지만,
정확히 문제가 무엇인지를 알려준다: 이전 구식 팩키지입니다.

일반적으로, 항상 버젼을 명시하고 어떤 버젼이 필요한지에 대해서는 보수적인 것이 항상 낫다.
달리 알고 있지 않는다면, 개발자가 현재 사용하고 있는 버젼 번호가 동일하거나 더 큰 버젼을 항상 사용한다.


### 기타 의존성

좀더 전문적으로 의존성을 표현할 수 있는 기타 필드가 세개 있다:


  * `Depends`: R 2.14.0 네임스페이스(namespace)를 출시하기 전에, `Depends`가
    또다른 팩키지에 "의존성(dependancy)"을 갖는 유일한 방법이었다.
    이제는 명칭에도 불구하고, `Depends`가 아닌, `Imports`를 거의 항상 사용해야 한다.
    [namespaces](#namespace)에서 이유와 여전히 `Depends`를 사용할 때는 언제인지 배울 것이다.
    
    또한, `Depends`를 사용해서 예를 들어, `Depends: R (>= 3.0.1)`처럼 특정 R 버젼을 쓸 수도 있다.
    팩키지와 마찬가지로, 개발자가 현재 사용하고 있는 버젼 번호와 동일하거나 
    더 큰 버젼 번호를 사용하고 안전 대비책을 준비하는 것이 좋다.

    R 3.1.1과 이전 버젼에서 S4를 사용하려면, `Depends: methods`을 사용할 필요가 있다.
    이런 버그는 R 3.2.0 버젼에서 고쳐져서 메쏘드가 속해있는 `Imports`로 되돌아 갈 수 있다.

  * `LinkingTo`: 여기 목록에 올라온 팩키지는 또 다른 팩키지에 C 혹은 C++ 코드에 의존성이 있다.
    [compiled code](#src)에서 `LinkingTo`에 대해 더 많이 배울 것이다.
    
  * `Enhances`: 여기 목록에 올라온 팩키지는 작성한 팩키지로 "개선(enhanced)"된다.
    전형적으로, 이것이 의미하는 바는 또다른 팩키지에 정의된 클래스에 메쏘드를 제공한다는 것이다
    (일종의 역 `Suggests`). 하지만, 이것이 무엇을 의미하는 것인지 정의하기 어려워서,
    저자는 `Enhances` 사용을 추천하지는 않는다.

`SystemRequirements` 필드에 R 밖에서 작성한 팩키지가 필요한 목록을 작성할 수 있다.
하지만, 텍스트 필드로만 작성되어 자동적으로 점검되지 못한다.
이를 조견표(quick reference)로 생각할 수 있다: README에 (팩키지를 설치하는 방법과) 구체적 시스템 요구사항을 포함할 필요도 있다.
    

## 제목과 기술: 작성한 팩키지가 어떤 작업을 수행하는가? {#pkg-description}

제목(title)과 기술(description) 필드로 팩키지가 어떤 작업을 수행하는지 기술한다.
제목과 기술 두 필드 차이는 단지 길이에서 있다:



* `제목(Title)`은 팩키지를 한 줄로 기술하고 팩키지 목록에 나타난다.
  (마크업이 아닌) 일반 텍스트여야 되며, 제목처럼 대문자로 시작되어야 되고, 마침표로 끝나면 __안__ 된다.
  짧게 한다: 제목을 65 글자로 한정하고 나머지는 잘라낸다.

* `기술(Description)`은 제목보다 좀더 자세하다. 여러 문장을 사용할 수 있지만, 한 문단 제약사항이 있다.
  만약 기술이 여러 행에 걸쳐 기술된다면 (그리고 기술되어야만 한다!), 각 행은 문자 80자를 넘지 말아야 된다.
  다음 행은 공백 4개로 들여 쓴다.

`ggplot2` 팩키지 `제목(title)`과 `기술(Description)`은 다음과 같다:

```yaml
Title: An implementation of the Grammar of Graphics
Description: An implementation of the grammar of graphics in R. It combines 
    the advantages of both base and lattice graphics: conditioning and shared 
    axes are handled automatically, and you can still build up a plot step 
    by step from multiple data sources. It also implements a sophisticated 
    multidimensional conditioning system and a consistent interface to map
    data to aesthetic attributes. See the ggplot2 website for more information, 
    documentation and examples.
```

좋은 제목과 기술이 중요하다. 특히 만약 팩키지를 CRAN에 배포할 계획이라면, CRAN 다운로드 페이지에 다음과 같이 나타나기 때문에 더욱 그렇다:

```{r, echo = FALSE}
bookdown::embed_png("diagrams/cran-package.png")
```

`기술(Description)`에는 작성한 팩키지가 무엇을 수행하는지 기술하는데 적은 공간만 배정하기 때문에,
좀더 심층적인 내용과 예제 몇가지를 `README.md` 파일을 추가하는 것을 추천한다.
[README.md](#readme)에서 더 많은 내용을 학습할 것이다.

## 저자 : 작성자는 누구인가? {#author}



To identify the package's author, and whom to contact if something goes wrong, use the `Authors@R` field. This field is unusual because it contains executable R code rather than plain text. Here's an example:

```yaml
Authors@R: person("Hadley", "Wickham", email = "hadley@rstudio.com",
  role = c("aut", "cre"))
```

```{r}
person("Hadley", "Wickham", email = "hadley@rstudio.com", 
  role = c("aut", "cre"))
```

This command says that both the author (aut) and the maintainer (cre) is Hadley Wickham, and that his email address is `hadley@rstudio.com`. The `person()` function has four main arguments:

* The name, specified by the first two arguments, `given` and `family` (these
  are normally supplied by position, not name). In English cultures, `given` 
  (first name) comes before `family` (last name). In many cultures, this 
  convention does not hold.
  
* The `email` address.

* A three letter code specifying the `role`. There are four important roles:

    * `cre`: the creator or maintainer, the person you should bother 
      if you have problems.
      
    * `aut`: authors, those who have made significant contributions to the 
      package.
    
    * `ctb`: contributors, those who have made smaller contributions, like 
      patches.
    
    * `cph`: copyright holder. This is used if the copyright is held by someone 
      other than the author, typically a company (i.e. the author's employer).
    
    (The [full list of roles](http://www.loc.gov/marc/relators/relaterm.html) is
    extremely comprehensive. Should your package have a woodcutter ("wdc"), 
    lyricist ("lyr") or costume designer ("cst"), rest comfortably that you can 
    correctly describe their role in creating your package.)

If you need to add further clarification, you can also use the `comment` argument and supply the desired information in plain text.

You can list multiple authors with `c()`:

```yaml
Authors@R: c(
    person("Hadley", "Wickham", email = "hadley@rstudio.com", role = "cre"),
    person("Winston", "Chang", email = "winston@rstudio.com", role = "aut"))
```

Alternatively, you can do this concisely by using `as.person()`:

```yaml
Authors@R: as.person(c(
    "Hadley Wickham <hadley@rstudio.com> [aut, cre]", 
    "Winston Chang <winston@rstudio.com> [aut]"
  ))
```

(This only works well for names with only one first and last name.)

Every package must have at least one author (aut) and one maintainer (cre) (they might be the same person). The creator must have an email address. These fields are used to generate the basic citation for the package (e.g. `citation("pkgname")`). Only people listed as authors will be included in the auto-generated citation. There are a few extra details if you're including code that other people have written. Since this typically occurs when you're wrapping a C library, it's discussed in [compiled code](#src).

As well as your email address, it's also a good idea to list other resources availble for help. You can list URLs in `URL`. Multiple URLs are separated with a comma. `BugReports` is the URL where bug reports should be submitted. For example, knitr has:

```yaml
URL: http://yihui.name/knitr/
BugReports: https://github.com/yihui/knitr/issues
```

You can also use separate `Maintainer` and `Author` fields. I prefer not to use these fields because `Authors@R` offers richer metadata. 

### On CRAN

The most important thing to note is that your email address (i.e., the address of `cre`) is the address that CRAN will use to contact you about your package. So make sure you use an email address that's likely to be around for a while. Also, because this address will be used for automated mailings, CRAN policies require that this be for a single person (not a mailing list) and that it does not require any confirmation or use any filtering.

## License: Who can use your package? {#license}

The `License` field can be either a standard abbreviation for an open source license, like `GPL-2` or `BSD`, or a pointer to a file containing more information, `file LICENSE`. The license is really only important if you're planning on releasing your package. If you don't, you can ignore this section. If you want to make it clear that your package is not open source, use `License: file LICENSE` and then create a file called `LICENSE`, containing for example:

    Proprietary 

    Do not distribute outside of Widgets Incorporated.

Open source software licensing is a rich and complex field. Fortunately, in my opinion, there are only three licenses that you should consider for your R package:

  * [MIT](https://tldrlegal.com/license/mit-license) 
    (v. similar: to BSD 2 and 3 clause licenses). This is a simple and
    permissive license. It lets people use  and freely distribute your code
    subject to only one restriction: the license must always be distributed
    with the code.
  
    The MIT license is a "template", so if you use it, you need 
    `License: MIT + file LICENSE`, and a `LICENSE` file that looks like this:
    
    ```yaml
    YEAR: <Year or years when changes have been made>
    COPYRIGHT HOLDER: <Name of the copyright holder>
    ```

  * [GPL-2](https://tldrlegal.com/license/gnu-general-public-license-v2) or 
    [GPL-3](https://tldrlegal.com/license/gnu-general-public-license-v3-(gpl-3)). 
    These are "copy-left" licenses. This means that anyone who distributes your
    code in a bundle must license the whole bundle in a GPL-compatible way. 
    Additionally, anyone who distributes modified versions of your code 
    (derivative works) must also make the source code available. GPL-3 is a 
    little stricter than GPL-2, closing some older loopholes.

  * [CC0](https://tldrlegal.com/license/creative-commons-cc0-1.0-universal). 
    It relinquishes all your rights on the code and data so that it can be 
    freely used by anyone for any purpose. This is sometimes called putting it 
    in the public domain, a term which is neither well-defined nor meaningful in 
    all countries.
  
    This license is most appropriate for data packages. Data, at least in the US, 
    is not copyrightable, so you're not really giving up much. This 
    license just makes this point clear.
  
If you'd like to learn more about other common licenses, Github's [choosealicense.com](http://choosealicense.com/licenses/) is a good place to start. Another good resource is <https://tldrlegal.com/>, which explains the most important parts of each license. If you use a license other than the three I suggest, make sure you consult the "Writing R Extensions" section on [licensing][R-exts].

If your package includes code that you didn't write, you need to make sure you're in compliance with its license. Since this occurs most commonly when you're including C source code, it's discussed in more detail in [compiled code](#src).

### On CRAN

If you want to release your package to CRAN, you must pick a standard license. Otherwise it's difficult for CRAN to determine whether or not it's legal to distribute your package! You can find a complete list of licenses that CRAN considers valid at <https://svn.r-project.org/R/trunk/share/licenses/license.db>.

```{r, results='asis', echo = FALSE, eval = FALSE}
licenses <- read.dcf(file.path(R.home("share"), "licenses", "license.db"))
licenses <- as.data.frame(licenses, stringsAsFactors = FALSE)
licenses <- licenses[order(licenses$Name, licenses$Version), ]
licenses[is.na(licenses)] <- ""
has_abbrev <- subset(licenses, Abbrev != "")
knitr::kable(has_abbrev[c("Name", "Version", "Abbrev")], row.names = FALSE)
```

## Version {#version}

Formally, an R package version is a sequence of at least two integers separated by either `.` or `-`. For example, `1.0` and `0.9.1-10` are valid versions, but `1` or `1.0-devel` are not. You can parse a version number with `numeric_version`.

```{r}
numeric_version("1.9") == numeric_version("1.9.0")
numeric_version("1.9.0") < numeric_version("1.10.0")
```

For example, a package might have a version 1.9. This version number is considered by R to be the same as 1.9.0, less than version 1.9.2, and all of these are less than version 1.10 (which is version "one point ten", not "one point one zero). R uses version numbers to determine whether package dependencies are satisfied. A package might, for example, import package `devtools (>= 1.9.2)`, in which case version 1.9 or 1.9.0 wouldn't work.

The version number of your package increases with subsequent releases of a package, but it's more than just an incrementing counter -- the way the number changes with each release can convey information about what kind of changes are in the package.

I don't recommend taking full advantage of R's flexiblity. Instead always use `.` to separate version numbers. 

* A released version number consists of three numbers, `<major>.<minor>.<patch>`. 
  For version number 1.9.2, 1 is the major number, 9 is the minor number, and 
  2 is the patch number. Never use versions like `1.0`, instead always spell
  out the three components, `1.0.0.`

* An in-development package has a fourth component: the development version.
  This should start at 9000. For example, the first version of the package
  should be `0.0.0.9000`. There are two reasons for this recommendation:
  first, it makes it easy to see if a package is released or in-development,
  and the use of the fourth place means that you're not limited to what the
  next version will be. `0.0.1`, `0.1.0` and `1.0.0` are all greater than 
  `0.0.0.9000`.
  
    Increment the development version, e.g. from `9000` to `9001` if you've
    added an important feature that another development package needs to depend 
    on.
    
    If you're using svn, instead of using the arbitrary `9000`, you can
    embed the sequential revision identifier.

This advice here is inspired in part by [Semantic Versioning](http://semver.org) and by the [X.Org](http://www.x.org/releases/X11R7.7/doc/xorg-docs/Versions.html) versioning schemes. Read them if you'd like to understand more about the standards of versioning used by many open source projects.

We'll come back to version numbers in the context of releasing your package, [picking a version number](#release-version). For now, just remember that the first version of your package should be `0.0.0.9000`.

## Other components {#description-misc}

A number of other fields are described elsewhere in the book:

* `Collate` controls the order in which R files are sourced. This only
  matters if your code has side-effects; most commonly because you're
  using S4. This is described in more depth in [documenting S4](#man-s4).

* `LazyData` makes it easier to access data in your package. Because it's so 
  important, it's included in the minimal description created by devtools. It's
  described in more detail in [external data](#data).

There are actually many other rarely, if ever, used fields. A complete list can be found in the "The DESCRIPTION file" section of the [R extensions manual][R-exts]. You can also create your own fields to add additional metadata. The only restrictions are that you shouldn't use existing names and that, if you plan to submit to CRAN, the names you use should be valid English words (so a spell-checking NOTE won't be generated).

[R-exts]: http://cran.r-project.org/doc/manuals/R-exts.html#Licensing
