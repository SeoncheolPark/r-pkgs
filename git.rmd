---
title: Git and GitHub
layout: default
output: bookdown::html_chapter
---

# Git 와 GitHub {#git}

만약 소프트웨어 개발에 진지하게 임하려면, Git을 배울 필요가 있다.
Git은 _버젼제어시스템(version control system)_으로, 코드 변경사항을 추적하고 다른 개발자와 변경사항을 공유한다. Git이 [GitHub](http://github.com)와 조합되어 사용될 때 그 유용성은 배가된다. [GitHub](http://github.com)을 통해서 코드를 전세계 개발자와 공유하고 풀요청(pull request)와 이슈 추적을 통해 개선을 이어나간다. Git + GitHub 조합이 R 팩키지 개발자를 위한 가장 인기있는 버젼제어시스템이다. (GitHub에 올려진 수천개 R 패키지를 목도하라).


Git 과 GitHub 조합이 단지 R 팩키지에만 유용한 것이 아니라, 모든 소프트웨어 개발과 자료분석에도 일반적으로 유용하다. 이 책에서 Git 과 GitHub 포함했는데 이유는 팩키지 개발에 매우 유용하기 때문이다. 저자 등 뒤에서 신속하게 잘못된 것을 찾아내고 다른 개발자와 쉽게 협업이 가능하게 한다. Git 과 GitHub을 통하지 않고 더 생산성을 높이는 다른 방법은 없다. 

왜 Git + GitHub를 사용할까?


  * 팩키지 공유를 쉽게 만든다. 그리고, R 사용자는 다음 코드 두줄로 팩키지를 설치할 수 있다:
  

    ```{r, eval = FALSE}
    install.packages("devtools")
    devtools::install_github("username/packagename")
    ```
    
  * GitHub을 통해 작성한 팩키지에 대한 핵심사항만 담긴 웹사이트를 쉽게 생성할 수 있다.
    독자가 쉽게 코드를 탐색하고 (마크다운으로) 문서를 읽을 수도 있다.
    독자가 코드를 읽고 버그를 보고하고, GitHub 이슈를 통해 신규 기능을 제안할 수 있다.
    [GitHub issues][gh-issues]. 그리고 풀요청으로 작성한 코드에 기능향상을 제안할 수 있다.
  

  * 전자우편 혹은 드롭박스 폴더로 파일을 주고받으면서 누군가 코드를 협업해서 개발한 적이 있는가?
    두 개발자가 동일한 파일에 동시 작업하지 않고, 
    다른 개발자 변경사항을 덮어쓰기 해서 문제없이 하는데도 상당한 노력이 소요된다.
    Git가 있으면, 두 개발자 모두 편안하게 동시에 동일한 파일에 작업할 수 있다.
    Git가 변경사항을 자동으로 결합하거나, 모호한 부분과 충돌나는 것을 모두 보여준다.
  

  * 파일을 저장할 때 Cmd + S 대신에 `s`만 우연히 누른적이 있는가?
    추적하는데 몇분 걸리는 실수 혹은 버그를 우연히 만들어내는 것은 무척이나 쉽다.
    Git는 이러한 문제를 쉽게 탐지하기 한다. 왜냐하면 정확하게 변경된 것을 알아내서 
    어떤 변경사항도 실행취소(undo)할 수 있게 하기 때문이다.
  
동일한 작업을 많은 다른 제품([subversion](https://subversion.apache.org) 혹은 [mercurial](http://mercurial.selenic.com))과 웹사이트 서비스(like [gitlab](https://about.gitlab.com) and [bitbucket](https://bitbucket.org))로 수행할 수 있다.
Git이 GitHub와 함께 혹은 GitHub가 Git과 연결되어 함께 사용될 때 가장 유용해서 Git에 속한 기능과 GitHub에 속한 기능을 정확히 구별하는 것은 무의미하다.
하지만, 저자는 생각에는 Git + GitHub 조합이 가장 사용자 친화적 시스템이라고 본다 (특히 신규 개발자에게 그렇다). 대중성으로 인해 가능한 모든 질문 혹은 문제가 StackOverflow에 올려졌다는 것 때문만은 아니다.

그렇다고 Git이 배우기 쉽다는 것을 의미하지는 않는다.
Git과 첫 조우는 좌절을 줄 수도 있고, 이상한 용어와 그다지 도움이 되지 않는 오류 메시지에 저주를 퍼붓는다. 다행스럽게도 인터넷에 많은 사용지침서가 나와 있다.
(상당한 정보를 제공하지만 무엇을 수행할 수 있고 왜 관심을 가져야 하는 이유에 대해서는 거의 안내정보가 나와 있지 않아서) 그다지 잘 작성되어 있지는 않지만, 조금 실습하면 Git을 확실히 통달할 수 있다. 포기하지 마라! 인내를 갖고 전진하면, 코드 협업의 초강력 힘의 비밀을 해제할 것이다.

## RStudio, Git, GitHub {#git-rstudio}

RStudio는 일상적인 Git 사용을 더 쉽게 했다.
Git 기능을 활용하는 하도록 프로젝트를 설정하면, 새로운 창(pane)과 툴바 아이콘이 생긴다.
가장 자주 사용되는 Git 명령어로 바로가는 단축키 기능을 제공한다.
하지만, 150+ Git 명령어 일부만 RStudio에서 사용할 수 있기 때문에, __쉘(shell)__(명령라인 인터페이스 혹은 콘솔로도 알려짐)로
Git을 사용하는 방법에 친숙해질 필요가 있다. 쉘에서 Git 사용에 친숙해질 필요가 있는데 이유는 막히게 되면 Git 명령어를 통해서 해결책을 강구해야될 때가 많기 때문이다.

RStudio로부터 쉘에 접속하는 가장 쉬운 방법은 `Tools > Shell` 메뉴를 클릭한다.
이 방법으로 프로젝트 루트 디렉토리에 신규 쉘을 열게 된다.
(주의: 윈도우에서는 상기 방법을 통해 리눅스 표준쉘, _배쉬(bash)_ 쉘을 열게 되는데, 보통 `cmd.exe` 쉘과는 약간 다르게 행동하니 주의한다.)

이전에 쉘을 전혀 사용하지 않았다면 걱정할 필요는 없다. 왜냐하면 R 을 사용하는 것과 매우 유사하다.
주된 차이점은 함수를 사용하는 대신에 명령어(command)를 호출하는데, 약간 다른 구문을 갖는다.
예를 들어, R에서 `f(x, y = 1)`처럼 함수를 작성하는 반면에, 쉘에서 `f x --y=1` 혹은 `f x -y1` 방식으로 작성한다. 또한 쉘 명령어는 R 함수보다 심지어 덜 정규성을 갖지만, 다행스럽게도 일부와 친숙해지면 된다. 이번장에서 Git 명령어 실행을 제외하고 쉘로 그다지 많은 것을 수행하지 않을 것이다. 하지만, 가장 중요한 쉘 명령어 3개를 배워두는 것이 좋다:


* `pwd`: 작업 디렉토리를 출력한다. 현재 위치한 디렉토리를 알려준다.
* `cd <name>`: 디렉토리를 변경한다. `cd ..` 명령어를 사용해서 상위 디렉토리로 이동한다.
* `ls`: 파일 목록을 출력한다. 현재 디렉토리에 있는 모든 파일을 보여준다.

쉘을 이전에 결코 사용하지 않았다면, [Terminus](http://web.mit.edu/mprat/Public/web/Terminus/Web/main.html)를 실행해 보는 것을 추천한다. 쉘 기초사항을 즐겁게 배울 수 있다. 
필립 궈(Philip Guo) [기초 유닉스 명령어 사용지침](http://pgbovine.net/command-line-tutorial.htm) 동영상 감상과, <http://www.ee.surrey.ac.uk/Teaching/Unix/unix1.html>,  <https://p1k3.com/userland-book/> 웹사이트 방문도 저자는 추천한다. 


## 초기 환경설정 {#git-init}

Git 혹은 GitHub을 전에 결코 사용한 적이 없다면, Git을 설치하고 GitHub 계정을 생성해서 시작해보라.
그리고 나서 Git과 GitHub을 연결시킨다:


1.  Git 설치:

    * 윈도우즈: <http://git-scm.com/download/win>.
    * 맥 OS X: <http://git-scm.com/download/mac>.
    * 데비안/우분투: `sudo apt-get install git-core`.
    * 다른 리눅스 배포판: <http://git-scm.com/download/linux>.

1.  Git에 성함과 전자우편주소를 알려준다. 매번 커밋(commit)할때마다 라벨 역할을 한다.
    그래서 다른 개발자와 협업할 때, 누가 어떤 변경을 했는지 명확히 할 수 있다.
    쉘에서 다음 명령어를 실행한다:

    ```bash
    git config --global user.name "YOUR FULL NAME"
    git config --global user.email "YOUR EMAIL ADDRESS"
    ```

    (`git config --global --list` 명령어를 입력해서 올바르게 설정했는지 점검할 수 있다.)

1.  GitHub, <https://github.com> 에 계정을 생성한다 (무료사용도 좋다).
    상기 적용한 동일한 전자우편을 사용한다.
    
1.  필요하다면, SSH 키를 생성한다. SSH키를 사용해서 비밀번호 없이도 안전하게 웹사이트와 
    의사소통을 가능케 한다. SSH 키는 두 부분으로 구성된다: 개인키, 공개키.
    공개키를 갖는 사람이 안전하게 데이터를 암호화할 수 있는데,
    상응하는 비밀키를 갖고 있는 사람만 암호화된 데이터를 해독할 수 있다.
    
    다음 명령어를 실행해서 SSH 키 짝을 이미 갖고 있는지 점검할 수 있다:


    ```{r, eval = FALSE}
    file.exists("~/.ssh/id_rsa.pub")
    ```

    만약 상기 실행결과 `FALSE`가 반환되면, 신규 키를 생성할 필요가 있다.
    [GitHub 안내지침](https://help.github.com/articles/generating-ssh-keys)을 따르거나,
    RStudio를 사용할 수도 있다. RStudio 개인설정(Preference)으로 들어가서,
    Git/SVN 창을 선택하고, "Create RSA key..."을 클릭한다:
    

    ```{r, echo = FALSE}
    bookdown::embed_png("screenshots/git-config-2.png", dpi = 220)
    ```
    
1.  GitHub에 SSH 공캐키를 전달한다: <https://github.com/settings/ssh>.
    키를 찾는 가장 쉬운 방법은 RStudio Git/SVN 개인설정창에서 "View public key"를 클릭하는 것이다.

## 로컬 Git 저장소 생성하기 {#git-init}

Git을 설치하고 환경설정을 했기 때문에, 이제부터 사용할 수 있다!
팩키지 작성에 GitHub을 사용하려면, 먼저 줄여서 __repo__라고 부르는 로컬 저장소(repository)를 초기화한다. 초기화되면, `.git` 디렉토리가 생성되는데 환경설정 파일과 코드 변경내역을 기록하는 데이터베이스가 그곳에 저장된다. 신규 저장소는 개발자 본인 컴퓨터에만 존재하게 된다; 곧 다른 개발자와 저장소를 공유하는 방법을 학습할 것이다.

신규 저장소를 생성하기 위해서:


  * RStudio에서 `project options`로 들어가서, Git/SVN 창을 클릭한다.
    "버젼제어시스템(Version control system)"을 "None"에서 "Git"로 변경한다:
    
    ```{r, echo = FALSE}
    bookdown::embed_png("screenshots/git-proj-config.png", dpi = 220)
    ```
    
    그러면 RStudio를 제시작하라는 메시지가 뜬다.
    

  * 쉘에서, `git init`을 실행한다. RStudio를 재시작하고 팩키지를 작성한 팩키지를 다시 연다.
  

Git이 초기화되면, 신규 컴포넌트 두개를 볼 수 있다:

  * 우측 상단에 __Git 창(pane)__에서 무슨 파일이 변경되었는지 알 수 있고,
    가장 중요한 Git 명령어 버튼도 포함돼 있다:
  
    ```{r, echo = FALSE}
    bookdown::embed_png("screenshots/git-pane.png", dpi = 220)
    ```

  * 툴바에서 찾을 수 있는 __Git 드롭다운(dropdown)__는 현재 파일에 적용할 수 있는
    Git과 GitHub 명령어가 포함되어 있다:
    
    ```{r, echo = FALSE}
    bookdown::embed_png("screenshots/git-dropdown.png", dpi = 220)
    ```

## 변경된 사항 살펴보기 {#git-status}

첫번째 Git 사용 장점은 개발하면서 만든 변경사항을 쉽게 볼 수 있다는 것이다.
우연히 키보드 단축키를 잘못 눌러서 코드에 길 잃은 문자를 코드에 넣었을 때, 저자는 이 기능이 정말 도움이 된다고 본다. 
RStudio Git 창에는 추가되고, 변경되고, 삭제된 모든 파일 목록이 나와 있다.
각 아이콘이 변경된 내역을 기술한다:

* `r bookdown::embed_png("screenshots/git-modified.png", dpi = 220)`, 
  __Modified__. 파일 내용이 변경되었다.

* `r bookdown::embed_png("screenshots/git-unknown.png", dpi = 220)`, 
  __Untracked__. Git 시스템이 이전에 본적이 없는 신규 파일이 추가되었다.

* `r bookdown::embed_png("screenshots/git-deleted.png", dpi = 220)`, 
  __Deleted__. 파일이 삭제되었다.


"diff", `r bookdown::embed_png("screenshots/git-diff.png", dpi = 220)` 명령어로
변경사항에 대한 좀더 상세한 내역을 볼 수 있다. 신규 창을 열어 구체적인 차이(**diff**erences)를 보여준다:

```{r, echo = FALSE}
bookdown::embed_png("screenshots/git-diff-window.png", dpi = 220)
```

배경색을 통해서 텍스트가 추가(녹색)되었는지 삭제(적색)되었는지 알 수 있다.
(만약 색맹이라면, 가장 왼쪽에 두 칼럼에 행번호로 알 수 있다: 첫번째 칼럼 숫자는 이전 버젼, 두번째 칼럼 숫자는 신규 버젼을 나타낸다.)
변경사항 위아래 코드 회색줄은 추가적인 내용을 전달한다.

쉘에서, `git status` 명령어를 사용해서 전반적인 변경사항을 확인할 수 있고,
`git diff`를 사용해서 차이분에 대한 자세한 사항을 볼 수도 있다.

## 변경사항 기록 {#git-commit}

Git에서 작업 기본 단위는 __커밋(commit)__이다.
커밋은 특정 시점에 작성한 코드에 대한 짧은 묘사정보(스냅샷, Snapshot)를 기록한다.
Git 커밋을 사용하는 것은 등반할 때 앵커와 기타 보호장구를 사용하는 것과 같다.
만약 위험한 바위를 가로지를 때, 추락하게 되면 잡아줄 보호장치가 확실히 필요할 것이다.
커밋이 유사한 역할을 한다: 만약 실수를 하게 되면, 이전 커밋 이후로 추락되지 않게 된다.
커밋이 없는 코딩은 도구 없이 하는 (암벽) 등반같다: 
단시간에 훨씬 더 빨리 이동할 수 있지만, 장기적으로 보면 비극적 실패 가능성도 높다!
암벽등반 보호장구처럼, 커밋을 사용할 때 신중히 판단해야 된다.
너무 자주 커밋하게 되면 진행을 더디게 한다; 불확실하고 위험한 영역에 있을 때는 커밋을 더 많이 사용하라. 커밋은 다른 사람에게도 도움이 된다. 왜냐하면, 목적지 뿐만 아니라 여행경로도 볼 수 있기 때문이다.

매번 커밋할 때마다 5가지 주요한 구성요소가 있다:

* 유일무이한 식별자, SHA라고 불림 (secure hash algorithm의 약자로 보안 해쉬 알고리즘).

* 무슨 파일이 추가, 변경, 삭제되었는지 기술하는 변경집합(changeset).

* 사람이 읽을 수 있는 커밋 메시지.

* 부모 커밋, 해당 커밋 이전 커밋. (이 규칙에는 예외가 두가지 있다:
  최초 커밋은 부모가 없고, 나중에 학습할 병합(merge)은 부모가 둘이다.)

* 저자(author)

두 단계로 나누어서 커밋을 생성한다:

1.  __준비(staging)__ 단계에서, 다음번 커밋에 어떤 변경사항이 포함되어야 하는지 Git에게 일러준다.


1. __커밋(commit)__ 단계에서, 준비된 파일을 메시지로 변경사항을 기술하고 커밋한다.

RStudio에서, 준비(staging)와 커밋(commit)은 동일 장소에서 수행된다.
`r bookdown::embed_png("screenshots/git-commit.png", dpi = 220)`을 클릭하거나, Ctrl + Alt + m 단축키를 누르면 커밋 윈도우가 나온다.

```{r, echo = FALSE}
bookdown::embed_png("screenshots/git-commit-window.png", dpi = 220)
```

커밋 윈도우는 창(pane) 세개로 구성된다:

* 좌측 상단 창(pane)에 현재 상태정보가 있는데 RStudio 윈도우 Git 창(pane)에 있는 것과 같다.

* 아래 창(pane)에는 현재 선택된 파일 차이(diff) 정보가 나와 있다.

* 우측 상단 창(pane)에는 커밋할 때 변경 내용을 요약해서 사람이 읽을 수 있는 
  메시지를 입력하는 곳이다. 좀더 자세한 사항에 대해서 곧 다시 다룰 예정이다.
  
(그렇다, `r bookdown::embed_png("screenshots/git-diff.png", dpi = 220)` 를 클릭할 때,
나타나는 창과 정확하게 동일하다!)  

신규 커밋을 생성하기 위해서:


1.  __변경사항을 저장한다__.

1.  `r bookdown::embed_png("screenshots/git-commit.png", dpi = 220)`을 클릭하거나 
    `Ctrl + Alt + m` 단축키를 눌러 __커밋 윈도우를 연다__.

1.  __파일을 선택한다__. 포함시킬 파일을 준비(staging)시키려면, 확인란(check box)를 선택한다.
    모든 파일을 준비(staging)시키려면, Ctrl/Cmd + A 단축키를 누르고 나서, 
    `r bookdown::embed_png("screenshots/git-stage.png", dpi = 220)`을 클릭한다.

    각 파일을 준비시킬 때, 상태가 변경되는 것을 알아챘을 것이다.
    아이콘이 오른쪽(준비되지 않은 상태, unstaged)에서 왼쪽(준비된 상태, staged)으로 
    칼럼을 변경한다. 그리고 다음 신규 아이콘 두개중 하나를 볼 수도 있다.
    

      * 추가(added): `r bookdown::embed_png("screenshots/git-added.png", dpi = 220)`: 
        추적되지 않은 파일을 준비상태로 올린 후에, 개발자가 신규 파일을 저장소에 추가하고자 
        한다는 것을 Git 시스템이 이제는 알고 있다.
      
      * 이름 변경(renamed): `r bookdown::embed_png("screenshots/git-renamed.png", dpi = 220)`:
        만약 파일 이름을 변경하면, 처음에 Git은 파일을 삭제하고 추가한 것으로 본다.
        두 변경사항을 준비단계로 올리게 되면, Git이 이름변경을 인지한다.
    
    종종, 두 칼럼에 걸친 상태 아이콘을 보게 된다, 예를 들어, `r bookdown::embed_png("screenshots/git-modified-staged.png", dpi = 220)`.
    동일한 파일이 준비상태기도 하고 준비되지 않은 상태이고도 하다는 것을 의미한다.
    일부 변경을 하고 준비상태로 올려놓은 다음에, 일부 변경을 할 때 이런 경우가 발생한다.
    준비상태 체크박스를 클릭하면 신규 변경사항이 준비상태로 올라가고,
    다시 체크박스를 클릭하면, 양쪽 변경사항 모두 준비상태에서 풀려 내려온다.
    

1.  위와 마찬가지로 __파일을 준비상태로 올린다__.

1.  __커밋 메시지를 작성한다__ (우측 상단 창), 메시지에는 변경사항을 기술한다.
    커밋 메시지 첫번째 행을 제목란으로 불리는데 간결해야 된다 (문자 50개 이하).
    복잡한 커밋에는, 빈줄을 넣고 나서 문단 혹은 글머리표를 통해 상세한 내용을 적는다.
    누군가에게 무엇을 수행하라고 지시하는 것처럼, 명령조로 메시지를 작성하라:
    "이 버그를 고쳤다(fixed this bug)" 혹은 
    "이 버그는 고쳐졌다(this bug was fixed)"가 아니라 "이 버그를 고쳐라(fix this bug)".

1.  __커밋(Commit)을 클릭한다__.

파일을 준비단계로 올리는 것은 쉘에서 다소 복잡하다.
`git add`를 사용해서 신규, 변경된 파일을 준비단계로 올린다. `git rm`를 사용해서 준비단계에 올라간 파일을 삭제한다. 커밋을 생성하려면, `git commit -m <message>` 명령어를 사용한다.

## 커밋 모범사례 {#commit-best-practices}

이상적인 것은 각 커밋은 _최소(minimal)_지만 _완결(complete)_되야 된다:


* __최소(Minimal)__: 한 커밋에는 단일문제에 연관된 변경사항만 담겨져야 된다.
  이렇게 함으로써 한번에 커밋된 것을 이해하고 간단한 메시지로 기술하기도 더 쉽게 된다.
  만약 새로운 문제를 발견한다면, 구별되는 별도 커밋을 수행해야 된다.

* __완결(Complete)__: 해결하려고 주장하는 문제를 한 커밋으로 해결한다.
  만약 버그를 고쳤다고 생각하면, 커밋은 단위 테스트를 포함해서 주장이 맞다는 사실을 확인해야 한다.

각 커밋 메시지는 다음과 같아야 된다:

* __간략하지만, 연상시켜야 된다__. 한눈에, 커밋이 무엇을 했는지 알 수 있어야 된다.
  하지만, 충분히 구체적인 사항이 녹아져서 무엇이 수행되었는지 기억할 (그리고 이해할) 수
  있어야 된다.

* __대상(what)이 아니라 이유(why)를 기술하라__. 커밋과 연관된 차이(diff)를 항상 불러올 수 
  있기 때문에, 메시지에 정확하게 무엇이 변경되었는지 적을 필요는 없다.
  대신에, 변경에 대한 이유에 집중한 높은 수준의 요약정보를 제공해야 된다.

만약 상기 사항을 잘 수행한다면:


* 다른 개발자와 공동작업하기가 더 쉽다. 예를 들어, 만약 두 사람이 같은 곳에서 같은 파일을
  변경했다면, 충돌을 해결하기 더 쉽다. 왜냐하면, 커밋 단위가 작고, 
  각 변경에 대한 사유가 명확하기 때문이다.

* 프로젝트 신규 참가자도 커밋 로그를 읽으면 지나온 이력을 더 쉽게 이해할 수 있다.

* 개발이력을 따라 특정 지점에서 작성한 팩키지를 적재하고 실행할 수 있다.
  [bisectr](https://github.com/wch/bisectr)같은 도구를 함께 사용하면 매우 유용하다.
  이진 검색을 사용해서 신속하게 버그가 주입된 커밋을 색출할 수 있다.
  
* 언제 버그가 주입되었는지 정확하게 알 수 있게 되면, 
  무엇을 수행하면 되는지 (그리고 왜!) 쉽게 이해할 수 있다.

어떤 누구도 개발하고 있는 저장소를 살펴보지 않을 것이기 때문에, 좋은 커밋 메시지를 작성하는 것이 노력대비 가치가 없을 것으로 생각할지도 모른다.
하지만, 매우 중요한 공동작업자가 있다는 것을 명심하라: 미래의 당신!
만약 지금 커밋 메시지에 약간 공을 드리면, 버그에 대한 부검을 한다면 그리고 부검을 할 필요가 있다면
미래의 당신이 매우 고마워할 것이다.

이러한 지시사항은 단지 열망을 담고 있다고 기억하기 바란다.
이러한 것이 방해가 되서는 않된다.
만약 여러분이 저자 저장소 커밋 이력을 본다면, 많은 부분은 그다지 훌륭하지 못하다는 것을 알아챘을 것이다. 특히, __여전히__ 어떻해서든지 버그를 고쳐보려고 하지 못할 정도로 좌절이 시작될 때 더욱 그렇다. 상기 안내지침을 따르려고 노력하고, 하나의 완전한 커밋보다는 다수 불완전한 커밋이 더 낫다.

## 파일 무시하기 {#git-ignore}

종종, 저장소에 포함하고 싶지 않은 파일이 있다.
이러한 유형의 파일은 일시적이고(LaTeX 혹은 C 빌드 산출물), 매우 크거나, 요청시 생성되는 것이 포함된다. 매번 주의를 기울여 준비단계로 _올리지 않는_ 대신에, `.gitignore` 파일에 추가하면 된다.
이 기능을 통해서 준비단계로 올려지는 것을 방지한다.
가장 쉬운 방법은 Git 창(pane)에서 우클릭해서 `Ignore`를 선택한다:


```{r, echo = FALSE}
bookdown::embed_png("screenshots/git-ignore.png", dpi = 220)
```

만약 파일 다수를 무시하려면, `*.png` 처럼 와일드카드 "글롭(glob)"을 사용할 수 있다.
선택옵션에 관한 좀더 학습하려면, Pro-Git 책에 [파일 무시하기](http://git-scm.com/book/ch2-2.html#Ignoring-Files)를 참조한다.

일부 개발자는 파생파일을 절대로 커밋하지 않는다. 파생파일은 자동으로 생성될 수 있다.
R 팩키지 개발에서는 `NAMESPACE` 파일과 `man/` 디렉토리에 담기는 파일이 버전관리에서 무시된다는 것을 의미한다. 왜냐하면 주석으로부터 만들어지기 때문이다. 실무적인 면에서는 이러한 파일도 커밋하는 것이 낫다: R 팩키지가 설치에 `.Rd` 파일을 만들어낼 방도가 없다. 그래서, 파생파일을 무시하게 되면 GitHub에서 작성한 팩키지를 설치한 사용자는 문서가 전혀없게 된다.

## 실수 실행취소(Undo) {#git-undo}

커밋을 사용하게 되면 가장 좋은 점은 실수를 실행취소할 수 있다는 것이다.
RStudio는 이러한 점을 특히 쉽게 만들었다:


*   방금 변경한 사항을 실행취소하려면, Git 창(pane)에서 파일을 우클릭하고 되돌리기 "revert"를
    선택한다. 이러게 하면 이전 커밋으로 변경사항을 다시 되돌린다. 
    주의: 이 작업을 다시 실행취소할 수는 없다!

    차이 (diff) 윈도우에 파일 일부만 실행취소할 수도 있다.
    실행취소 하고자하는 변경 블록 상단에 __discard chunk__를 찾아봐라: 
    `r bookdown::embed_png("screenshots/git-chunk.png", dpi = 220)`.
    개별 행 혹은 선택한 텍스트에 변경사항도 폐기할 수 있다.
    

*   만약 너무 일찍 변경사항을 커밋했다면, 추가 변경사항을 준비단계로 올려서
    이전 커밋을 변형할 수 있다. 커밋을 클릭하기 전에, 
    `r bookdown::embed_png("screenshots/git-commit-amend.png", dpi = 220)`
    체크박스를 선택하라. 
    (이전 커밋을 GitHub에 푸쉬했다면, 이 기능을 사용하지 마라 -
    이력(history)을 효과적으로 다시 작성하는 방법으로, 공공장소에서 작업을 할 때는
    주의를 기울여야 한다.)

즉석에서 실수를 잡아내지 못한다면, 이력을 거슬러 올라가서 살펴보고, 실수가 발생한 장소를 찾아낼 필요가 있다:


1.  Git 창(pane)에서 `r bookdown::embed_png("screenshots/git-history.png", dpi = 220)` 을
    클릭해서 이력(history) 윈도우를 연다.
    
    ```{r, echo = FALSE}
    bookdown::embed_png("screenshots/git-history-window.png", dpi = 220)
    ```

    이력 윈도우는 두 부분으로 나뉘어진다.
    상단 부분은 저장소에 모든 커밋 목록을 출력한다.
    하단 부분은 커밋을 보여준다: SHA (유일무이한 id), 저자, 날짜, 부모, 커밋 변경사항.
    
    
1.  실수가 일어난 커밋을 찾아낼 때까지 시간을 거슬러 탐색한다.
    부모 SHA 코드를 적는다: 실수를 저지르기 전 커밋으로 다시 작업하는 시점으로 적절할 것이다.


이제 쉘에서 상기 SHA 코드를 사용한다:

*   파일이 과거에 어땠는지 보고서 이전 코드를 복사해서 붙여넣을 수 있다:

    ```bash
    git show <SHA> <filename>
    ```

*   혹은 과거 버젼을 복사해서 현재로 가져온다:

    ```bash
    git checkout <SHA> <filename>
    ```

상기 두가지 경우 모두 파일을 준비단계로 올리고 커밋해서 마무리할 필요가 있다.
    
(마치 시간을 거슬러 올라가서 실수가 처음부터 발생하지 않은 것처럼 Git를 사용하는 것도 가능하다.
이것이 __이력 리베이스(rebasing history)__로 불리는 고급기술이다. 상상하듯이, 과거를 변경하려고 시간을 거슬러 올라가면 현재에도 심오한 영향을 준다. 유용할 수 있지만, 극도로 조심해서 사용될 필요가 있다.)

그래도 여전히 문제에 봉착했다면, <http://sethrobertson.github.io/GitFixUm/fixup.html> 혹은 <http://justinhileman.info/article/git-pretty/>을 참조한다.
흔히 있는 (그다지 흔하지는 않음!) 많은 문제를 고치는데 단계별 접근법을 제시하고 있다.

## GitHub과 동기화 {#github-init}

지금까지 로컬 컴퓨터에서만 작업을 해왔다. 커밋을 사용해서 프로젝트 진도를 추적하고 안전 검사점(checkpoint)도 찍었다. 하지만, Git이 정말 빛을 발할 때는 작성한 코드를 
[GitHub](http://github.com)으로 다른 개발자와 공유하기 시작할 때다.
다른 선택지가 있지만, 저자는 GitHub을 추천하는데 이유는 공개 소프트웨어 프로젝트에 대해서는 무료고, 필요한 모든 기능을 갖추고 있으며, R 개발자 세상에서는 가장 대중적인 선택이라서 그렇다.

작성한 코드를 GitHub에 게시, 즉 __푸시(push)__하려면:



1.  GitHub에 신규 저장소를 생성한다: <https://github.com/new>.
    작성한 팩키지와 동일한 명칭을 부여하고, 팩키지 제목을 저장소 설명으로 추가한다.
    다른 선택옵션을 그대로 두고, 완료(Submit) 버튼을 클릭한다.

1.  쉘을 열고 나서, 신규 저장소 페이지 안내절차를 따른다.
    안내절차는 다음과 같을 것이다:

    ```bash
    git remote add origin git@github.com:hadley/r-pkgs.git
    git push -u origin master
    ```
    
    상기 첫번째 줄을 해석하면, 로컬 저장소가 GitHub에 원격 버젼 저장소를 갖고 있는데 
    "origin"으로 칭한다. 두번째 줄은 현재 모든 작업결과를 원격 저장소에 밀어 넣는다는 
    것을 의미한다.

이제 커밋을 하고, 원격 저장소가 갱신되었는지 확인하자:

1.  `DESCRIPTION` 파일을 변경해서 `URL` 과 `BugReports` 필드를 추가해서
    신규 GitHub 사이트에 연결한다. 예를 들어, `dplyr`은 다음과 같다:

    ```yaml
    URL: http://github.com/hadley/dplyr
    BugReports: http://github.com/hadley/dplyr/issues
    ```

1.  파일을 저장하고 ("Updating DESCRIPTION to add 
    links to GitHub site") 메시지를 넣어 커밋한다.
    
1.  `r bookdown::embed_png("screenshots/git-push.png", dpi = 220)`을 클릭해서 GitHub에
   변경사항을 __푸쉬(Push)__한다. (쉘에서 `git push` 명령어를 실행한 것과 동일하다).
    
1.  GitHub 페이지로 돌아가서 `DESCRIPTION` 파일을 살펴본다.

대체로, 푸쉬 각각에는 다수 커밋이 포함된다.
왜냐하면, 커밋하는 것보다 덜 푸쉬하기 때문이다.
얼마나 자주 푸쉬 vs 커밋 비율을 갖는지는 완전히 개발자 본인에게 달려있다.
하지만, 코드를 푸시는 코드를 출시한다는 의미가 된다. 그래서 정상 동작하는 코드를 푸쉬하려고 노력하라.

작성한 코드가 정확하다는 것을 확실히 하려면, 저자는 항상 코드를 푸시하지 전에 `R CMD check` 명령어 실행을 추천한다 ([automated checking](#check)에서 배울 주제).
(아직) 정상 동작하지 않는 코드를 게시하려면, 다음 [branching](#git-branch)에서 학습할 예정인,
브랜치(branch) 사용을 추천한다.


로컬 저장소를 GitHub에 연결하게 되면, Git 창(pane)에 GitHub에 푸쉬되지 않고 로컬 저장소에 커밋된 정보를 보여준다: `r bookdown::embed_png("screenshots/git-local-commits.png", dpi = 220)`.
이 메시지가 나타내는 것은 로컬(브랜치)에 커밋이 1개 있는데 GitHub("origin/master")에는 올라가지 않았다는 것이다.


## GitHub 사용에 따른 혜택 {#github-benefit}

1.  괜찮은 웹사이트가 생김. 팩키지에 대한 GitHub 페이지에 팩키지에 대한 모든 파일과 디렉토리 
    목록이 올라간다. 예를 들어, <https://github.com/hadley/testthat> (the GitHub repo for testthat). 
    `.R` 파일은 구문 강조 기능으로 서식이 입혀지고, `.md`/`.Rmd` 파일은 HTML로 렌더링된다.
    그리고, 만약 최상위 디렉토리에 `README.md` 파일을 포함하게 되면, 홈페이지로 화면에 출력된다.
    [README.md](#readme)에서 이 파일 생성에 따른 혜택에 대해서 더 배울 예정이다.

1.  작성한 팩키지를 다른 누군가 설치하기 쉽게 한다. 
    (그리고 개발자의 노고에 대한 혜택도 포함된다):

    ```r
    devtools::install_github("<your_username>/<your_package>")
    ``` 

1.  커밋 보기에서 프로젝트 이력을 추적할 수 있다. 예를 들어, 
    <https://github.com/hadley/testthat/commits/master>.
    다른 개발자와 저자가 팩키지에 대한 작업을 할 때,
    해당 페이지를 공개해서 다른 개발자가 작업하는 것을 볼 수 있다.
    개별 커밋에는 RStudio commit/diff 창에서 보는 것과 
    동일한 정보가 나타나 있다.
    

1.  파일 이력을 보는 것도 쉽다.
    만약 파일을 탐색하고 __이력(History)__을 클릭하면,
    파일에 영향을 준 모든 커밋 정보가 나와 있다.
    또다른 유용한 관점은 __책임(Blame)__이다;
    각 코드 라인에는 최종 변경정보, 변경작업한 개발자 정보, 변경사항이 속한 커밋정보가 
    나와있다. 버그를 추적해서 좁혀갈 때, 엄청나게 도움이 된다.

    RStudio 툴바에 있는 Git 드롭다운 메뉴를 통해서 해당 페이지로 바로 들어갈 수 있다: 
    
    ```{r, echo = FALSE}
    bookdown::embed_png("screenshots/git-dropdown.png", dpi = 220)
    ```

1.  커밋에 주석을 달 수도 있다. 전체로 커밋에 주석을 달려면,
    페이지 하단에 주석상자를 활용한다.
    각 라인에 주석을 달려면, 해당 라인에 마우스를 갖다대면 더하기 기호가 생기는데 이를 클릭한다, 
    `r bookdown::embed_png("screenshots/github-comment-line.png", dpi = 220)`.
    실수한 것을 보거나 질문이 있을 때 동료개발자에게 정보를 제공하는 훌륭한 방법이다.
    전자우편보다 더 좋은데 이유는 공개되어 있어
    저장소에 작업하고 있는 (현재 혹은 미래) 누구나 대화내용을 볼 수 있기 때문이다.


## 다른 개발자와 공동 작업하기 {#git-pull}

GitHub에 작성한 변경사항을 전송할 때 __푸쉬(push)__를 사용한다.
만약 다른 개발자와 공동 작업할 때, 상대 개발자도 GitHub에 그들이 작업한 변경사항을 푸쉬한다.
하지만, 로컬에서 변경사항을 보려면, GitHub에서 변경사항을 __풀(pull)__해서 가져와야 된다.
사실, 모든 개발자와 동기화를 확실히 하려면, 풀 명령어로 가장 최신 버젼을 받아오면
저장소에 푸쉬만 Git이 허락한다.


풀 명령어를 실행하면, Git은 먼저 모든 변경사항을 다운로드(__fetch__)하고 나서 로컬에서 작업한 변경사항과 __병합(merge)__한다.
병합은 두 부모를 갖는 커밋이다. 서로 다른 두 개발 코드를 결합해서 단일 결과로 만든다.
많은 경우에, 자동으로 Git이 작업을 수행한다: 예를 들어,
다른 파일에, 혹은 동일한 파일에 다른 부분에 변경사항이 반영되어 있다면 자동으로 작업한다.
하지만, 파일 동일한 장소에 변경사항이 반영되어 있다면, 개발자 본인 스스로 __병합충돌(merge conflict)__을 해소해야만 된다.


RStudio에서, 다음과 같은 경우에 병합충돌을 발견할 수 있다:

* 풀 작업이 오류로 실패하는 경우.

* Git 창에, `r bookdown::embed_png("screenshots/git-commit-conflict.png", dpi = 220)` 
  상태정보가 뜰 경우.

RStudio에서 현재 병합 충돌에 도움이 되는 어떤 도구도 제공하고 있지 않다.
그래서, 명령라인 인터페이스에서 작업해야 된다.
저자는 병합충돌 "스타일(style)"을 `diff3`로 설정해서 작업할 것을 추천한다.
병합충돌이 발생할 때, `diff3` 스타일에는 세가지 정보가 나타난다: 로컬 변경사항,
원래 파일, 원격 변경사항. 디폴트 기본설정 스타일은 `diff2`로 로컬 변경사항과 원격 변경사항 정보만 나타나 있다. 일반적으로 `diff2` 스타일로는 무슨 일이 발생했는지 파악하기 더 어렵다.


* 첫번째 병합 충돌과 조우하면, 다음을 수행한다:

    ```bash
    # 해당 병합을 중단시킨다.
    git merge --abort
    # 충돌 스타일을 환경설정한다
    git config --global merge.conflictstyle diff3
    # 병합을 다시 시도한다.
    git pull
    ```
    
* 만약 병합충돌 과정에 있지 않다면, 다음만 실행한다.

    ```bash
    git config --global merge.conflictstyle diff3
    ```

병합충돌을 해결하기 위해서는, 상태정보 `r bookdown::embed_png("screenshots/git-commit-conflict.png", dpi = 220)`을 갖는 모든 파일을 열어서 살펴볼 필요가 있다. 각 파일에서 다음과 같은 충돌 표식이 보일 것이다:

```
<<<<<<< HEAD

||||||| merged common ancestors

=======

>>>>>>> remote
```

충돌을 일으킨 코드에 세가지 모든 버젼 정보가 나타나 있다:

* 상단에, 작성한 로컬 코드.

* 중간에, 두줄 개발코드 사이에 분기 전 최종 커밋에서 나온 코드
  (디폴트 기본설정 충돌 스타일에는 생략된다. 그래서 만약 중간부분이 보이지 않는다면,
  상기 안내지침을 따라 설정하면 보인다).

* 하단에, GitHub에서 풀명령으로 내려받은 원격 코드.

각 충돌 문제를 해결하고 어느 쪽 버젼이 더 나은지 혹은 어떠한 방식으로 병합할지 결정도 해야 된다.
그리고 나서, 파일을 준비단계에 올리기 전에, 모든 충돌 표식을 삭제했는지 확실히 한다.
모든 충돌사항을 고치고 나면, 신규 커밋을 생성해서 GitHub에 푸쉬해서 올린다.

`roxygen`으로 생성된 텍스트 문제를 고칠 때 몇가지 유의점이 있다:

* `man/*.Rd` 파일에 문제를 직접 고치지 마라. 대신에 
  근본이 되는 roxygen 주석에 충돌을 해결하고 팩키지를 다시 문서화한다.
  
* `NAMESPACE` 파일에 병합충돌로 인해 팩키지를 재적재 혹은 재문서화가 되지 않는다.
  충분히 충돌문제를 해결해서 팩키지가 적재되도록 하고나서 깨끗하고 정확한 `NAMESPACE`를 
  생성하도록 다시 문서화한다.

병합충돌 처리는 Git에서 가장 까다로운 부분중 하나다.
요령을 터득하기 전에 사용지침서 몇개를 읽을 필요가 있다.
구글과 스택오버플로우는 그자체로 훌륭한 교재다.
만약 끔찍할 정도로 혼란스러울 경우에는 항상 병합을 중단하고 다시 시작한다.
그때는 `git merge --abort` 명령어를 실행하고 나서, `git pull` 명령어를 차례로 실행한다.


## 이슈사항 (Issues) {#github-issues}

모든 GitHub 저장소에는 이슈사항을 추적하는 페이지가 딸려온다.
사용해라! 또다른 프로젝트에 작업하다가 버그와 조우하게 되면, 이슈 페이지에 노트해 적어둬라.
조금더 작은 프로젝트를 갖고 있다면, 이정표를 세우고, 태그달고, 특정 개발자에게 이슈를 배정하는 것에 대해 너무 걱정하지 마라. 한 페이지에 걸친 이슈를 처리해야 되면 (>50), 이러한 면이 더 유용하게 된다. 그 지점에 도달하게 되면, 이슈에 대한 GitHub 안내서를 읽어보라: <https://guides.github.com/features/issues/>.

유용한 기술은 커밋 메시지로 이슈를 마감하는 것이다.
커밋 메시지 어딘가에 `Closes #<issue number>` 만 넣으면,
다음번 푸쉬할 때 GitHub이 알아서 이슈를 마감해준다.
이러한 방식으로 이슈를 마감하게 되면 가장 좋은 점이
커밋과 이슈에 연결 링크를 생성하는 것이다.
만약 버그로 다시 되돌아와서 버그를 고치려고 무슨 작업을 했는지 확인하고자 할 때 유용하게 사용된다.
마감하지 않고 이슈에 연결 링크를 걸 수도 있다; `#<issue number>` 참조를 넣는다.

[NEWS.md](#news)에서 더 많이 학습할 것으로, 이슈사항을 마감할 때마다 `NEWS.md` 파일에 글머리표를 추가하는 것이 좋다. 글머리표는 이슈사항을 사용자가 이해하는 용어로 기술해야 된다. 커밋 메시지가 개발자를 위해 작성된 것과 반대다.

## 브랜치 (Branches) {#git-branch}

종종 개발 주요 흐름을 방해하지 않으면서 코드에 큰 변경을 가하고 싶을 때가 있다.
아마도 코드를 간단한 다수 커밋으로 쪼개서 쉽게 변경사항을 추적하게 만들 수 있다.
변경사항이 최선의 선택인지 확신하지 못한다면 누군가에게 부탁해서 코드 검토를 받고 싶을 지도 모른다.
혹은, 일부 실험을 진행하고 싶을지도 모른다 (만약 실험이 성공했들 때만 병합작업을 수행한다).
이러한 상황에는 브랜치(branch)와 풀 요청(pull request)이 강력한 도구가 된다.

인식하고 있지 못했을 수도 있지만, 이미 브랜치를 사용하고 있다.
디폴트 기본설정 브랜치(branch)를 __마스터(master)__라고 부른다;
이곳이 작성한 커밋을 저장하는 장소가 된다.
만약 작성한 코드를 GitHub과 동기화시키면, __오리진/마스터(origin/master)__ 브랜치를 갖게 된다:
GitHub에 전체 커밋한 로컬 복사본으로, 풀 명령어로 끌어올 때 동기화된다.
`git pull` 명령어는 두가지 작업을 수행한다:

1.  `git fetch origin master` 명령어는 GitHub으로부터 가장 최신 커밋으로 
    로컬 `origin master` 브랜치를 갱신한다.
  
1.  `git merge orgin/master` 명령어는 원격 변경사항과 로컬 작업한 변경사항을 결합한다.

(임시로) 주요 개발 흐름에서 벗어날 때 자신만의 개발 브랜치를 생성하는 것이 유용하다.
`git checkout -b <branch-name>` 명령어로 신규 브랜치를 생성할 수 있다.
명칭은 소문자와 숫자로 `-`를 사용해서 단어를 구분한다.

`git checkout <branch-name>` 명령어로 브랜치를 전환한다.
예를 들어, 다시 주 개발흐름으로 돌아가려면 `git checkout master` 명령어를 사용한다.
또한, Git 창(pane) 우측 상단에 브랜치 전환자(switcher)를 사용해도 된다:
  
```{r, echo = FALSE}
bookdown::embed_png("screenshots/git-branch.png", dpi = 220)
```

만약 쉘에서 브랜치 명칭을 잊어버렸다면, `git branch` 명령어를 사용해서 존재하는 모든 브랜치 목록을 볼 수 있다.

만약 RStudio 내부로부터 해당 브랜치를 GitHub과 동기화하려면,
풀과 푸쉬가 모두 비활성화된 것을 알아챘을 것이다: `r bookdown::embed_png("screenshots/git-no-remote.png", dpi = 220)`.
비활성화된 것을 활성화시키려면, 로컬브랜치가 동등한 원격브랜치가 있다는 사실을 Git에게 먼저 일러줘야만 된다:

```bash
git push --set-upstream origin <branch-name>
```

상기 명령어로 한번 수행하고 나면, 일상으로 돌아와 다시 풀과 푸쉬 버튼을 사용할 수 있다.

한동안 브랜치에서 작업을 수행하면, 다른 작업은 마스터 브랜치에서 진행될 수 있다.
해당 작업을 브랜치와 통합하려면, `git merge master` 명령어를 실행한다.
(위에서 살펴본) 병합충돌을 해결할 필요는 여전히 남아있다.
상당히 자주 병합충돌 해소작업을 수행하는 것이 최선이다 - 마스터에서 브랜치가 덜 분기해 나갈수록,
병합작업을 수행하는 것이 더 쉬워진다.

브랜치에서 작업을 완료하면, 마스터 브랜치에 다시 작업결과를 병합하고 나서, 해당 브랜치를 삭제한다:

```bash
git checkout master
git merge <branch-name>
git branch -d <branch-name>
```

(마스터 브랜치에 병합작업을 수행하지 않으면, 해당 브랜치를 삭제하지 못하는 역할을 Git이 수행한다.
만약 병합하지 않고 해당 브랜치를 버릴려면, `-d` 옵션 대신에 `-D` 옵션으로 강제로 삭제할 필요가 있다. 만약 우연히 브랜치를 삭제했다면 당황하지 마라. 대체로 다시 되돌리는 것이 가능하다. 실수를 실행취소하는 조언을 참고하라).


## 풀 요청하기 {#git-pullreq}

풀 요청(pull request)은 저장소에 변경사항을 병합하기 전에 변경사항을 제안하고 논의하는데 사용되는 도구다. 가장 일반적인 풀요청을 사용례는 다른 개발자 코드에 기여하는 것이다:
본인이 제어권한이 없는 코드에 변경사항을 제안하는 가장 쉬운 방법이다.

아래에서 본인 자신의 코드를 변경하는데 사용되는 풀요청을 학습할 것이다.
직접적으로 작성한 코드를 변경할 수 있어, 이러한 과정이 _필요하지 않기_ 때문에 다소 무의미하게 보일 수도 있다. 하지만, 풀요청은 놀랍게도 유용한데 이 과정을 통해서
제안된 변경사항에 대한 피드백을 얻을 수 있기 때문이다.
저자가 속한 팀에서 RStudio에 이러한 기능을 사용해서 주요 변경사항을 병합하기 전에 피드백을 받는다.

GitHub 사이트에 풀 요청 사용법에 대한 좋은 문서가 있다: <https://help.github.com/articles/using-pull-requests/>.
이번 장에서, 저자는 풀 요청을 효과적으로 사용하는데 알아야 되는 기본기에 초점을 맞췄다.
지금까지 학습한 Git 명령어로 어떻게 엮어서 사용하는지 보여줬다.

풀 요청을 생성하려면, 브랜치를 생성하고, 코드를 커밋하고 나서, 브랜치를 GitHub에 푸쉬한다.
다음번에 GitHub 웹사이트에 방문하면, 풀 요청을 제출하도록 초대하는 헤더 정보를 볼 수 있다.
다음 방법으로 동일한 작업을 수행할 수도 있다:

1.  브랜치를 전환한다:

    ```{r, echo = FALSE}
    bookdown::embed_png("screenshots/github-branches.png", dpi = 220)
    ```

1.  `r bookdown::embed_png("screenshots/pr-create.png", dpi = 220)`을 클릭한다.

상기 작업은 다음과 같은 페이지를 생성한다:

```{r, echo = FALSE}
bookdown::embed_png("screenshots/pr.png", dpi = 220)
```

상기 풀 요청은 작은 문제 몇개를 고치는 것으로 이 책 GitHub 사이트에 제출된 사례다.

풀 요청은 세가지 구성요소가 있다:


* __대화(conversation)__, 
  `r bookdown::embed_png("screenshots/pr-conversation.png", dpi = 220)`,
  여기서 변경사항을 토론할 수 있다.
  
* __커밋(commits)__ 뷰, 
  `r bookdown::embed_png("screenshots/pr-commits.png", dpi = 220)`,
  여기서 각 개별 커밋을 볼 수 있다.
  
* __파일 변경(file changes)__,
  `r bookdown::embed_png("screenshots/pr-changes.png", dpi = 220)`,
  여기서 전체 커밋 차이(diff)와 함께 각 개별 행에 대한 주석을 볼 수 있다.

풀 요청을 토론을 수행하면, 병합하거나 삭제할 수 있다.
병합작업은 쉘에서 `git merge <branchname>` 명령어를 실행하는 것에 대응된다;
삭제는 `git branch -r <branchname>` 명령어 실행에 대응된다.

## 풀 요청 사항을 또다른 저장소에 제출하기 {#pr-make}

본인이 소유하고 있지 않은 저장소에 풀 요청을 제출하려면,
먼저 본인이 소유할 수 있는 __포크(fork)__로 불리는 저장소 사본을 생성할 필요가 있다.
그리고 나서 본인 컴퓨터에 해당 포크를 복제(clone)한다.


1.  __포크(Fork)__ 작업은 GitHub 저장소로 가서 `r bookdown::embed_png("screenshots/github-fork.png", dpi = 220)`를 클릭하면 된다.
    이 작업을 통해 본인이 소유관리하는 저장소 사본이 생성된다.

1.  __복제(Clone)__ 작업은 포크한 저장소를 복제하여 원격저장소와 똑같은 로컬 사본을 생성한다.
    RStudio 내부에서 이 작업을 수행하는 것이 가능하다 
    ("Version Control"에서 "Create New Project" 기능을 사용한다). 하지만,
    쉘에서 동일한 작업을 수행하는 것이 좀더 쉽다고 저자는 판단한다:
    
    ```bash
    git clone git@github.com:<your-name>/<repo>.git
    cd <repo>
    ```

포크는 저장소의 _정적(static)_ 복사본이다: 
저장소 사본이 생성되면, GitHub은 상류 저장소와 동기화하는데 전혀 관여하지 않는다.
이것이 문제가 되는데 이유는 풀요청 작업을 하는 동안에, 원래 저장소에 변경사항이 일어날 수도 있다.
포크한 저장소와 원 저장소를 동기화 하려면, 상류 저장소에 관한 정보를 본인 저장소에 일러줘서 시작한다:

```bash
git remote add upstream git@github.com:<original-name>/<repo>.git
git fetch upstream
```

그리고 나서, 상류 저장소로부터 변경사항을 본인 로컬 사본과 병합한다:

```bash
git merge upstream/master
```

포크뜬 저장소에 작업할 때, 마스터 브랜치에서 작업하지 않도록 저자는 추천한다.
왜냐하면 해당 저장소 주요 개발선상에서 정말 작업하는 것이 아니기 때문에,
마스터 브랜치를 사용하는 것이 혼란을 불러올 수 있다.


만약 브랜치에서 풀 요청을 항상 생성하게 되면,
상류 저장소와 로컬 저장소를 동기화하는게 다음 명령어를 실행해서 약간 더 쉽게 만들 수 있다:

```bash
git branch -u upstream/master   
```

그리고 나서, 다음 코드로 로컬 저장소를 갱신할 수 있다:

```bash
git checkout master
git pull
```
풀요청작업을 하는 동안에 변경사항이 발생할지도 모른다. 그래서 다음 명령어로 작업중인 브랜치에 병합하는 것을 명심하라:

```bash
git checkout <my-branch>
git merge master
```

풀 요청(pull request, PR)은 브랜치에 일대일 매핑이다. 그래서 
이 기법을 사용해서 풀요청 토론에 기반해서 갱신할 수 있다.
변경할 때마다 새로운 풀요청을 생성하지 마라; 
대신에 PR이 기반한 브랜치에만 푸쉬하면 되고, PR 웹페이지는 자동으로 갱신된다.

다음 다이어그램에 상류 저장소가 변경될 때 풀 요청을 생성하고, 요청사항을 갱신하는 주요 단계가 그려져 있다:

```{r, echo = FALSE}
bookdown::embed_png("diagrams/pull-request-process.png", dpi = 220)    
```

## 풀 요청 검토와 승인 {#pr-accept}

작성한 팩키지가 점점 인기가 많아지면, 풀요청을 다수 받을 것 같다.
풀요청을 받는 것은 환상적이다.
누군가 개발한 팩키지를 사용할만큼 관심을 가져줄 뿐만 아니라,
실제로 소스코드를 읽고 개선도 해주다니 말이다!

풀 요청을 받으면, 사라 샤프(Sarah Sharp)가 기술한 세단계 접근법을 사용해서 검토하는 것을 저자는 추천한다. 저자는 다음에 세단계를 다음과 같이 요약했다. 하지만,
<http://sarah.thesharps.us/2014/09/01/the-gentle-art-of-patch-review/> 웹사이트에서 전체 기사를 읽어보는 것을 강력히 추천한다:

1.  좋은 생각인가? 만약 기여분이 본인 프로젝트와 잘 맞지 않는다고 생각되면,
    기여하신 분께 가능하면 빨리 알 수 있게하는 것이 예의바른 행동이다.
    기여하신 분께 감사의 말씀을 전하고 더 나은 곳에 다시 집중할 수 있도록 배려한다.
    
1.  전반적 접근방법이 올바른가? 이 지점에서 큰그림에 집중할 필요가 있다:
    기여하신 분이 올바른 방식으로 올바른 함수를 변경했는가?
    사소한 스타일 문제를 따지는 것은 피한다 (이점은 최종단계 이슈다);
    대신에 프로젝트 스타일에 대한 환경설정 정보를 제공한다, 예를 들어, 
    <http://r-pkgs.had.co.nz/style.html>.

1.  깔끔히 정리되었는가? 마지막 검토 단계에서, PR 요청 코드가 아닌 부분이 깔끔히 정리되었는지 
    확실히 한다. 기여하신 분께 맞춤법 검사와 더 나은 표현 제안을 통해서 문서를 갱신하게 한다.

    `NEWS.md` 파일에 글머리표를 포함해서 개선사항을 기술하고 GitHub 사용자명을 넣어 
    감사를 표시할 수 있게끔 기여하신 분께 요청하는 것을 저자는 추천한다.
    좀더 자세한 사항은 [post release](#post-release)에 나와 있다.

토의가 완료된 뒤에 병합 버튼을 클릭해서 변경사항을 반영한다.
만약 버튼이 잘 동작하지 않는다면, 명령라인 인터페이스에서 동일한 작업을 수행하는 안내가 GitHub에 나와 있다. 앞에서 필요한 모든 부분을 살펴봤지만, 해당 문서를 읽어보는 것이 도움이 된다.
그렇게 함으로써 정확하게 무슨 일이 일어나고 있는지 이해하게 된다.

```bash
# 신규 브랜치를 생성하고 풀 요청으로 동기화한다.
git checkout -b <branch> master
git pull https://github.com/<user>/<branch>.git patch-3

# 변경사항을 주요 개발선상에 병합한다.
git checkout master
git merge --no-ff <branch>
# 충돌을 해소하고, 준비단계로 올리고 추가한다.

# GitHub과 로컬 변경사항을 동기화한다.
git push origin master
```

## 추가 학습 {#git-learning}

Git과 GitHub은 풍부하고 강력한 도구 집합이다.
다른 어떤 방식으로도 필요한 모든 것을 이번 장에서 가르칠 수는 없다.
하지만, 효과적으로 기본 지식을 갖추었으니, 더 많은 학습을 이어나갈 좋은 위치에 섰다.
훌륭한 교재가 다음에 나와 있다:


* GitHub 도움말, <https://help.github.com>, GitHub에 대한 사용법 뿐만 아니라,
  많은 Git 기능에 대한 좋은 사용지침을 전달한다.


* Git 에 대한 세부내용에 관해서 좀더 학습하려면, Scott Chacon 과 Ben Straub이 저술한
  [Pro Git](http://git-scm.com/book/en/v2) 책을 탐독한다.

마지막으로, 스택오버플로우(StackOverflow)는 그자체가 Git의 핵심부분이다 -
해결방법을 모르는 문제를 갖게되면, 스택오버플로우가 첫 학습교재가 되야한다.
누군가 이미 여러분과 정확하게 동일한 문제를 가졌을 확률이 많이 높고,
다양한 접근방법과 더불어 고를 수 있는 선택지가 다수 있을 것이다.

[gh-issues]:https://guides.github.com/features/issues/
[gh-pr]: https://help.github.com/articles/using-pull-requests/
[gh-releases]: https://help.github.com/articles/about-releases/
