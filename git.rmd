---
title: Git and GitHub
layout: default
output: bookdown::html_chapter
---

# Git 와 GitHub {#git}

만약 소프트웨어 개발에 진지하게 임하려면, Git을 배울 필요가 있다.
Git은 _버젼제어시스템(version control system)_으로, 코드 변경사항을 추적하고 다른 개발자와 변경사항을 공유한다. Git이 [GitHub](http://github.com)와 조합되어 사용될 때 그 유용성은 배가된다. [GitHub](http://github.com)을 통해서 코드를 전세계 개발자와 공유하고 풀요청(pull request)와 이슈 추적을 통해 개선을 이어나간다. Git + GitHub 조합이 R 팩키지 개발자를 위한 가장 인기있는 버젼제어시스템이다. (GitHub에 올려진 수천개 R 패키지를 목도하라).


Git 과 GitHub 조합이 단지 R 팩키지에만 유용한 것이 아니라, 모든 소프트웨어 개발과 자료분석에도 일반적으로 유용하다. 이 책에서 Git 과 GitHub 포함했는데 이유는 팩키지 개발에 매우 유용하기 때문이다. 저자 등 뒤에서 신속하게 잘못된 것을 찾아내고 다른 개발자와 쉽게 협업이 가능하게 한다. Git 과 GitHub을 통하지 않고 더 생산성을 높이는 다른 방법은 없다. 

왜 Git + GitHub를 사용할까?


  * 팩키지 공유를 쉽게 만든다. 그리고, R 사용자는 다음 코드 두줄로 팩키지를 설치할 수 있다:
  

    ```{r, eval = FALSE}
    install.packages("devtools")
    devtools::install_github("username/packagename")
    ```
    
  * GitHub을 통해 작성한 팩키지에 대한 핵심사항만 담긴 웹사이트를 쉽게 생성할 수 있다.
    독자가 쉽게 코드를 탐색하고 (마크다운으로) 문서를 읽을 수도 있다.
    독자가 코드를 읽고 버그를 보고하고, GitHub 이슈를 통해 신규 기능을 제안할 수 있다.
    [GitHub issues][gh-issues]. 그리고 풀요청으로 작성한 코드에 기능향상을 제안할 수 있다.
  

  * 전자우편 혹은 드롭박스 폴더로 파일을 주고받으면서 누군가 코드를 협업해서 개발한 적이 있는가?
    두 개발자가 동일한 파일에 동시 작업하지 않고, 
    다른 개발자 변경사항을 덮어쓰기 해서 문제없이 하는데도 상당한 노력이 소요된다.
    Git가 있으면, 두 개발자 모두 편안하게 동시에 동일한 파일에 작업할 수 있다.
    Git가 변경사항을 자동으로 결합하거나, 모호한 부분과 충돌나는 것을 모두 보여준다.
  

  * 파일을 저장할 때 Cmd + S 대신에 `s`만 우연히 누른적이 있는가?
    추적하는데 몇분 걸리는 실수 혹은 버그를 우연히 만들어내는 것은 무척이나 쉽다.
    Git는 이러한 문제를 쉽게 탐지하기 한다. 왜냐하면 정확하게 변경된 것을 알아내서 
    어떤 변경사항도 실행취소(undo)할 수 있게 하기 때문이다.
  
동일한 작업을 많은 다른 제품([subversion](https://subversion.apache.org) 혹은 [mercurial](http://mercurial.selenic.com))과 웹사이트 서비스(like [gitlab](https://about.gitlab.com) and [bitbucket](https://bitbucket.org))로 수행할 수 있다.
Git이 GitHub와 함께 혹은 GitHub가 Git과 연결되어 함께 사용될 때 가장 유용해서 Git에 속한 기능과 GitHub에 속한 기능을 정확히 구별하는 것은 무의미하다.
하지만, 저자는 생각에는 Git + GitHub 조합이 가장 사용자 친화적 시스템이라고 본다 (특히 신규 개발자에게 그렇다). 대중성으로 인해 가능한 모든 질문 혹은 문제가 StackOverflow에 올려졌다는 것 때문만은 아니다.

그렇다고 Git이 배우기 쉽다는 것을 의미하지는 않는다.
Git과 첫 조우는 좌절을 줄 수도 있고, 이상한 용어와 그다지 도움이 되지 않는 오류 메시지에 저주를 퍼붓는다. 다행스럽게도 인터넷에 많은 사용지침서가 나와 있다.
(상당한 정보를 제공하지만 무엇을 수행할 수 있고 왜 관심을 가져야 하는 이유에 대해서는 거의 안내정보가 나와 있지 않아서) 그다지 잘 작성되어 있지는 않지만, 조금 실습하면 Git을 확실히 통달할 수 있다. 포기하지 마라! 인내를 갖고 전진하면, 코드 협업의 초강력 힘의 비밀을 해제할 것이다.

## RStudio, Git, GitHub {#git-rstudio}

RStudio는 일상적인 Git 사용을 더 쉽게 했다.
Git 기능을 활용하는 하도록 프로젝트를 설정하면, 새로운 창(pane)과 툴바 아이콘이 생긴다.
가장 자주 사용되는 Git 명령어로 바로가는 단축키 기능을 제공한다.
하지만, 150+ Git 명령어 일부만 RStudio에서 사용할 수 있기 때문에, __쉘(shell)__(명령라인 인터페이스 혹은 콘솔로도 알려짐)로
Git을 사용하는 방법에 친숙해질 필요가 있다. 쉘에서 Git 사용에 친숙해질 필요가 있는데 이유는 막히게 되면 Git 명령어를 통해서 해결책을 강구해야될 때가 많기 때문이다.

RStudio로부터 쉘에 접속하는 가장 쉬운 방법은 `Tools > Shell` 메뉴를 클릭한다.
이 방법으로 프로젝트 루트 디렉토리에 신규 쉘을 열게 된다.
(주의: 윈도우에서는 상기 방법을 통해 리눅스 표준쉘, _배쉬(bash)_ 쉘을 열게 되는데, 보통 `cmd.exe` 쉘과는 약간 다르게 행동하니 주의한다.)

이전에 쉘을 전혀 사용하지 않았다면 걱정할 필요는 없다. 왜냐하면 R 을 사용하는 것과 매우 유사하다.
주된 차이점은 함수를 사용하는 대신에 명령어(command)를 호출하는데, 약간 다른 구문을 갖는다.
예를 들어, R에서 `f(x, y = 1)`처럼 함수를 작성하는 반면에, 쉘에서 `f x --y=1` 혹은 `f x -y1` 방식으로 작성한다. 또한 쉘 명령어는 R 함수보다 심지어 덜 정규성을 갖지만, 다행스럽게도 일부와 친숙해지면 된다. 이번장에서 Git 명령어 실행을 제외하고 쉘로 그다지 많은 것을 수행하지 않을 것이다. 하지만, 가장 중요한 쉘 명령어 3개를 배워두는 것이 좋다:


* `pwd`: 작업 디렉토리를 출력한다. 현재 위치한 디렉토리를 알려준다.
* `cd <name>`: 디렉토리를 변경한다. `cd ..` 명령어를 사용해서 상위 디렉토리로 이동한다.
* `ls`: 파일 목록을 출력한다. 현재 디렉토리에 있는 모든 파일을 보여준다.

쉘을 이전에 결코 사용하지 않았다면, [Terminus](http://web.mit.edu/mprat/Public/web/Terminus/Web/main.html)를 실행해 보는 것을 추천한다. 쉘 기초사항을 즐겁게 배울 수 있다. 
필립 궈(Philip Guo) [기초 유닉스 명령어 사용지침](http://pgbovine.net/command-line-tutorial.htm) 동영상 감상과, <http://www.ee.surrey.ac.uk/Teaching/Unix/unix1.html>,  <https://p1k3.com/userland-book/> 웹사이트 방문도 저자는 추천한다. 


## 초기 환경설정 {#git-init}

Git 혹은 GitHub을 전에 결코 사용한 적이 없다면, Git을 설치하고 GitHub 계정을 생성해서 시작해보라.
그리고 나서 Git과 GitHub을 연결시킨다:


1.  Git 설치:

    * 윈도우즈: <http://git-scm.com/download/win>.
    * 맥 OS X: <http://git-scm.com/download/mac>.
    * 데비안/우분투: `sudo apt-get install git-core`.
    * 다른 리눅스 배포판: <http://git-scm.com/download/linux>.

1.  Git에 성함과 전자우편주소를 알려준다. 매번 커밋(commit)할때마다 라벨 역할을 한다.
    그래서 다른 개발자와 협업할 때, 누가 어떤 변경을 했는지 명확히 할 수 있다.
    쉘에서 다음 명령어를 실행한다:

    ```bash
    git config --global user.name "YOUR FULL NAME"
    git config --global user.email "YOUR EMAIL ADDRESS"
    ```

    (`git config --global --list` 명령어를 입력해서 올바르게 설정했는지 점검할 수 있다.)

1.  GitHub, <https://github.com> 에 계정을 생성한다 (무료사용도 좋다).
    상기 적용한 동일한 전자우편을 사용한다.
    
1.  필요하다면, SSH 키를 생성한다. SSH키를 사용해서 비밀번호 없이도 안전하게 웹사이트와 
    의사소통을 가능케 한다. SSH 키는 두 부분으로 구성된다: 개인키, 공개키.
    공개키를 갖는 사람이 안전하게 데이터를 암호화할 수 있는데,
    상응하는 비밀키를 갖고 있는 사람만 암호화된 데이터를 해독할 수 있다.
    
    다음 명령어를 실행해서 SSH 키 짝을 이미 갖고 있는지 점검할 수 있다:


    ```{r, eval = FALSE}
    file.exists("~/.ssh/id_rsa.pub")
    ```

    만약 상기 실행결과 `FALSE`가 반환되면, 신규 키를 생성할 필요가 있다.
    [GitHub 안내지침](https://help.github.com/articles/generating-ssh-keys)을 따르거나,
    RStudio를 사용할 수도 있다. RStudio 개인설정(Preference)으로 들어가서,
    Git/SVN 창을 선택하고, "Create RSA key..."을 클릭한다:
    

    ```{r, echo = FALSE}
    bookdown::embed_png("screenshots/git-config-2.png", dpi = 220)
    ```
    
1.  GitHub에 SSH 공캐키를 전달한다: <https://github.com/settings/ssh>.
    키를 찾는 가장 쉬운 방법은 RStudio Git/SVN 개인설정창에서 "View public key"를 클릭하는 것이다.

## 로컬 Git 저장소 생성하기 {#git-init}

Git을 설치하고 환경설정을 했기 때문에, 이제부터 사용할 수 있다!
팩키지 작성에 GitHub을 사용하려면, 먼저 줄여서 __repo__라고 부르는 로컬 저장소(repository)를 초기화한다. 초기화되면, `.git` 디렉토리가 생성되는데 환경설정 파일과 코드 변경내역을 기록하는 데이터베이스가 그곳에 저장된다. 신규 저장소는 개발자 본인 컴퓨터에만 존재하게 된다; 곧 다른 개발자와 저장소를 공유하는 방법을 학습할 것이다.

신규 저장소를 생성하기 위해서:


  * RStudio에서 `project options`로 들어가서, Git/SVN 창을 클릭한다.
    "버젼제어시스템(Version control system)"을 "None"에서 "Git"로 변경한다:
    
    ```{r, echo = FALSE}
    bookdown::embed_png("screenshots/git-proj-config.png", dpi = 220)
    ```
    
    그러면 RStudio를 제시작하라는 메시지가 뜬다.
    

  * 쉘에서, `git init`을 실행한다. RStudio를 재시작하고 팩키지를 작성한 팩키지를 다시 연다.
  

Git이 초기화되면, 신규 컴포넌트 두개를 볼 수 있다:

  * 우측 상단에 __Git 창(pane)__에서 무슨 파일이 변경되었는지 알 수 있고,
    가장 중요한 Git 명령어 버튼도 포함돼 있다:
  
    ```{r, echo = FALSE}
    bookdown::embed_png("screenshots/git-pane.png", dpi = 220)
    ```

  * 툴바에서 찾을 수 있는 __Git 드롭다운(dropdown)__는 현재 파일에 적용할 수 있는
    Git과 GitHub 명령어가 포함되어 있다:
    
    ```{r, echo = FALSE}
    bookdown::embed_png("screenshots/git-dropdown.png", dpi = 220)
    ```

## 변경된 사항 살펴보기 {#git-status}

첫번째 Git 사용 장점은 개발하면서 만든 변경사항을 쉽게 볼 수 있다는 것이다.
우연히 키보드 단축키를 잘못 눌러서 코드에 길 잃은 문자를 코드에 넣었을 때, 저자는 이 기능이 정말 도움이 된다고 본다. 
RStudio Git 창에는 추가되고, 변경되고, 삭제된 모든 파일 목록이 나와 있다.
각 아이콘이 변경된 내역을 기술한다:

* `r bookdown::embed_png("screenshots/git-modified.png", dpi = 220)`, 
  __Modified__. 파일 내용이 변경되었다.

* `r bookdown::embed_png("screenshots/git-unknown.png", dpi = 220)`, 
  __Untracked__. Git 시스템이 이전에 본적이 없는 신규 파일이 추가되었다.

* `r bookdown::embed_png("screenshots/git-deleted.png", dpi = 220)`, 
  __Deleted__. 파일이 삭제되었다.


"diff", `r bookdown::embed_png("screenshots/git-diff.png", dpi = 220)` 명령어로
변경사항에 대한 좀더 상세한 내역을 볼 수 있다. 신규 창을 열어 구체적인 차이(**diff**erences)를 보여준다:

```{r, echo = FALSE}
bookdown::embed_png("screenshots/git-diff-window.png", dpi = 220)
```

배경색을 통해서 텍스트가 추가(녹색)되었는지 삭제(적색)되었는지 알 수 있다.
(만약 색맹이라면, 가장 왼쪽에 두 칼럼에 행번호로 알 수 있다: 첫번째 칼럼 숫자는 이전 버젼, 두번째 칼럼 숫자는 신규 버젼을 나타낸다.)
변경사항 위아래 코드 회색줄은 추가적인 내용을 전달한다.

쉘에서, `git status` 명령어를 사용해서 전반적인 변경사항을 확인할 수 있고,
`git diff`를 사용해서 차이분에 대한 자세한 사항을 볼 수도 있다.

## 변경사항 기록 {#git-commit}

Git에서 작업 기본 단위는 __커밋(commit)__이다.
커밋은 특정 시점에 작성한 코드에 대한 짧은 묘사정보(스냅샷, Snapshot)를 기록한다.
Git 커밋을 사용하는 것은 등반할 때 앵커와 기타 보호장구를 사용하는 것과 같다.
만약 위험한 바위를 가로지를 때, 추락하게 되면 잡아줄 보호장치가 확실히 필요할 것이다.
커밋이 유사한 역할을 한다: 만약 실수를 하게 되면, 이전 커밋 이후로 추락되지 않게 된다.
커밋이 없는 코딩은 도구 없이 하는 (암벽) 등반같다: 
단시간에 훨씬 더 빨리 이동할 수 있지만, 장기적으로 보면 비극적 실패 가능성도 높다!
암벽등반 보호장구처럼, 커밋을 사용할 때 신중히 판단해야 된다.
너무 자주 커밋하게 되면 진행을 더디게 한다; 불확실하고 위험한 영역에 있을 때는 커밋을 더 많이 사용하라. 커밋은 다른 사람에게도 도움이 된다. 왜냐하면, 목적지 뿐만 아니라 여행경로도 볼 수 있기 때문이다.

매번 커밋할 때마다 5가지 주요한 구성요소가 있다:

* 유일무이한 식별자, SHA라고 불림 (secure hash algorithm의 약자로 보안 해쉬 알고리즘).

* 무슨 파일이 추가, 변경, 삭제되었는지 기술하는 변경집합(changeset).

* 사람이 읽을 수 있는 커밋 메시지.

* 부모 커밋, 해당 커밋 이전 커밋. (이 규칙에는 예외가 두가지 있다:
  최초 커밋은 부모가 없고, 나중에 학습할 병합(merge)은 부모가 둘이다.)

* 저자(author)

두 단계로 나누어서 커밋을 생성한다:

1.  __준비(staging)__ 단계에서, 다음번 커밋에 어떤 변경사항이 포함되어야 하는지 Git에게 일러준다.


1. __커밋(commit)__ 단계에서, 준비된 파일을 메시지로 변경사항을 기술하고 커밋한다.

RStudio에서, 준비(staging)와 커밋(commit)은 동일 장소에서 수행된다.
`r bookdown::embed_png("screenshots/git-commit.png", dpi = 220)`을 클릭하거나, Ctrl + Alt + m 단축키를 누르면 커밋 윈도우가 나온다.

```{r, echo = FALSE}
bookdown::embed_png("screenshots/git-commit-window.png", dpi = 220)
```

커밋 윈도우는 창(pane) 세개로 구성된다:

* 좌측 상단 창(pane)에 현재 상태정보가 있는데 RStudio 윈도우 Git 창(pane)에 있는 것과 같다.

* 아래 창(pane)에는 현재 선택된 파일 차이(diff) 정보가 나와 있다.

* 우측 상단 창(pane)에는 커밋할 때 변경 내용을 요약해서 사람이 읽을 수 있는 
  메시지를 입력하는 곳이다. 좀더 자세한 사항에 대해서 곧 다시 다룰 예정이다.
  
(그렇다, `r bookdown::embed_png("screenshots/git-diff.png", dpi = 220)` 를 클릭할 때,
나타나는 창과 정확하게 동일하다!)  

신규 커밋을 생성하기 위해서:


1.  __변경사항을 저장한다__.

1.  `r bookdown::embed_png("screenshots/git-commit.png", dpi = 220)`을 클릭하거나 
    `Ctrl + Alt + m` 단축키를 눌러 __커밋 윈도우를 연다__.

1.  __파일을 선택한다__. 포함시킬 파일을 준비(staging)시키려면, 확인란(check box)를 선택한다.
    모든 파일을 준비(staging)시키려면, Ctrl/Cmd + A 단축키를 누르고 나서, 
    `r bookdown::embed_png("screenshots/git-stage.png", dpi = 220)`을 클릭한다.

    각 파일을 준비시킬 때, 상태가 변경되는 것을 알아챘을 것이다.
    아이콘이 오른쪽(준비되지 않은 상태, unstaged)에서 왼쪽(준비된 상태, staged)으로 
    칼럼을 변경한다. 그리고 다음 신규 아이콘 두개중 하나를 볼 수도 있다.
    

      * 추가(added): `r bookdown::embed_png("screenshots/git-added.png", dpi = 220)`: 
        추적되지 않은 파일을 준비상태로 올린 후에, 개발자가 신규 파일을 저장소에 추가하고자 
        한다는 것을 Git 시스템이 이제는 알고 있다.
      
      * 이름 변경(renamed): `r bookdown::embed_png("screenshots/git-renamed.png", dpi = 220)`:
        만약 파일 이름을 변경하면, 처음에 Git은 파일을 삭제하고 추가한 것으로 본다.
        두 변경사항을 준비단계로 올리게 되면, Git이 이름변경을 인지한다.
    
    종종, 두 칼럼에 걸친 상태 아이콘을 보게 된다, 예를 들어, `r bookdown::embed_png("screenshots/git-modified-staged.png", dpi = 220)`.
    동일한 파일이 준비상태기도 하고 준비되지 않은 상태이고도 하다는 것을 의미한다.
    일부 변경을 하고 준비상태로 올려놓은 다음에, 일부 변경을 할 때 이런 경우가 발생한다.
    준비상태 체크박스를 클릭하면 신규 변경사항이 준비상태로 올라가고,
    다시 체크박스를 클릭하면, 양쪽 변경사항 모두 준비상태에서 풀려 내려온다.
    

1.  위와 마찬가지로 __파일을 준비상태로 올린다__.

1.  __커밋 메시지를 작성한다__ (우측 상단 창), 메시지에는 변경사항을 기술한다.
    커밋 메시지 첫번째 행을 제목란으로 불리는데 간결해야 된다 (문자 50개 이하).
    복잡한 커밋에는, 빈줄을 넣고 나서 문단 혹은 글머리표를 통해 상세한 내용을 적는다.
    누군가에게 무엇을 수행하라고 지시하는 것처럼, 명령조로 메시지를 작성하라:
    "이 버그를 고쳤다(fixed this bug)" 혹은 
    "이 버그는 고쳐졌다(this bug was fixed)"가 아니라 "이 버그를 고쳐라(fix this bug)".

1.  __커밋(Commit)을 클릭한다__.

파일을 준비단계로 올리는 것은 쉘에서 다소 복잡하다.
`git add`를 사용해서 신규, 변경된 파일을 준비단계로 올린다. `git rm`를 사용해서 준비단계에 올라간 파일을 삭제한다. 커밋을 생성하려면, `git commit -m <message>` 명령어를 사용한다.

## 커밋 모범사례 {#commit-best-practices}

이상적인 것은 각 커밋은 _최소(minimal)_지만 _완결(complete)_되야 된다:


* __최소(Minimal)__: 한 커밋에는 단일문제에 연관된 변경사항만 담겨져야 된다.
  이렇게 함으로써 한번에 커밋된 것을 이해하고 간단한 메시지로 기술하기도 더 쉽게 된다.
  만약 새로운 문제를 발견한다면, 구별되는 별도 커밋을 수행해야 된다.

* __완결(Complete)__: 해결하려고 주장하는 문제를 한 커밋으로 해결한다.
  만약 버그를 고쳤다고 생각하면, 커밋은 단위 테스트를 포함해서 주장이 맞다는 사실을 확인해야 한다.

각 커밋 메시지는 다음과 같아야 된다:

* __간략하지만, 연상시켜야 된다__. 한눈에, 커밋이 무엇을 했는지 알 수 있어야 된다.
  하지만, 충분히 구체적인 사항이 녹아져서 무엇이 수행되었는지 기억할 (그리고 이해할) 수
  있어야 된다.

* __대상(what)이 아니라 이유(why)를 기술하라__. 커밋과 연관된 차이(diff)를 항상 불러올 수 
  있기 때문에, 메시지에 정확하게 무엇이 변경되었는지 적을 필요는 없다.
  대신에, 변경에 대한 이유에 집중한 높은 수준의 요약정보를 제공해야 된다.

만약 상기 사항을 잘 수행한다면:


* 다른 개발자와 공동작업하기가 더 쉽다. 예를 들어, 만약 두 사람이 같은 곳에서 같은 파일을
  변경했다면, 충돌을 해결하기 더 쉽다. 왜냐하면, 커밋 단위가 작고, 
  각 변경에 대한 사유가 명확하기 때문이다.

* 프로젝트 신규 참가자도 커밋 로그를 읽으면 지나온 이력을 더 쉽게 이해할 수 있다.

* 개발이력을 따라 특정 지점에서 작성한 팩키지를 적재하고 실행할 수 있다.
  [bisectr](https://github.com/wch/bisectr)같은 도구를 함께 사용하면 매우 유용하다.
  이진 검색을 사용해서 신속하게 버그가 주입된 커밋을 색출할 수 있다.
  
* 언제 버그가 주입되었는지 정확하게 알 수 있게 되면, 
  무엇을 수행하면 되는지 (그리고 왜!) 쉽게 이해할 수 있다.

어떤 누구도 개발하고 있는 저장소를 살펴보지 않을 것이기 때문에, 좋은 커밋 메시지를 작성하는 것이 노력대비 가치가 없을 것으로 생각할지도 모른다.
하지만, 매우 중요한 공동작업자가 있다는 것을 명심하라: 미래의 당신!
만약 지금 커밋 메시지에 약간 공을 드리면, 버그에 대한 부검을 한다면 그리고 부검을 할 필요가 있다면
미래의 당신이 매우 고마워할 것이다.

이러한 지시사항은 단지 열망을 담고 있다고 기억하기 바란다.
이러한 것이 방해가 되서는 않된다.
만약 여러분이 저자 저장소 커밋 이력을 본다면, 많은 부분은 그다지 훌륭하지 못하다는 것을 알아챘을 것이다. 특히, __여전히__ 어떻해서든지 버그를 고쳐보려고 하지 못할 정도로 좌절이 시작될 때 더욱 그렇다. 상기 안내지침을 따르려고 노력하고, 하나의 완전한 커밋보다는 다수 불완전한 커밋이 더 낫다.

## Ignoring files {#git-ignore}

Often, there are files that you don't want to include in the repository. They might be transient (like LaTex or C build artefacts), very large, or generated on demand. Rather than carefully _not_ staging them each time, you should instead add them to `.gitignore`. This will prevent them from ever being added. The easiest way to do this is to right-click on the file in the Git pane and select `Ignore`:

```{r, echo = FALSE}
bookdown::embed_png("screenshots/git-ignore.png", dpi = 220)
```

If you want to ignore multiple files, you can use a wildcard "glob" like `*.png`. To learn more about the options, see [ignoring files](http://git-scm.com/book/ch2-2.html#Ignoring-Files) in Pro-Git.

Some developers never commit derived files, files that can be generated automatically. For an R package this would mean ignoring the files in the `NAMESPACE` and `man/` directories because they're generated from comments. From a practical pespective, it's better to commit these files: R packages have no way to generate `.Rd` files on installation so ignoring derived files means that users who install your package from GitHub will have no documentation.

## Undo a mistake {#git-undo}

The best thing about using commits is that you can undo mistakes. RStudio makes it particularly easy:

*   To undo the changes you've just made, right click on the file in the Git 
    pane and select "revert". This will roll any changes back to the previous 
    commit. Beware: you can't undo this operation!
  
    You can also undo changes to just part of a file in the diff window. Look 
    for a __discard chunk__ button above the block of changes that you want to 
    undo:`r bookdown::embed_png("screenshots/git-chunk.png", dpi = 220)`. You 
    can also discard changes to individual lines or selected text.

*   If you committed changes too early, you can modify the previous commit by 
    staging the extra changes. Before you click commit, select 
    `r bookdown::embed_png("screenshots/git-commit-amend.png", dpi = 220)`. 
    (Don't do this if you've pushed the previous commit to GitHub - you're
    effectively rewriting history, which should be done with care when you're 
    doing it in public.)
  
If you didn't catch the mistake right away, you'll need to look backwards in history and find out where it occurred:

1.  Open the history window by clicking
    `r bookdown::embed_png("screenshots/git-history.png", dpi = 220)` in the 
    Git pane.
    
    ```{r, echo = FALSE}
    bookdown::embed_png("screenshots/git-history-window.png", dpi = 220)
    ```

    The history window is divided into two parts. The top part lists every
    commit to your repo. The bottom part shows you the commit:
    the SHA (the unique id), the author, the date, the parent and 
    the changes in the commit.
     
1.  Navigate back in time until you find the commit where the mistake occurred.
    Write down the parent SHA: that's the commit that occurred before the 
    mistake so it will be good.
    
Now you can use that SHA in the shell:

*   See what the file looked like in the past so you can copy-and-paste the old
    code:
    
    ```bash
    git show <SHA> <filename>
    ```

*   Or copy the version from the past back in to the present:

    ```bash
    git checkout <SHA> <filename>
    ```
    
In both cases you'll need to finish by staging and committing the files.

(It's also possible to use Git as if you went back in time and prevented the mistake from happening in the first place. This is an advanced technique called __rebasing history__. As you might imagine, going back in time to change the past can have a profound impact on the present. It can be useful, but it needs to be done with extreme care.)

If you're still stuck, try <http://sethrobertson.github.io/GitFixUm/fixup.html> or <http://justinhileman.info/article/git-pretty/>. They give step-by-step approaches to fixing many common (and not so common!) problems.

## Synchronising with GitHub {#github-init}

So far we've only been working locally, using commits to track the progress of a project and to provide safe checkpoints. However, Git really shines when you start sharing your code with others with [GitHub](http://github.com). While there are other choices, I recommend GitHub because it is free for open source projects, it has all the features you'll need, and is a popular choice in the R world. 

To publish, or __push__, your code to GitHub:

1.  Create a new repo on GitHub: <https://github.com/new>. Give it the same
    name as your package, and include the package title as the repo
    description. Leave all the other options as is, then click Submit.

1.  Open a shell, then follow the instructions on the new repo page. 
    They'll look something like this:

    ```bash
    git remote add origin git@github.com:hadley/r-pkgs.git
    git push -u origin master
    ```
    
    The first line tells Git that your local repo has a remote version on 
    GitHub, and calls it "origin". The second line pushes all your current 
    work to that repo.

Now let's make a commit and verify that the remote repo updates:

1.  Modify `DESCRIPTION` to add `URL` and `BugReports` fields that link 
    to your new GitHub site. For example, dplyr has:

    ```yaml
    URL: http://github.com/hadley/dplyr
    BugReports: http://github.com/hadley/dplyr/issues
    ```

1.  Save the file and commit (with the message "Updating DESCRIPTION to add 
    links to GitHub site").
    
1.  __Push__ your changes to GitHub by clicking 
    `r bookdown::embed_png("screenshots/git-push.png", dpi = 220)`. (This is 
    the same as running `git push` in the shell). 
    
1.  Go to your GitHub page and look at the `DESCRIPTION`.

Usually, each push will include multiple commits. This is because you push much less often than you commit. How often you push versus commit is completely up to you, but pushing code means publishing code. So strive to push code that works. 

To ensure your code is clean, I recommend always running `R CMD check` before you push (a topic you'll learn about in the chapter on [automated checking](#check)). If you want to publish code that doesn't work (yet), I recommend using a branch, as you'll learn about below in [branching](#git-branch).

Once you've connected your repo to GitHub, the Git pane will show you how many commits you have locally that are not on GitHub: `r bookdown::embed_png("screenshots/git-local-commits.png", dpi = 220)`. This message indicates that I have 1 commit locally (my branch) that is not on GitHub ("origin/master").

## Benefits of using GitHub {#github-benefit}

1.  You get a decent website. The GitHub page for your project, e.g. 
    <https://github.com/hadley/testthat> (the GitHub repo for testthat), lists 
    all the files and directories in your package. `.R` files will be formatted 
    with syntax highlighting, and `.md`/`.Rmd` files will be rendered as HTML.
    And, if you include a `README.md` file in the top-level directory, it will 
    be displayed on the homepage. You'll learn more about the benefits of 
    creating this file in [README.md](#readme). 

1.  It makes it easy for anyone to install your package (and to benefit from your 
    hard work):

    ```r
    devtools::install_github("<your_username>/<your_package>")
    ``` 

1.  You can track the history of the project in the commit view, e.g. 
    <https://github.com/hadley/testthat/commits/master>. When I'm working on 
    a package with others, I often keep this page open so I can see what 
    they're working on.  Individual commits show the same information that you 
    see in the commit/diff window in RStudio.

1.  It's easy to see the history of a file. If you navigate to a file and click 
    __History__, you'll see every commit that affected that file. Another useful 
    view is __Blame__; it shows the last change made to each line of code, who 
    made the change, and the commit the change belongs to. This is tremendously 
    helpful when you're tracking down a bug. 
    
    You can jump directly to these pages from RStudio with the Git dropdown in 
    the main toolbar: 
    
    ```{r, echo = FALSE}
    bookdown::embed_png("screenshots/git-dropdown.png", dpi = 220)
    ```

1.  You can comment on commits. To comment on the commit as a whole, use the 
    comment box at the bottom of the page. To comment on an individual line,
    click the plus sign that appears when you mouse over a line number,
    `r bookdown::embed_png("screenshots/github-comment-line.png", dpi = 220)`. 
    This is a great way to let your collaborators know if you see a mistake or 
    have a question. It's better than email because it's public so anyone 
    working on the repo (both present and future) can see the conversation.

## Working with others {#git-pull}

You use __push__ to send your changes to GitHub. If you're working with others, they also push their changes to GitHub. But, to see their changes locally you'll need to __pull__ their changes from GitHub. In fact, to make sure everyone is in sync, Git will only let you push to a repo if you've retrieved the most recent version with a pull.

When you pull, Git first downloads (__fetches__) all of the changes and then __merges__ them with the changes that you've made. A merge is a commit with two parents. It takes two different lines of development and combines them into a single result. In many cases, Git can do this automatically: for example, when changes are made to different files, or to different parts of the same file. However, if changes are made to the same place in a file, you'll need to resolve the __merge conflict__ yourself.

In RStudio, you'll discover that you have merge conflict when:

* A pull fails with an error.

* In the Git pane, you see a status like
  `r bookdown::embed_png("screenshots/git-commit-conflict.png", dpi = 220)`

RStudio currently doesn't provide any tools to help with merge conflicts, so you'll need to use the command line. I recommend starting by setting your merge conflict "style" to `diff3`. The `diff3` style shows three things when you get a merge conflict: your local changes, the original file and the remote changes. The default style is `diff2`, which only shows your changes and the remote changes. This generally makes it harder to figure out what's happened. 

* If you've encountered your first merge conflict, do the following:

    ```bash
    # Abort this merge
    git merge --abort
    # Set the conflict style
    git config --global merge.conflictstyle diff3
    # Re-try the merge
    git pull
    ```
    
* If you're not in the middle of a merge conflict, just run 

    ```bash
    git config --global merge.conflictstyle diff3
    ```

To resolve a merge conflict, you need to open every file with the status `r bookdown::embed_png("screenshots/git-commit-conflict.png", dpi = 220)`. In each file, you'll find a conflict marker that looks like this:

```
<<<<<<< HEAD

||||||| merged common ancestors

=======

>>>>>>> remote
```

This shows all three versions of the conflicting code:

* At the top, your local code.

* In the middle, the code from the last commit before the split between the
  two lines of development (This is missing in the default conflict 
  style, so if you don't see it, follow the instructions above).

* At the bottom, the remote code that you pulled down from GitHub.

You need to work through each conflict and decide either which version is better, or how to combine both versions. Then, before you stage the file, make sure you've deleted all the conflict markers. Once you've fixed all conflicts, make a new commit and push to GitHub.

A couple of pointers when fixing text generated by roxygen:

* Don't fix problems in `man/*.Rd` files. Instead, resolve any conflicts in 
  the underlying roxygen comments and re-document the package.
   
* Merge conflicts in the `NAMESPACE` file will prevent you from re-loading or 
  re-documenting a package. Resolve them enough so that the package 
  can be loaded, then re-document to generate a clean and correct `NAMESPACE`.

Handling merge conflicts is one of the trickier parts of Git. You may need to read a few tutorials before you get the hang of it. Google and StackOverflow are great resources. If you get terribly confused, you can always abort the merge and try again by running `git merge --abort` then `git pull`.

## Issues {#github-issues}

Every GitHub repo comes with a page for tracking issues. Use it! If you encounter a bug while working on another project, jot a note down on the issues page. When you have a smaller project, don't worry too much about milestones, tags and assigning issues to specific people. Those are more useful once you get over a page of issues (>50). Once you get to that point, read the GitHub guide on issues: <https://guides.github.com/features/issues/>.

A useful technique is closing issues from a commit message. Just put `Closes #<issue number>` somewhere in your commit message and GitHub will close the issue for you when you next push. The best thing about closing issues this way is that it makes a link from the issue to the commit. This is useful if you ever have to come back to the bug and want to see exactly what you did to fix it. You can also link to issues without closing them; just refer to `#<issue number>`.

As you'll learn about in [NEWS.md](#news), it's a good idea to add a bullet to `NEWS.md` whenever you close an issue. The bullet point should describe the issue in terms that users will understand, as opposed to the commit message which is written for developers.

## Branches {#git-branch}

Sometimes you want to make big changes to your code without having to disturb your main stream of development. Maybe you want to break it up into multiple simple commits so you can easily track what you're doing. Maybe you're not sure what you've done is the best approach and you want someone else to review your code. Or, maybe you want to try something experimental (you can merge it back only if the experiment succeeds). Branches and pull requests provide powerful tools to handle these situations.

Although you haven't realised it, you're already using branches. The default branch is called __master__; it's where you've been saving your commits. If you synchronise your code to GitHub you'll also have a branch called __origin/master__: it's a local copy of all the commits on GitHub, which gets synchronised when you pull. `git pull` does two things:

1.  `git fetch origin master` to update the local `origin/master` branch with
    the latest commits from GitHub.
  
1.  `git merge orgin/master` to combine the remote changes with your changes.

It's useful to create your own branches when you want to (temporarily) break away from the main stream of development. You can create a new branch with `git checkout -b <branch-name>`. Names should be in lower case letters and numbers, with `-` used to separate words. 
  
Switch between branches with `git checkout <branch-name>`. For example, to return to the main line of development use `git checkout master`. You can also use the branch switcher at the top right of the Git pane:
  
```{r, echo = FALSE}
bookdown::embed_png("screenshots/git-branch.png", dpi = 220)
```

If you've forgotten the name of your branch in the shell, you can use `git branch` to list all existing branches. 

If you try to synchronise this branch to GitHub from inside RStudio, you'll notice that push and pull are disabled: `r bookdown::embed_png("screenshots/git-no-remote.png", dpi = 220)`. To enable them, you'll need to first tell Git that your local branch has a remote equivalent:

```bash
git push --set-upstream origin <branch-name>
```

After you've done that once, you can use the pull and push buttons as usual.

If you've been working on a branch for a while, other work might have been going on in the master branch. To integrate that work into your branch, run `git merge master`. You will need to resolve any merge conflicts (see above). It's best to do this fairly frequently - the less your branch diverges from the master, the easier it will be to merge.

Once you're done working on a branch, merge it back into the master, then delete the branch:

```bash
git checkout master
git merge <branch-name>
git branch -d <branch-name>
```

(Git won't let you delete a branch unless you've merged it back into the master branch. If you do want to abandon a branch without merging it, you'll need to force delete with `-D` instead of `-d`. If you accidentally delete a branch, don't panic. It's usually possible to get it back. See the advice about undoing mistakes).

## Making a pull request {#git-pullreq}

A pull request is a tool for proposing and discussing changes before merging them into a repo. The most common use for a pull request is to contribute to someone else's code: it's the easiest way to propose changes to code that you don't control. 

Below, you'll learn about pull requests to make changes to your own code. This may seem a bit pointless because you don't _need_ them, as you can directly modify your code. But pull requests are surprisingly useful because they allow you to get feedback on proposed changes. We use them frequently at RStudio to get feedback before merging major changes.

GitHub has some good documentation on using pull requests: <https://help.github.com/articles/using-pull-requests/>. In this chapter, I'll focus on the basics you need to know to use pull requests effectively, and show you how they fit in with the Git commands you've learned so far.

To create a pull request, you create a branch, commit code, then push the branch to GitHub. When you next go to the GitHub website you'll see a header that invites you to submit a pull request. You can also do it by:

1.  Switching branches: 

    ```{r, echo = FALSE}
    bookdown::embed_png("screenshots/github-branches.png", dpi = 220)
    ```

1.  Clicking `r bookdown::embed_png("screenshots/pr-create.png", dpi = 220)`

This will create a page that looks like this:

```{r, echo = FALSE}
bookdown::embed_png("screenshots/pr.png", dpi = 220)
```

This pull request, which fixes a couple of small problems, is one that was submitted to this book's GitHub site.

There are three parts to a pull request:

* A __conversation__, 
  `r bookdown::embed_png("screenshots/pr-conversation.png", dpi = 220)`,
  where you can discuss the changes as a whole.
  
* The __commits__ view, 
  `r bookdown::embed_png("screenshots/pr-commits.png", dpi = 220)`,
  where you can see each individual commit.
  
* The __file changes__,
  `r bookdown::embed_png("screenshots/pr-changes.png", dpi = 220)`,
  where you see the overall diff of the commits, and you can comment
  on individual lines.

Once you're done discussing a pull request, you either choose to merge it or delete it. Merging it is equivalent to running `git merge <branchname>` from the shell; deleting is equivalent to `git branch -r <branchname>`.

## Submitting a pull request to another repo {#pr-make}

To submit a pull request to a repo that you don't own, you first need to create a copy of the repo that you can own, called a __fork__, and then clone that fork on your own computer:

1.  __Fork__ the original repo by going to the repo on GitHub and clicking
    `r bookdown::embed_png("screenshots/github-fork.png", dpi = 220)`. 
    This creates a copy of the repo that belongs to you. 

1.  __Clone__ the forked repo to create a local copy of the remote repo. 
    It's possible to do this within RStudio (using "Create New Project" from 
    "Version Control") but I think it's easier to do it from the shell:
    
    ```bash
    git clone git@github.com:<your-name>/<repo>.git
    cd <repo>
    ```

A fork is a _static_ copy of the repo: once you've created it, GitHub does nothing to keep it in sync with the upstream repo. This is a problem because while you're working on a pull request, changes might occur in the original repo. To keep the forked and the original repo in sync, start by telling your repo about the upstream repo:

```bash
git remote add upstream git@github.com:<original-name>/<repo>.git
git fetch upstream
```

Then you can merge changes from the upstream repo to your local copy:

```bash
git merge upstream/master
```

When working on a forked repo, I recommend that you don't work on the master branch. Because you're not really working on the main line of development for that repo, using your master branch makes things confusing. 

If you always create pull requests in branches, you can make it a little easier to keep your local repo in sync with the upstream repo by running:

```bash
git branch -u upstream/master   
```

Then you can update your local repo with the following code:

```bash
git checkout master
git pull
```

Changes may occur while you're working on the pull request, so remember to merge them into your branch with:

```bash
git checkout <my-branch>
git merge master
```

A pull request (PR) is a one-to-one mapping to a branch, so you can also use this technique to make updates based on the pull request discussion. Don't create a new pull request each time you make a change; instead you just need to push the branch that the PR is based on and the PR webpage will automatically update.

The diagram below illustrates the main steps of creating a pull request and updating the request as the upstream repo changes:

```{r, echo = FALSE}
bookdown::embed_png("diagrams/pull-request-process.png", dpi = 220)    
```

## Reviewing and accepting pull requests {#pr-accept}

As your package gets more popular, you're likely to receive pull requests. Receiving a pull request is fantastic. Someone not only cares about your package enough to use it, they've actually read the source code and made an improvement!

When you receive a pull request, I recommend reviewing it using the three step approach described by Sarah Sharp. I summarise the three phases below, but I highly recommend reading the full article at <http://sarah.thesharps.us/2014/09/01/the-gentle-art-of-patch-review/>:

1.  Is it a good idea? If you don't think the contribution is a good fit for 
    your project, it's polite to let the contributor know as quickly as 
    possible. Thank them for their work, and refocus them on a better area to 
    work on.
    
1.  Is the overall approach sound? At this point you want to focus on the big
    picture: have they modified the right functions in the right way? Avoid
    nitpicking minor style problems (that's the final phase); instead just 
    provide a pointer to your style preferences, e.g. 
    <http://r-pkgs.had.co.nz/style.html>.

1.  Is it polished? In the final review phase, make sure that the non-code
    parts of the PR are polished. Prompt the contributor to update the 
    documentation, point out spelling mistakes and suggest better wording.
    
    I recommend asking the contributor to include a bullet point in `NEWS.md`, 
    briefly describing the improvement and thanking themselves with their GitHub 
    username. More details to follow in  [post release](#post-release)).

After discussion is complete, you can incorporate the changes by clicking the merge button. If the button doesn't work, GitHub provides some instructions on how to do it from the command line. While you've seen all the pieces before, it's useful to read through this just so you understand what exactly is happening.

```bash
# Create a new branch, and sync it with the pull request
git checkout -b <branch> master
git pull https://github.com/<user>/<branch>.git patch-3

# Merge the changes into the main line of development
git checkout master
git merge --no-ff <branch>
# Resolve conflicts, stage and add.

# Sync your local changes with GitHub
git push origin master
```

## Learning more {#git-learning}

Git and GitHub are a rich and powerful set of tools, and there's no way this chapter has taught you everything you need to know. However, you should now have the basic knowledge to be effective, and you should be in a good position to learn more. Some good resources are:
  
* GitHub help, <https://help.github.com>, not only teaches you about
  GitHub, but also has good tutorials on many Git features.

* If you'd like to learn more about the details of Git, read 
  [Pro Git](http://git-scm.com/book/en/v2) by Scott Chacon and Ben Straub.

Finally, StackOverflow is a vital part of Git - when you have a problem that you don't know how to solve, StackOverflow should be your first resource. It's highly likely that someone has already had the same exact problem as you, and that there will be a variety of approaches and solutions to choose from.

[gh-issues]:https://guides.github.com/features/issues/
[gh-pr]: https://help.github.com/articles/using-pull-requests/
[gh-releases]: https://help.github.com/articles/about-releases/
