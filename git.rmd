---
title: Git and GitHub
layout: default
output: bookdown::html_chapter
---

# Git 와 GitHub {#git}

만약 소프트웨어 개발에 진지하게 임하려면, Git을 배울 필요가 있다.
Git은 _버젼제어시스템(version control system)_으로, 코드 변경사항을 추적하고 다른 개발자와 변경사항을 공유한다. Git이 [GitHub](http://github.com)와 조합되어 사용될 때 그 유용성은 배가된다. [GitHub](http://github.com)을 통해서 코드를 전세계 개발자와 공유하고 풀요청(pull request)와 이슈 추적을 통해 개선을 이어나간다. Git + GitHub 조합이 R 팩키지 개발자를 위한 가장 인기있는 버젼제어시스템이다. (GitHub에 올려진 수천개 R 패키지를 목도하라).


Git 과 GitHub 조합이 단지 R 팩키지에만 유용한 것이 아니라, 모든 소프트웨어 개발과 자료분석에도 일반적으로 유용하다. 이 책에서 Git 과 GitHub 포함했는데 이유는 팩키지 개발에 매우 유용하기 때문이다. 저자 등 뒤에서 신속하게 잘못된 것을 찾아내고 다른 개발자와 쉽게 협업이 가능하게 한다. Git 과 GitHub을 통하지 않고 더 생산성을 높이는 다른 방법은 없다. 

왜 Git + GitHub를 사용할까?


  * 팩키지 공유를 쉽게 만든다. 그리고, R 사용자는 다음 코드 두줄로 팩키지를 설치할 수 있다:
  

    ```{r, eval = FALSE}
    install.packages("devtools")
    devtools::install_github("username/packagename")
    ```
    
  * GitHub을 통해 작성한 팩키지에 대한 핵심사항만 담긴 웹사이트를 쉽게 생성할 수 있다.
    독자가 쉽게 코드를 탐색하고 (마크다운으로) 문서를 읽을 수도 있다.
    독자가 코드를 읽고 버그를 보고하고, GitHub 이슈를 통해 신규 기능을 제안할 수 있다.
    [GitHub issues][gh-issues]. 그리고 풀요청으로 작성한 코드에 기능향상을 제안할 수 있다.
  

  * 전자우편 혹은 드롭박스 폴더로 파일을 주고받으면서 누군가 코드를 협업해서 개발한 적이 있는가?
    두 개발자가 동일한 파일에 동시 작업하지 않고, 
    다른 개발자 변경사항을 덮어쓰기 해서 문제없이 하는데도 상당한 노력이 소요된다.
    Git가 있으면, 두 개발자 모두 편안하게 동시에 동일한 파일에 작업할 수 있다.
    Git가 변경사항을 자동으로 결합하거나, 모호한 부분과 충돌나는 것을 모두 보여준다.
  

  * 파일을 저장할 때 Cmd + S 대신에 `s`만 우연히 누른적이 있는가?
    추적하는데 몇분 걸리는 실수 혹은 버그를 우연히 만들어내는 것은 무척이나 쉽다.
    Git는 이러한 문제를 쉽게 탐지하기 한다. 왜냐하면 정확하게 변경된 것을 알아내서 
    어떤 변경사항도 실행취소(undo)할 수 있게 하기 때문이다.
  
동일한 작업을 많은 다른 제품([subversion](https://subversion.apache.org) 혹은 [mercurial](http://mercurial.selenic.com))과 웹사이트 서비스(like [gitlab](https://about.gitlab.com) and [bitbucket](https://bitbucket.org))로 수행할 수 있다.
Git이 GitHub와 함께 혹은 GitHub가 Git과 연결되어 함께 사용될 때 가장 유용해서 Git에 속한 기능과 GitHub에 속한 기능을 정확히 구별하는 것은 무의미하다.
하지만, 저자는 생각에는 Git + GitHub 조합이 가장 사용자 친화적 시스템이라고 본다 (특히 신규 개발자에게 그렇다). 대중성으로 인해 가능한 모든 질문 혹은 문제가 StackOverflow에 올려졌다는 것 때문만은 아니다.

그렇다고 Git이 배우기 쉽다는 것을 의미하지는 않는다.
Git과 첫 조우는 좌절을 줄 수도 있고, 이상한 용어와 그다지 도움이 되지 않는 오류 메시지에 저주를 퍼붓는다. 다행스럽게도 인터넷에 많은 사용지침서가 나와 있다.
(상당한 정보를 제공하지만 무엇을 수행할 수 있고 왜 관심을 가져야 하는 이유에 대해서는 거의 안내정보가 나와 있지 않아서) 그다지 잘 작성되어 있지는 않지만, 조금 실습하면 Git을 확실히 통달할 수 있다. 포기하지 마라! 인내를 갖고 전진하면, 코드 협업의 초강력 힘의 비밀을 해제할 것이다.

## RStudio, Git, GitHub {#git-rstudio}

RStudio는 일상적인 Git 사용을 더 쉽게 했다.
Git 기능을 활용하는 하도록 프로젝트를 설정하면, 새로운 창(pane)과 툴바 아이콘이 생긴다.
가장 자주 사용되는 Git 명령어로 바로가는 단축키 기능을 제공한다.
하지만, 150+ Git 명령어 일부만 RStudio에서 사용할 수 있기 때문에, __쉘(shell)__(명령라인 인터페이스 혹은 콘솔로도 알려짐)로
Git을 사용하는 방법에 친숙해질 필요가 있다. 쉘에서 Git 사용에 친숙해질 필요가 있는데 이유는 막히게 되면 Git 명령어를 통해서 해결책을 강구해야될 때가 많기 때문이다.

RStudio로부터 쉘에 접속하는 가장 쉬운 방법은 `Tools > Shell` 메뉴를 클릭한다.
이 방법으로 프로젝트 루트 디렉토리에 신규 쉘을 열게 된다.
(주의: 윈도우에서는 상기 방법을 통해 리눅스 표준쉘, _배쉬(bash)_ 쉘을 열게 되는데, 보통 `cmd.exe` 쉘과는 약간 다르게 행동하니 주의한다.)

이전에 쉘을 전혀 사용하지 않았다면 걱정할 필요는 없다. 왜냐하면 R 을 사용하는 것과 매우 유사하다.
주된 차이점은 함수를 사용하는 대신에 명령어(command)를 호출하는데, 약간 다른 구문을 갖는다.
예를 들어, R에서 `f(x, y = 1)`처럼 함수를 작성하는 반면에, 쉘에서 `f x --y=1` 혹은 `f x -y1` 방식으로 작성한다. 또한 쉘 명령어는 R 함수보다 심지어 덜 정규성을 갖지만, 다행스럽게도 일부와 친숙해지면 된다. 이번장에서 Git 명령어 실행을 제외하고 쉘로 그다지 많은 것을 수행하지 않을 것이다. 하지만, 가장 중요한 쉘 명령어 3개를 배워두는 것이 좋다:


* `pwd`: 작업 디렉토리를 출력한다. 현재 위치한 디렉토리를 알려준다.
* `cd <name>`: 디렉토리를 변경한다. `cd ..` 명령어를 사용해서 상위 디렉토리로 이동한다.
* `ls`: 파일 목록을 출력한다. 현재 디렉토리에 있는 모든 파일을 보여준다.

쉘을 이전에 결코 사용하지 않았다면, [Terminus](http://web.mit.edu/mprat/Public/web/Terminus/Web/main.html)를 실행해 보는 것을 추천한다. 쉘 기초사항을 즐겁게 배울 수 있다. 
필립 궈(Philip Guo) [기초 유닉스 명령어 사용지침](http://pgbovine.net/command-line-tutorial.htm) 동영상 감상과, <http://www.ee.surrey.ac.uk/Teaching/Unix/unix1.html>,  <https://p1k3.com/userland-book/> 웹사이트 방문도 저자는 추천한다. 


## 초기 환경설정 {#git-init}

Git 혹은 GitHub을 전에 결코 사용한 적이 없다면, Git을 설치하고 GitHub 계정을 생성해서 시작해보라.
그리고 나서 Git과 GitHub을 연결시킨다:


1.  Git 설치:

    * 윈도우즈: <http://git-scm.com/download/win>.
    * 맥 OS X: <http://git-scm.com/download/mac>.
    * 데비안/우분투: `sudo apt-get install git-core`.
    * 다른 리눅스 배포판: <http://git-scm.com/download/linux>.

1.  Git에 성함과 전자우편주소를 알려준다. 매번 커밋(commit)할때마다 라벨 역할을 한다.
    그래서 다른 개발자와 협업할 때, 누가 어떤 변경을 했는지 명확히 할 수 있다.
    쉘에서 다음 명령어를 실행한다:

    ```bash
    git config --global user.name "YOUR FULL NAME"
    git config --global user.email "YOUR EMAIL ADDRESS"
    ```

    (`git config --global --list` 명령어를 입력해서 올바르게 설정했는지 점검할 수 있다.)

1.  GitHub, <https://github.com> 에 계정을 생성한다 (무료사용도 좋다).
    상기 적용한 동일한 전자우편을 사용한다.
    
1.  필요하다면, SSH 키를 생성한다. SSH키를 사용해서 비밀번호 없이도 안전하게 웹사이트와 
    의사소통을 가능케 한다. SSH 키는 두 부분으로 구성된다: 개인키, 공개키.
    공개키를 갖는 사람이 안전하게 데이터를 암호화할 수 있는데,
    상응하는 비밀키를 갖고 있는 사람만 암호화된 데이터를 해독할 수 있다.
    
    다음 명령어를 실행해서 SSH 키 짝을 이미 갖고 있는지 점검할 수 있다:


    ```{r, eval = FALSE}
    file.exists("~/.ssh/id_rsa.pub")
    ```

    만약 상기 실행결과 `FALSE`가 반환되면, 신규 키를 생성할 필요가 있다.
    [GitHub 안내지침](https://help.github.com/articles/generating-ssh-keys)을 따르거나,
    RStudio를 사용할 수도 있다. RStudio 개인설정(Preference)으로 들어가서,
    Git/SVN 창을 선택하고, "Create RSA key..."을 클릭한다:
    

    ```{r, echo = FALSE}
    bookdown::embed_png("screenshots/git-config-2.png", dpi = 220)
    ```
    
1.  GitHub에 SSH 공캐키를 전달한다: <https://github.com/settings/ssh>.
    키를 찾는 가장 쉬운 방법은 RStudio Git/SVN 개인설정창에서 "View public key"를 클릭하는 것이다.

## 로컬 Git 저장소 생성하기 {#git-init}

Git을 설치하고 환경설정을 했기 때문에, 이제부터 사용할 수 있다!
팩키지 작성에 GitHub을 사용하려면, 먼저 줄여서 __repo__라고 부르는 로컬 저장소(repository)를 초기화한다. 초기화되면, `.git` 디렉토리가 생성되는데 환경설정 파일과 코드 변경내역을 기록하는 데이터베이스가 그곳에 저장된다. 신규 저장소는 개발자 본인 컴퓨터에만 존재하게 된다; 곧 다른 개발자와 저장소를 공유하는 방법을 학습할 것이다.

신규 저장소를 생성하기 위해서:


  * RStudio에서 `project options`로 들어가서, Git/SVN 창을 클릭한다.
    "버젼제어시스템(Version control system)"을 "None"에서 "Git"로 변경한다:
    
    ```{r, echo = FALSE}
    bookdown::embed_png("screenshots/git-proj-config.png", dpi = 220)
    ```
    
    그러면 RStudio를 제시작하라는 메시지가 뜬다.
    

  * 쉘에서, `git init`을 실행한다. RStudio를 재시작하고 팩키지를 작성한 팩키지를 다시 연다.
  

Git이 초기화되면, 신규 컴포넌트 두개를 볼 수 있다:

  * 우측 상단에 __Git 창(pane)__에서 무슨 파일이 변경되었는지 알 수 있고,
    가장 중요한 Git 명령어 버튼도 포함돼 있다:
  
    ```{r, echo = FALSE}
    bookdown::embed_png("screenshots/git-pane.png", dpi = 220)
    ```

  * 툴바에서 찾을 수 있는 __Git 드롭다운(dropdown)__는 현재 파일에 적용할 수 있는
    Git과 GitHub 명령어가 포함되어 있다:
    
    ```{r, echo = FALSE}
    bookdown::embed_png("screenshots/git-dropdown.png", dpi = 220)
    ```

## 변경된 사항 살펴보기 {#git-status}

첫번째 Git 사용 장점은 개발하면서 만든 변경사항을 쉽게 볼 수 있다는 것이다.
우연히 키보드 단축키를 잘못 눌러서 코드에 길 잃은 문자를 코드에 넣었을 때, 저자는 이 기능이 정말 도움이 된다고 본다. 
RStudio Git 창에는 추가되고, 변경되고, 삭제된 모든 파일 목록이 나와 있다.
각 아이콘이 변경된 내역을 기술한다:

* `r bookdown::embed_png("screenshots/git-modified.png", dpi = 220)`, 
  __Modified__. 파일 내용이 변경되었다.

* `r bookdown::embed_png("screenshots/git-unknown.png", dpi = 220)`, 
  __Untracked__. Git 시스템이 이전에 본적이 없는 신규 파일이 추가되었다.

* `r bookdown::embed_png("screenshots/git-deleted.png", dpi = 220)`, 
  __Deleted__. 파일이 삭제되었다.


"diff", `r bookdown::embed_png("screenshots/git-diff.png", dpi = 220)` 명령어로
변경사항에 대한 좀더 상세한 내역을 볼 수 있다. 신규 창을 열어 구체적인 차이(**diff**erences)를 보여준다:

```{r, echo = FALSE}
bookdown::embed_png("screenshots/git-diff-window.png", dpi = 220)
```

배경색을 통해서 텍스트가 추가(녹색)되었는지 삭제(적색)되었는지 알 수 있다.
(만약 색맹이라면, 가장 왼쪽에 두 칼럼에 행번호로 알 수 있다: 첫번째 칼럼 숫자는 이전 버젼, 두번째 칼럼 숫자는 신규 버젼을 나타낸다.)
변경사항 위아래 코드 회색줄은 추가적인 내용을 전달한다.

쉘에서, `git status` 명령어를 사용해서 전반적인 변경사항을 확인할 수 있고,
`git diff`를 사용해서 차이분에 대한 자세한 사항을 볼 수도 있다.

## 변경사항 기록 {#git-commit}

Git에서 작업 기본 단위는 __커밋(commit)__이다.
커밋은 특정 시점에 작성한 코드에 대한 짧은 묘사정보(스냅샷, Snapshot)를 기록한다.
Git 커밋을 사용하는 것은 등반할 때 앵커와 기타 보호장구를 사용하는 것과 같다.
만약 위험한 바위를 가로지를 때, 추락하게 되면 잡아줄 보호장치가 확실히 필요할 것이다.
커밋이 유사한 역할을 한다: 만약 실수를 하게 되면, 이전 커밋 이후로 추락되지 않게 된다.
커밋이 없는 코딩은 도구 없이 하는 (암벽) 등반같다: 
단시간에 훨씬 더 빨리 이동할 수 있지만, 장기적으로 보면 비극적 실패 가능성도 높다!
암벽등반 보호장구처럼, 커밋을 사용할 때 신중히 판단해야 된다.
너무 자주 커밋하게 되면 진행을 더디게 한다; 불확실하고 위험한 영역에 있을 때는 커밋을 더 많이 사용하라. 커밋은 다른 사람에게도 도움이 된다. 왜냐하면, 목적지 뿐만 아니라 여행경로도 볼 수 있기 때문이다.

매번 커밋할 때마다 5가지 주요한 구성요소가 있다:

* 유일무이한 식별자, SHA라고 불림 (secure hash algorithm의 약자로 보안 해쉬 알고리즘).

* 무슨 파일이 추가, 변경, 삭제되었는지 기술하는 변경집합(changeset).

* 사람이 읽을 수 있는 커밋 메시지.

* 부모 커밋, 해당 커밋 이전 커밋. (이 규칙에는 예외가 두가지 있다:
  최초 커밋은 부모가 없고, 나중에 학습할 병합(merge)은 부모가 둘이다.)

* 저자(author)

두 단계로 나누어서 커밋을 생성한다:

1.  __준비(staging)__ 단계에서, 다음번 커밋에 어떤 변경사항이 포함되어야 하는지 Git에게 일러준다.


1. __커밋(commit)__ 단계에서, 준비된 파일을 메시지로 변경사항을 기술하고 커밋한다.

RStudio에서, 준비(staging)와 커밋(commit)은 동일 장소에서 수행된다.
`r bookdown::embed_png("screenshots/git-commit.png", dpi = 220)`을 클릭하거나, Ctrl + Alt + m 단축키를 누르면 커밋 윈도우가 나온다.

```{r, echo = FALSE}
bookdown::embed_png("screenshots/git-commit-window.png", dpi = 220)
```

커밋 윈도우는 창(pane) 세개로 구성된다:

* 좌측 상단 창(pane)에 현재 상태정보가 있는데 RStudio 윈도우 Git 창(pane)에 있는 것과 같다.

* 아래 창(pane)에는 현재 선택된 파일 차이(diff) 정보가 나와 있다.

* 우측 상단 창(pane)에는 커밋할 때 변경 내용을 요약해서 사람이 읽을 수 있는 
  메시지를 입력하는 곳이다. 좀더 자세한 사항에 대해서 곧 다시 다룰 예정이다.
  
(그렇다, `r bookdown::embed_png("screenshots/git-diff.png", dpi = 220)` 를 클릭할 때,
나타나는 창과 정확하게 동일하다!)  

신규 커밋을 생성하기 위해서:


1.  __변경사항을 저장한다__.

1.  `r bookdown::embed_png("screenshots/git-commit.png", dpi = 220)`을 클릭하거나 
    `Ctrl + Alt + m` 단축키를 눌러 __커밋 윈도우를 연다__.

1.  __파일을 선택한다__. 포함시킬 파일을 준비(staging)시키려면, 확인란(check box)를 선택한다.
    모든 파일을 준비(staging)시키려면, Ctrl/Cmd + A 단축키를 누르고 나서, 
    `r bookdown::embed_png("screenshots/git-stage.png", dpi = 220)`을 클릭한다.

    각 파일을 준비시킬 때, 상태가 변경되는 것을 알아챘을 것이다.
    아이콘이 오른쪽(준비되지 않은 상태, unstaged)에서 왼쪽(준비된 상태, staged)으로 
    칼럼을 변경한다. 그리고 다음 신규 아이콘 두개중 하나를 볼 수도 있다.
    

      * 추가(added): `r bookdown::embed_png("screenshots/git-added.png", dpi = 220)`: 
        추적되지 않은 파일을 준비상태로 올린 후에, 개발자가 신규 파일을 저장소에 추가하고자 
        한다는 것을 Git 시스템이 이제는 알고 있다.
      
      * 이름 변경(renamed): `r bookdown::embed_png("screenshots/git-renamed.png", dpi = 220)`:
        만약 파일 이름을 변경하면, 처음에 Git은 파일을 삭제하고 추가한 것으로 본다.
        두 변경사항을 준비단계로 올리게 되면, Git이 이름변경을 인지한다.
    
    종종, 두 칼럼에 걸친 상태 아이콘을 보게 된다, 예를 들어, `r bookdown::embed_png("screenshots/git-modified-staged.png", dpi = 220)`.
    동일한 파일이 준비상태기도 하고 준비되지 않은 상태이고도 하다는 것을 의미한다.
    일부 변경을 하고 준비상태로 올려놓은 다음에, 일부 변경을 할 때 이런 경우가 발생한다.
    준비상태 체크박스를 클릭하면 신규 변경사항이 준비상태로 올라가고,
    다시 체크박스를 클릭하면, 양쪽 변경사항 모두 준비상태에서 풀려 내려온다.
    

1.  위와 마찬가지로 __파일을 준비상태로 올린다__.

1.  __커밋 메시지를 작성한다__ (우측 상단 창), 메시지에는 변경사항을 기술한다.
    커밋 메시지 첫번째 행을 제목란으로 불리는데 간결해야 된다 (문자 50개 이하).
    복잡한 커밋에는, 빈줄을 넣고 나서 문단 혹은 글머리표를 통해 상세한 내용을 적는다.
    누군가에게 무엇을 수행하라고 지시하는 것처럼, 명령조로 메시지를 작성하라:
    "이 버그를 고쳤다(fixed this bug)" 혹은 
    "이 버그는 고쳐졌다(this bug was fixed)"가 아니라 "이 버그를 고쳐라(fix this bug)".

1.  __커밋(Commit)을 클릭한다__.

파일을 준비단계로 올리는 것은 쉘에서 다소 복잡하다.
`git add`를 사용해서 신규, 변경된 파일을 준비단계로 올린다. `git rm`를 사용해서 준비단계에 올라간 파일을 삭제한다. 커밋을 생성하려면, `git commit -m <message>` 명령어를 사용한다.

## 커밋 모범사례 {#commit-best-practices}

이상적인 것은 각 커밋은 _최소(minimal)_지만 _완결(complete)_되야 된다:


* __최소(Minimal)__: 한 커밋에는 단일문제에 연관된 변경사항만 담겨져야 된다.
  이렇게 함으로써 한번에 커밋된 것을 이해하고 간단한 메시지로 기술하기도 더 쉽게 된다.
  만약 새로운 문제를 발견한다면, 구별되는 별도 커밋을 수행해야 된다.

* __완결(Complete)__: 해결하려고 주장하는 문제를 한 커밋으로 해결한다.
  만약 버그를 고쳤다고 생각하면, 커밋은 단위 테스트를 포함해서 주장이 맞다는 사실을 확인해야 한다.

각 커밋 메시지는 다음과 같아야 된다:

* __간략하지만, 연상시켜야 된다__. 한눈에, 커밋이 무엇을 했는지 알 수 있어야 된다.
  하지만, 충분히 구체적인 사항이 녹아져서 무엇이 수행되었는지 기억할 (그리고 이해할) 수
  있어야 된다.

* __대상(what)이 아니라 이유(why)를 기술하라__. 커밋과 연관된 차이(diff)를 항상 불러올 수 
  있기 때문에, 메시지에 정확하게 무엇이 변경되었는지 적을 필요는 없다.
  대신에, 변경에 대한 이유에 집중한 높은 수준의 요약정보를 제공해야 된다.

만약 상기 사항을 잘 수행한다면:


* 다른 개발자와 공동작업하기가 더 쉽다. 예를 들어, 만약 두 사람이 같은 곳에서 같은 파일을
  변경했다면, 충돌을 해결하기 더 쉽다. 왜냐하면, 커밋 단위가 작고, 
  각 변경에 대한 사유가 명확하기 때문이다.

* 프로젝트 신규 참가자도 커밋 로그를 읽으면 지나온 이력을 더 쉽게 이해할 수 있다.

* 개발이력을 따라 특정 지점에서 작성한 팩키지를 적재하고 실행할 수 있다.
  [bisectr](https://github.com/wch/bisectr)같은 도구를 함께 사용하면 매우 유용하다.
  이진 검색을 사용해서 신속하게 버그가 주입된 커밋을 색출할 수 있다.
  
* 언제 버그가 주입되었는지 정확하게 알 수 있게 되면, 
  무엇을 수행하면 되는지 (그리고 왜!) 쉽게 이해할 수 있다.

어떤 누구도 개발하고 있는 저장소를 살펴보지 않을 것이기 때문에, 좋은 커밋 메시지를 작성하는 것이 노력대비 가치가 없을 것으로 생각할지도 모른다.
하지만, 매우 중요한 공동작업자가 있다는 것을 명심하라: 미래의 당신!
만약 지금 커밋 메시지에 약간 공을 드리면, 버그에 대한 부검을 한다면 그리고 부검을 할 필요가 있다면
미래의 당신이 매우 고마워할 것이다.

이러한 지시사항은 단지 열망을 담고 있다고 기억하기 바란다.
이러한 것이 방해가 되서는 않된다.
만약 여러분이 저자 저장소 커밋 이력을 본다면, 많은 부분은 그다지 훌륭하지 못하다는 것을 알아챘을 것이다. 특히, __여전히__ 어떻해서든지 버그를 고쳐보려고 하지 못할 정도로 좌절이 시작될 때 더욱 그렇다. 상기 안내지침을 따르려고 노력하고, 하나의 완전한 커밋보다는 다수 불완전한 커밋이 더 낫다.

## 파일 무시하기 {#git-ignore}

종종, 저장소에 포함하고 싶지 않은 파일이 있다.
이러한 유형의 파일은 일시적이고(LaTeX 혹은 C 빌드 산출물), 매우 크거나, 요청시 생성되는 것이 포함된다. 매번 주의를 기울여 준비단계로 _올리지 않는_ 대신에, `.gitignore` 파일에 추가하면 된다.
이 기능을 통해서 준비단계로 올려지는 것을 방지한다.
가장 쉬운 방법은 Git 창(pane)에서 우클릭해서 `Ignore`를 선택한다:


```{r, echo = FALSE}
bookdown::embed_png("screenshots/git-ignore.png", dpi = 220)
```

만약 파일 다수를 무시하려면, `*.png` 처럼 와일드카드 "글롭(glob)"을 사용할 수 있다.
선택옵션에 관한 좀더 학습하려면, Pro-Git 책에 [파일 무시하기](http://git-scm.com/book/ch2-2.html#Ignoring-Files)를 참조한다.

일부 개발자는 파생파일을 절대로 커밋하지 않는다. 파생파일은 자동으로 생성될 수 있다.
R 팩키지 개발에서는 `NAMESPACE` 파일과 `man/` 디렉토리에 담기는 파일이 버전관리에서 무시된다는 것을 의미한다. 왜냐하면 주석으로부터 만들어지기 때문이다. 실무적인 면에서는 이러한 파일도 커밋하는 것이 낫다: R 팩키지가 설치에 `.Rd` 파일을 만들어낼 방도가 없다. 그래서, 파생파일을 무시하게 되면 GitHub에서 작성한 팩키지를 설치한 사용자는 문서가 전혀없게 된다.

## 실수 실행취소(Undo) {#git-undo}

커밋을 사용하게 되면 가장 좋은 점은 실수를 실행취소할 수 있다는 것이다.
RStudio는 이러한 점을 특히 쉽게 만들었다:


*   방금 변경한 사항을 실행취소하려면, Git 창(pane)에서 파일을 우클릭하고 되돌리기 "revert"를
    선택한다. 이러게 하면 이전 커밋으로 변경사항을 다시 되돌린다. 
    주의: 이 작업을 다시 실행취소할 수는 없다!

    차이 (diff) 윈도우에 파일 일부만 실행취소할 수도 있다.
    실행취소 하고자하는 변경 블록 상단에 __discard chunk__를 찾아봐라: 
    `r bookdown::embed_png("screenshots/git-chunk.png", dpi = 220)`.
    개별 행 혹은 선택한 텍스트에 변경사항도 폐기할 수 있다.
    

*   만약 너무 일찍 변경사항을 커밋했다면, 추가 변경사항을 준비단계로 올려서
    이전 커밋을 변형할 수 있다. 커밋을 클릭하기 전에, 
    `r bookdown::embed_png("screenshots/git-commit-amend.png", dpi = 220)`
    체크박스를 선택하라. 
    (이전 커밋을 GitHub에 푸쉬했다면, 이 기능을 사용하지 마라 -
    이력(history)을 효과적으로 다시 작성하는 방법으로, 공공장소에서 작업을 할 때는
    주의를 기울여야 한다.)

즉석에서 실수를 잡아내지 못한다면, 이력을 거슬러 올라가서 살펴보고, 실수가 발생한 장소를 찾아낼 필요가 있다:


1.  Git 창(pane)에서 `r bookdown::embed_png("screenshots/git-history.png", dpi = 220)` 을
    클릭해서 이력(history) 윈도우를 연다.
    
    ```{r, echo = FALSE}
    bookdown::embed_png("screenshots/git-history-window.png", dpi = 220)
    ```

    이력 윈도우는 두 부분으로 나뉘어진다.
    상단 부분은 저장소에 모든 커밋 목록을 출력한다.
    하단 부분은 커밋을 보여준다: SHA (유일무이한 id), 저자, 날짜, 부모, 커밋 변경사항.
    
    
1.  실수가 일어난 커밋을 찾아낼 때까지 시간을 거슬러 탐색한다.
    부모 SHA 코드를 적는다: 실수를 저지르기 전 커밋으로 다시 작업하는 시점으로 적절할 것이다.


이제 쉘에서 상기 SHA 코드를 사용한다:

*   파일이 과거에 어땠는지 보고서 이전 코드를 복사해서 붙여넣을 수 있다:

    ```bash
    git show <SHA> <filename>
    ```

*   혹은 과거 버젼을 복사해서 현재로 가져온다:

    ```bash
    git checkout <SHA> <filename>
    ```

상기 두가지 경우 모두 파일을 준비단계로 올리고 커밋해서 마무리할 필요가 있다.
    
(마치 시간을 거슬러 올라가서 실수가 처음부터 발생하지 않은 것처럼 Git를 사용하는 것도 가능하다.
이것이 __이력 리베이스(rebasing history)__로 불리는 고급기술이다. 상상하듯이, 과거를 변경하려고 시간을 거슬러 올라가면 현재에도 심오한 영향을 준다. 유용할 수 있지만, 극도로 조심해서 사용될 필요가 있다.)

그래도 여전히 문제에 봉착했다면, <http://sethrobertson.github.io/GitFixUm/fixup.html> 혹은 <http://justinhileman.info/article/git-pretty/>을 참조한다.
흔히 있는 (그다지 흔하지는 않음!) 많은 문제를 고치는데 단계별 접근법을 제시하고 있다.

## GitHub과 동기화 {#github-init}

지금까지 로컬 컴퓨터에서만 작업을 해왔다. 커밋을 사용해서 프로젝트 진도를 추적하고 안전 검사점(checkpoint)도 찍었다. 하지만, Git이 정말 빛을 발할 때는 작성한 코드를 
[GitHub](http://github.com)으로 다른 개발자와 공유하기 시작할 때다.
다른 선택지가 있지만, 저자는 GitHub을 추천하는데 이유는 공개 소프트웨어 프로젝트에 대해서는 무료고, 필요한 모든 기능을 갖추고 있으며, R 개발자 세상에서는 가장 대중적인 선택이라서 그렇다.

작성한 코드를 GitHub에 게시, 즉 __푸시(push)__하려면:



1.  GitHub에 신규 저장소를 생성한다: <https://github.com/new>.
    작성한 팩키지와 동일한 명칭을 부여하고, 팩키지 제목을 저장소 설명으로 추가한다.
    다른 선택옵션을 그대로 두고, 완료(Submit) 버튼을 클릭한다.

1.  쉘을 열고 나서, 신규 저장소 페이지 안내절차를 따른다.
    안내절차는 다음과 같을 것이다:

    ```bash
    git remote add origin git@github.com:hadley/r-pkgs.git
    git push -u origin master
    ```
    
    상기 첫번째 줄을 해석하면, 로컬 저장소가 GitHub에 원격 버젼 저장소를 갖고 있는데 
    "origin"으로 칭한다. 두번째 줄은 현재 모든 작업결과를 원격 저장소에 밀어 넣는다는 
    것을 의미한다.

이제 커밋을 하고, 원격 저장소가 갱신되었는지 확인하자:

1.  `DESCRIPTION` 파일을 변경해서 `URL` 과 `BugReports` 필드를 추가해서
    신규 GitHub 사이트에 연결한다. 예를 들어, `dplyr`은 다음과 같다:

    ```yaml
    URL: http://github.com/hadley/dplyr
    BugReports: http://github.com/hadley/dplyr/issues
    ```

1.  파일을 저장하고 ("Updating DESCRIPTION to add 
    links to GitHub site") 메시지를 넣어 커밋한다.
    
1.  `r bookdown::embed_png("screenshots/git-push.png", dpi = 220)`을 클릭해서 GitHub에
   변경사항을 __푸쉬(Push)__한다. (쉘에서 `git push` 명령어를 실행한 것과 동일하다).
    
1.  GitHub 페이지로 돌아가서 `DESCRIPTION` 파일을 살펴본다.

대체로, 푸쉬 각각에는 다수 커밋이 포함된다.
왜냐하면, 커밋하는 것보다 덜 푸쉬하기 때문이다.
얼마나 자주 푸쉬 vs 커밋 비율을 갖는지는 완전히 개발자 본인에게 달려있다.
하지만, 코드를 푸시는 코드를 출시한다는 의미가 된다. 그래서 정상 동작하는 코드를 푸쉬하려고 노력하라.

작성한 코드가 정확하다는 것을 확실히 하려면, 저자는 항상 코드를 푸시하지 전에 `R CMD check` 명령어 실행을 추천한다 ([automated checking](#check)에서 배울 주제).
(아직) 정상 동작하지 않는 코드를 게시하려면, 다음 [branching](#git-branch)에서 학습할 예정인,
분기(branch) 사용을 추천한다.


로컬 저장소를 GitHub에 연결하게 되면, Git 창(pane)에 GitHub에 푸쉬되지 않고 로컬 저장소에 커밋된 정보를 보여준다: `r bookdown::embed_png("screenshots/git-local-commits.png", dpi = 220)`.
이 메시지가 나타내는 것은 로컬(분기)에 커밋이 1개 있는데 GitHub("origin/master")에는 올라가지 않았다는 것이다.


## GitHub 사용에 따른 혜택 {#github-benefit}

1.  괜찮은 웹사이트가 생김. 팩키지에 대한 GitHub 페이지에 팩키지에 대한 모든 파일과 디렉토리 
    목록이 올라간다. 예를 들어, <https://github.com/hadley/testthat> (the GitHub repo for testthat). 
    `.R` 파일은 구문 강조 기능으로 서식이 입혀지고, `.md`/`.Rmd` 파일은 HTML로 렌더링된다.
    그리고, 만약 최상위 디렉토리에 `README.md` 파일을 포함하게 되면, 홈페이지로 화면에 출력된다.
    [README.md](#readme)에서 이 파일 생성에 따른 혜택에 대해서 더 배울 예정이다.

1.  작성한 팩키지를 다른 누군가 설치하기 쉽게 한다. 
    (그리고 개발자의 노고에 대한 혜택도 포함된다):

    ```r
    devtools::install_github("<your_username>/<your_package>")
    ``` 

1.  커밋 보기에서 프로젝트 이력을 추적할 수 있다. 예를 들어, 
    <https://github.com/hadley/testthat/commits/master>.
    다른 개발자와 저자가 팩키지에 대한 작업을 할 때,
    해당 페이지를 공개해서 다른 개발자가 작업하는 것을 볼 수 있다.
    개별 커밋에는 RStudio commit/diff 창에서 보는 것과 
    동일한 정보가 나타나 있다.
    

1.  파일 이력을 보는 것도 쉽다.
    만약 파일을 탐색하고 __이력(History)__을 클릭하면,
    파일에 영향을 준 모든 커밋 정보가 나와 있다.
    또다른 유용한 관점은 __책임(Blame)__이다;
    각 코드 라인에는 최종 변경정보, 변경작업한 개발자 정보, 변경사항이 속한 커밋정보가 
    나와있다. 버그를 추적해서 좁혀갈 때, 엄청나게 도움이 된다.

    RStudio 툴바에 있는 Git 드롭다운 메뉴를 통해서 해당 페이지로 바로 들어갈 수 있다: 
    
    ```{r, echo = FALSE}
    bookdown::embed_png("screenshots/git-dropdown.png", dpi = 220)
    ```

1.  커밋에 주석을 달 수도 있다. 전체로 커밋에 주석을 달려면,
    페이지 하단에 주석상자를 활용한다.
    각 라인에 주석을 달려면, 해당 라인에 마우스를 갖다대면 더하기 기호가 생기는데 이를 클릭한다, 
    `r bookdown::embed_png("screenshots/github-comment-line.png", dpi = 220)`.
    실수한 것을 보거나 질문이 있을 때 동료개발자에게 정보를 제공하는 훌륭한 방법이다.
    전자우편보다 더 좋은데 이유는 공개되어 있어
    저장소에 작업하고 있는 (현재 혹은 미래) 누구나 대화내용을 볼 수 있기 때문이다.


## 다른 개발자와 공동 작업하기 {#git-pull}

GitHub에 작성한 변경사항을 전송할 때 __푸쉬(push)__를 사용한다.
만약 다른 개발자와 공동 작업할 때, 상대 개발자도 GitHub에 그들이 작업한 변경사항을 푸쉬한다.
하지만, 로컬에서 변경사항을 보려면, GitHub에서 변경사항을 __풀(pull)__해서 가져와야 된다.
사실, 모든 개발자와 동기화를 확실히 하려면, 풀 명령어로 가장 최신 버젼을 받아오면
저장소에 푸쉬만 Git이 허락한다.


풀 명령어를 실행하면, Git은 먼저 모든 변경사항을 다운로드(__fetch__)하고 나서 로컬에서 작업한 변경사항과 __병합(merge)__한다.
병합은 두 부모를 갖는 커밋이다. 서로 다른 두 개발 코드를 결합해서 단일 결과로 만든다.
많은 경우에, 자동으로 Git이 작업을 수행한다: 예를 들어,
다른 파일에, 혹은 동일한 파일에 다른 부분에 변경사항이 반영되어 있다면 자동으로 작업한다.
하지만, 파일 동일한 장소에 변경사항이 반영되어 있다면, 개발자 본인 스스로 __병합충돌(merge conflict)__을 해소해야만 된다.


RStudio에서, 다음과 같은 경우에 병합충돌을 발견할 수 있다:

* 풀 작업이 오류로 실패하는 경우.

* Git 창에, `r bookdown::embed_png("screenshots/git-commit-conflict.png", dpi = 220)` 
  상태정보가 뜰 경우.

RStudio에서 현재 병합 충돌에 도움이 되는 어떤 도구도 제공하고 있지 않다.
그래서, 명령라인 인터페이스에서 작업해야 된다.
저자는 병합충돌 "스타일(style)"을 `diff3`로 설정해서 작업할 것을 추천한다.
병합충돌이 발생할 때, `diff3` 스타일에는 세가지 정보가 나타난다: 로컬 변경사항,
원래 파일, 원격 변경사항. 디폴트 기본설정 스타일은 `diff2`로 로컬 변경사항과 원격 변경사항 정보만 나타나 있다. 일반적으로 `diff2` 스타일로는 무슨 일이 발생했는지 파악하기 더 어렵다.


* 첫번째 병합 충돌과 조우하면, 다음을 수행한다:

    ```bash
    # 해당 병합을 중단시킨다.
    git merge --abort
    # 충돌 스타일을 환경설정한다
    git config --global merge.conflictstyle diff3
    # 병합을 다시 시도한다.
    git pull
    ```
    
* 만약 병합충돌 과정에 있지 않다면, 다음만 실행한다.

    ```bash
    git config --global merge.conflictstyle diff3
    ```

병합충돌을 해결하기 위해서는, 상태정보 `r bookdown::embed_png("screenshots/git-commit-conflict.png", dpi = 220)`을 갖는 모든 파일을 열어서 살펴볼 필요가 있다. 각 파일에서 다음과 같은 충돌 표식이 보일 것이다:

```
<<<<<<< HEAD

||||||| merged common ancestors

=======

>>>>>>> remote
```

충돌을 일으킨 코드에 세가지 모든 버젼 정보가 나타나 있다:

* 상단에, 작성한 로컬 코드.

* 중간에, 두줄 개발코드 사이에 분기 전 최종 커밋에서 나온 코드
  (디폴트 기본설정 충돌 스타일에는 생략된다. 그래서 만약 중간부분이 보이지 않는다면,
  상기 안내지침을 따라 설정하면 보인다).

* 하단에, GitHub에서 풀명령으로 내려받은 원격 코드.

각 충돌 문제를 해결하고 어느 쪽 버젼이 더 나은지 혹은 어떠한 방식으로 병합할지 결정도 해야 된다.
그리고 나서, 파일을 준비단계에 올리기 전에, 모든 충돌 표식을 삭제했는지 확실히 한다.
모든 충돌사항을 고치고 나면, 신규 커밋을 생성해서 GitHub에 푸쉬해서 올린다.

`roxygen`으로 생성된 텍스트 문제를 고칠 때 몇가지 유의점이 있다:

* `man/*.Rd` 파일에 문제를 직접 고치지 마라. 대신에 
  근본이 되는 roxygen 주석에 충돌을 해결하고 팩키지를 다시 문서화한다.
  
* `NAMESPACE` 파일에 병합충돌로 인해 팩키지를 재적재 혹은 재문서화가 되지 않는다.
  충분히 충돌문제를 해결해서 팩키지가 적재되도록 하고나서 깨끗하고 정확한 `NAMESPACE`를 
  생성하도록 다시 문서화한다.

병합충돌 처리는 Git에서 가장 까다로운 부분중 하나다.
요령을 터득하기 전에 사용지침서 몇개를 읽을 필요가 있다.
구글과 스택오버플로우는 그자체로 훌륭한 교재다.
만약 끔찍할 정도로 혼란스러울 경우에는 항상 병합을 중단하고 다시 시작한다.
그때는 `git merge --abort` 명령어를 실행하고 나서, `git pull` 명령어를 차례로 실행한다.


## 이슈사항 (Issues) {#github-issues}



Every GitHub repo comes with a page for tracking issues. Use it! If you encounter a bug while working on another project, jot a note down on the issues page. When you have a smaller project, don't worry too much about milestones, tags and assigning issues to specific people. Those are more useful once you get over a page of issues (>50). Once you get to that point, read the GitHub guide on issues: <https://guides.github.com/features/issues/>.

A useful technique is closing issues from a commit message. Just put `Closes #<issue number>` somewhere in your commit message and GitHub will close the issue for you when you next push. The best thing about closing issues this way is that it makes a link from the issue to the commit. This is useful if you ever have to come back to the bug and want to see exactly what you did to fix it. You can also link to issues without closing them; just refer to `#<issue number>`.

As you'll learn about in [NEWS.md](#news), it's a good idea to add a bullet to `NEWS.md` whenever you close an issue. The bullet point should describe the issue in terms that users will understand, as opposed to the commit message which is written for developers.

## Branches {#git-branch}

Sometimes you want to make big changes to your code without having to disturb your main stream of development. Maybe you want to break it up into multiple simple commits so you can easily track what you're doing. Maybe you're not sure what you've done is the best approach and you want someone else to review your code. Or, maybe you want to try something experimental (you can merge it back only if the experiment succeeds). Branches and pull requests provide powerful tools to handle these situations.

Although you haven't realised it, you're already using branches. The default branch is called __master__; it's where you've been saving your commits. If you synchronise your code to GitHub you'll also have a branch called __origin/master__: it's a local copy of all the commits on GitHub, which gets synchronised when you pull. `git pull` does two things:

1.  `git fetch origin master` to update the local `origin/master` branch with
    the latest commits from GitHub.
  
1.  `git merge orgin/master` to combine the remote changes with your changes.

It's useful to create your own branches when you want to (temporarily) break away from the main stream of development. You can create a new branch with `git checkout -b <branch-name>`. Names should be in lower case letters and numbers, with `-` used to separate words. 
  
Switch between branches with `git checkout <branch-name>`. For example, to return to the main line of development use `git checkout master`. You can also use the branch switcher at the top right of the Git pane:
  
```{r, echo = FALSE}
bookdown::embed_png("screenshots/git-branch.png", dpi = 220)
```

If you've forgotten the name of your branch in the shell, you can use `git branch` to list all existing branches. 

If you try to synchronise this branch to GitHub from inside RStudio, you'll notice that push and pull are disabled: `r bookdown::embed_png("screenshots/git-no-remote.png", dpi = 220)`. To enable them, you'll need to first tell Git that your local branch has a remote equivalent:

```bash
git push --set-upstream origin <branch-name>
```

After you've done that once, you can use the pull and push buttons as usual.

If you've been working on a branch for a while, other work might have been going on in the master branch. To integrate that work into your branch, run `git merge master`. You will need to resolve any merge conflicts (see above). It's best to do this fairly frequently - the less your branch diverges from the master, the easier it will be to merge.

Once you're done working on a branch, merge it back into the master, then delete the branch:

```bash
git checkout master
git merge <branch-name>
git branch -d <branch-name>
```

(Git won't let you delete a branch unless you've merged it back into the master branch. If you do want to abandon a branch without merging it, you'll need to force delete with `-D` instead of `-d`. If you accidentally delete a branch, don't panic. It's usually possible to get it back. See the advice about undoing mistakes).

## Making a pull request {#git-pullreq}

A pull request is a tool for proposing and discussing changes before merging them into a repo. The most common use for a pull request is to contribute to someone else's code: it's the easiest way to propose changes to code that you don't control. 

Below, you'll learn about pull requests to make changes to your own code. This may seem a bit pointless because you don't _need_ them, as you can directly modify your code. But pull requests are surprisingly useful because they allow you to get feedback on proposed changes. We use them frequently at RStudio to get feedback before merging major changes.

GitHub has some good documentation on using pull requests: <https://help.github.com/articles/using-pull-requests/>. In this chapter, I'll focus on the basics you need to know to use pull requests effectively, and show you how they fit in with the Git commands you've learned so far.

To create a pull request, you create a branch, commit code, then push the branch to GitHub. When you next go to the GitHub website you'll see a header that invites you to submit a pull request. You can also do it by:

1.  Switching branches: 

    ```{r, echo = FALSE}
    bookdown::embed_png("screenshots/github-branches.png", dpi = 220)
    ```

1.  Clicking `r bookdown::embed_png("screenshots/pr-create.png", dpi = 220)`

This will create a page that looks like this:

```{r, echo = FALSE}
bookdown::embed_png("screenshots/pr.png", dpi = 220)
```

This pull request, which fixes a couple of small problems, is one that was submitted to this book's GitHub site.

There are three parts to a pull request:

* A __conversation__, 
  `r bookdown::embed_png("screenshots/pr-conversation.png", dpi = 220)`,
  where you can discuss the changes as a whole.
  
* The __commits__ view, 
  `r bookdown::embed_png("screenshots/pr-commits.png", dpi = 220)`,
  where you can see each individual commit.
  
* The __file changes__,
  `r bookdown::embed_png("screenshots/pr-changes.png", dpi = 220)`,
  where you see the overall diff of the commits, and you can comment
  on individual lines.

Once you're done discussing a pull request, you either choose to merge it or delete it. Merging it is equivalent to running `git merge <branchname>` from the shell; deleting is equivalent to `git branch -r <branchname>`.

## Submitting a pull request to another repo {#pr-make}

To submit a pull request to a repo that you don't own, you first need to create a copy of the repo that you can own, called a __fork__, and then clone that fork on your own computer:

1.  __Fork__ the original repo by going to the repo on GitHub and clicking
    `r bookdown::embed_png("screenshots/github-fork.png", dpi = 220)`. 
    This creates a copy of the repo that belongs to you. 

1.  __Clone__ the forked repo to create a local copy of the remote repo. 
    It's possible to do this within RStudio (using "Create New Project" from 
    "Version Control") but I think it's easier to do it from the shell:
    
    ```bash
    git clone git@github.com:<your-name>/<repo>.git
    cd <repo>
    ```

A fork is a _static_ copy of the repo: once you've created it, GitHub does nothing to keep it in sync with the upstream repo. This is a problem because while you're working on a pull request, changes might occur in the original repo. To keep the forked and the original repo in sync, start by telling your repo about the upstream repo:

```bash
git remote add upstream git@github.com:<original-name>/<repo>.git
git fetch upstream
```

Then you can merge changes from the upstream repo to your local copy:

```bash
git merge upstream/master
```

When working on a forked repo, I recommend that you don't work on the master branch. Because you're not really working on the main line of development for that repo, using your master branch makes things confusing. 

If you always create pull requests in branches, you can make it a little easier to keep your local repo in sync with the upstream repo by running:

```bash
git branch -u upstream/master   
```

Then you can update your local repo with the following code:

```bash
git checkout master
git pull
```

Changes may occur while you're working on the pull request, so remember to merge them into your branch with:

```bash
git checkout <my-branch>
git merge master
```

A pull request (PR) is a one-to-one mapping to a branch, so you can also use this technique to make updates based on the pull request discussion. Don't create a new pull request each time you make a change; instead you just need to push the branch that the PR is based on and the PR webpage will automatically update.

The diagram below illustrates the main steps of creating a pull request and updating the request as the upstream repo changes:

```{r, echo = FALSE}
bookdown::embed_png("diagrams/pull-request-process.png", dpi = 220)    
```

## Reviewing and accepting pull requests {#pr-accept}

As your package gets more popular, you're likely to receive pull requests. Receiving a pull request is fantastic. Someone not only cares about your package enough to use it, they've actually read the source code and made an improvement!

When you receive a pull request, I recommend reviewing it using the three step approach described by Sarah Sharp. I summarise the three phases below, but I highly recommend reading the full article at <http://sarah.thesharps.us/2014/09/01/the-gentle-art-of-patch-review/>:

1.  Is it a good idea? If you don't think the contribution is a good fit for 
    your project, it's polite to let the contributor know as quickly as 
    possible. Thank them for their work, and refocus them on a better area to 
    work on.
    
1.  Is the overall approach sound? At this point you want to focus on the big
    picture: have they modified the right functions in the right way? Avoid
    nitpicking minor style problems (that's the final phase); instead just 
    provide a pointer to your style preferences, e.g. 
    <http://r-pkgs.had.co.nz/style.html>.

1.  Is it polished? In the final review phase, make sure that the non-code
    parts of the PR are polished. Prompt the contributor to update the 
    documentation, point out spelling mistakes and suggest better wording.
    
    I recommend asking the contributor to include a bullet point in `NEWS.md`, 
    briefly describing the improvement and thanking themselves with their GitHub 
    username. More details to follow in  [post release](#post-release)).

After discussion is complete, you can incorporate the changes by clicking the merge button. If the button doesn't work, GitHub provides some instructions on how to do it from the command line. While you've seen all the pieces before, it's useful to read through this just so you understand what exactly is happening.

```bash
# Create a new branch, and sync it with the pull request
git checkout -b <branch> master
git pull https://github.com/<user>/<branch>.git patch-3

# Merge the changes into the main line of development
git checkout master
git merge --no-ff <branch>
# Resolve conflicts, stage and add.

# Sync your local changes with GitHub
git push origin master
```

## Learning more {#git-learning}

Git and GitHub are a rich and powerful set of tools, and there's no way this chapter has taught you everything you need to know. However, you should now have the basic knowledge to be effective, and you should be in a good position to learn more. Some good resources are:
  
* GitHub help, <https://help.github.com>, not only teaches you about
  GitHub, but also has good tutorials on many Git features.

* If you'd like to learn more about the details of Git, read 
  [Pro Git](http://git-scm.com/book/en/v2) by Scott Chacon and Ben Straub.

Finally, StackOverflow is a vital part of Git - when you have a problem that you don't know how to solve, StackOverflow should be your first resource. It's highly likely that someone has already had the same exact problem as you, and that there will be a variety of approaches and solutions to choose from.

[gh-issues]:https://guides.github.com/features/issues/
[gh-pr]: https://help.github.com/articles/using-pull-requests/
[gh-releases]: https://help.github.com/articles/about-releases/
