---
title: Object documentation
layout: default
output: bookdown::html_chapter
---

# 객체 문서화(Documentation) {#man}

문서(Documentation)는 좋은 팩키지가 갖춰야 되는 가장 중요한 측면 중 하나다.
문서가 없다면, 사용자는 여러분이 작성한 팩키지를 어떻게 사용하는지 알 길이 없다.
문서는 또한 미래 당신 즉, 개발자 본인(그래서 작성한 함수가 무슨 기능을 수행하도록 만들어졌는지 기억하기 편하다)에게도 유용하고 팩키지를 확장하려는 다른 개발자에게도 마찬가지다.

문서화에 대한 다수 형태가 존재한다.
이번 장에서 `?` 혹은 `help()` 명령어로 접근하는 객체 문서화에 대해 배울 것이다.
객체 문서화는 일종의 참조 문서다. 마치 사전과 같다: 단어가 의미하는 바를 알고자 한다면 사전이 도움이 될 수 있을지라도, 전혀 새로운 상황에서 올바른 단어를 찾는데는 도움이 되지 못한다. 유사하게, 이미 객체 명칭을 알고 있다면 객체 문서가 도움이 되지만, 주어진 문제 해결책을 찾는데 필요한 객체를 찾는데는 도움이 되지 못한다.
이런 역할을 하는 것이 소품문(vignette)의 역할이고 다음 장에서 학습할 것이다.

팩키지 객체를 문서화하는 표준 방식을 R에서 제공한다: `man/` 디렉토리에 `.Rd` 파일을 작성한다. 이런 파일은 느슨하게 LaTeX에 기반한 사용자 정의 구문(custom syntax)을 사용해서, HTML, 일반 텍스트, pdf로 번역하여 옮겨 볼 수 있다. 수작업으로 파일 각각을 작성하는 대신에, `roxygen2`를 사용해서 특별한 형식으로 된 주석을 `.Rd` 파일로 변환한다. `roxygen2` 목적은 코드 문서화 작업을 가능하면 쉽게 자동화하는데 있다.
`.Rd` 파일을 수작업으로 일일이 작성하는데 비해서 많은 장점을 갖는다:

* 코드와 문서가 섞여있어서, 코드를 변경할 때, 문서도 갱신하도록 상기된다.

* `Roxygen2`가 동적으로 문서화한 객체를 검사한다. 그렇게 함으로써 `Roxygen2`를 사용하지 않는다면 
  수작업으로 작성이 필요한 표준문안(boilerplate) 작업을 건너뛰게 돕는다.
  
* 다른 유형의 객체를 문서화에서 발생하는 차이점을 추상화한다. 
  그렇게 함으로써, 구체적인 사항에 대해서 좀더 덜 학습해도 된다.  

`.Rd` 파일을 생성할 때, `roxygen2`를 사용해서 `DESCRIPTION` 파일에 `NAMESPACE`와 `Collate` 필드를 관리할 수 있다. 이번 장에서 `.Rd` 파일과 `collate` 필드를 다룬다. 
[NAMESPACE](#namespace)에서 `NAMESPACE`를 관리하는데 `roxygen2`를 사용하는 방법을 기술하고, 왜 관심을 가져야 하는지도 살펴본다.

## 문서화 작업흐름(workflow) {#man-workflow}

이번 절에서 전체 문서화 작업흐름에 대한 대략적인 개요를 살펴볼 것이다. 그리고 나서, 개별적으로 각 단계별로 파고든다. 네가지 기본 단계가 있다:

1. `.R` 파일에 `roxygen` 주석을 추가한다.

1. roxygen 주석을 `.Rd` 파일로 변환하는데 `devtools::document()` 명령어를 실행한다. (혹은 
RStudio에서 Ctrl/Cmd + Shift + D 단축키를 누른다).  (`devtools::document()`가 
   `roxygen2::roxygenise()`을 호출해서 고된 작업을 수행한다.)

1. `?` 명령어로 문서 미리보기 기능을 활용한다.

1. 문서가 원하는 대로 작업이 될 때까지 반복작업한다.

`roxygen` 주석을 소스코드 파일에 추가할 때 문서화 개발과정이 시작된다: `roxygen` 주석은 `#'`으로 시작되어 일반 주석(`#`)과 구분된다. 다음에 간단한 함수에 대한 문서 예제가 있다:

```{r}
#' Add together two numbers.
#' 
#' @param x A number.
#' @param y A number.
#' @return The sum of \code{x} and \code{y}.
#' @examples
#' add(1, 1)
#' add(10, 1)
add <- function(x, y) {
  x + y
}
```

Ctrl/Cmd + Shift + D 단축키를 누르면 (혹은 `devtools::document()` 명령어를 실행하면) 다음과 같은 `man/add.Rd` 파일이 생성된다:

```
% Generated by roxygen2 (4.0.0): do not edit by hand
\name{add}
\alias{add}
\title{Add together two numbers}
\usage{
add(x, y)
}
\arguments{
  \item{x}{A number}

  \item{y}{A number}
}
\value{
The sum of \code{x} and \code{y}
}
\description{
Add together two numbers
}
\examples{
add(1, 1)
add(10, 1)
}
```

만약 LaTeX과 친숙하다면, 산출결과가 친숙해 보일 것이다. 왜냐하면 `.Rd` 형식이 LaTeX에 느슨하게 기반하기 때문이다. [R extensions](http://cran.r-project.org/doc/manuals/R-exts.html#Rd-format) 매뉴얼에서 `.Rd` 형식에 관해서 더 많은 정보를 얻을 수 있다. 파일 최상단 주석에 주목하라: 코드로 자동 생성되어서 변경되지 말아야 된다. 사실 `roxygen2`를 사용한다면, 거의 이런 파일을 열어 볼 필요는 없다.

`?add`, `help("add")`, 혹은 `example("add")` 명령어를 사용하면, R은 일단 `\alias{"add"}`가 포함하는 `.Rd` 파일을 찾는다. 그리고 나서, 파일을 파싱하고, HTML로 전환하고 화면에 출력한다.
RStudio에서 출력되는 결과가 나와 있다:


```{r, echo = FALSE}
bookdown::embed_png("screenshots/man-add.png", dpi = 220)
```

(`devtools`가 일반 도움말 함수에 우선하기 때문에 개발 문서를 미리보기 할 수 있다는 것에 주목한다.
만약 문서가 나타나지 않는다면, `devtools`를 사용하고 있는지 `devtools::load_all()` 명령어로 팩키지를 적재했는지 확인한다.)

## 문서화 작업흐름 다른 대안 {#man-workflow-2}

첫 문서화 작업흐름은 매우 빠르지만, 한가지 한계가 있다: 미리보기 문서 페이지에 페이지 사이에 어떤 링크도 보여주지 않는다. 만약 연결된 링크도 볼려면, 다음 작업흐름을 사용한다:

1. `roxygen` 주석을 작성한 `.R` 파일에 추가한다.

1. `build` 창에서 `r bookdown::embed_png("screenshots/build-reload.png", dpi = 220)`을 클릭하거나 Ctrl/Cmd + Shift + B 단축키를 누른다. 이 과정을 통해서 팩키지를 완전히 다시 빌드한다. 여기에는 모든 문서를 갱신하고, 문서를 정규 라이브러리에 설치하고 나서 R을 다시 시작하고 팩키지를 다시 적재한다. 느리지만 빈틈없다.

1. `?` 명령어로 문서를 미리보기(preview) 한다.

1. 문서가 원하는 대로 작업이 될 때까지 반복작업한다.

만약 상기 작업흐름이 동작하지 않는 것처럼 보인다면, RStudio에 프로젝트 선택옵션을 점검한다. 이전 `devtools`와 RStudio에서 팩키지가 다시 빌드될 때 문서를 자동으로 갱신하지 못하는 오류가 있다:

```{r, echo = FALSE}
bookdown::embed_png("screenshots/build-reload-opts-2.png", dpi = 220)
```

## `Roxygen` 주석 {#roxygen-comments}

Roxygen 주석은 `#'`으로 시작하고, 함수 앞에 놓인다.
함수에 앞선 모든 roxygen 행을 __블록(block)__이라고 한다.
각 행도 코드와 동일하게 일반적으로 문자 80자에 맞춰야 된다.

블록은 `@tagName details`처럼 __태그(tags)__로 쪼개진다. 
해당 태그 내용은 태그 명칭 끝에서부터 다음 태그 시작까지(혹은 블록 끝까지) 범위를 갖는다. `@` 기호가 roxygen에서 특별한 의미를 갖기 때문에, `@`를 문자 그대로 추가하려면
`@@`로 표현한다. (전자우편주소와 S4 객체 슬롯에 접근하는데 대체로 사용된다).

각 블록은 첫 태그[^1] 앞에 텍스트를 포함한다. 이것을 __소개(introduction)__라고 부르고, 특별하게 파싱된다:


* 첫 _문장(sentence)_는 문서 제목이 된다. `help(package = mypackage)` 명령어를 실행했을 때 보는 것이고, 각 도움말 파일 상단에 나타난다. 한 줄에 맞춰야 되고, 각 단어는 대문자로 표현되고, 마침표로 끝나야 된다.


* 두번째 _문단(paragraph)_은 기술이다: 문서 처음에 나오고, 간략하게 함수가 __무엇(what)__을 수행하는지 기술해야 한다.
  
* 세번째 그리고 후속 _문단(paragraphs)_은 상세로 들어간다: 인자 기술 다음에 나타나는
  (종종 장문) 부문으로 함수가 __어떻게(how)__ 동작하는지 상세한 내용이 나와있다.

모든 객체는 제목(title)과 기술(description)을 가져야만 된다. 상세 내용(detail)은 선택옵션이다.

`roxygen`으로 작성한다면, `sum()` 함수에 대한 소개가 어떤 느낌이 다음에 예제로 나와 있다:

```{r}
#' Sum of vector elements.
#' 
#' \code{sum} returns the sum of all the values present in its arguments.
#' 
#' This is a generic function: methods can be defined for it directly or via the
#' \code{\link{Summary}} group generic. For this to work properly, the arguments
#' \code{...} should be unnamed, and dispatch is on the first argument.
sum <- function(..., na.rm = TRUE) {}
```

`\code{}`와 `\link{}`는 [formatting](#text-formatting)에서 학습할 서식 명령어(formatting commands)다. 조심스럽게 `roxygen` 블록을 감싸서 문자 80자를 넘지않게 했다. RStudio에서 Ctrl/Cmd + Shift + / 명령어를 사용해서 자동으로 맞추게 한다. (혹은 메뉴에서 code | re-flow comment을 사용한다).

`@section` 태그로 임의 절(section)을 문서에 추가할 수도 있다.
이것이 유용한 이유는 상세한 설명을 담고 있는 장문 절을 도움되는 표제를 갖는 다수 덩어리로 쪼갤 수 있게 한다. 절 제목 각 단어는 대문자로 표현되고, 콜론이 다음에 오고, 한줄 길이로 표현될 수 있다.

```{r}
#' @section Warning:
#' Do not operate heavy machinery within 8 hours of using this function.
```

도움말 파일 사이를 쉽게 돌아다니게 도움이 되는 태그가 두개 있다:


* `@seealso` 태그는 `\url{http://www.r-project.org}` 웹상에, 
  `\code{\link{functioname}}` 팩키지에, `\code{\link[packagename]{functioname}}` 
  또 다른 팩키지에 다른 유용한 교재를 알려준다.
   
* 만약 연관된 함수군으로 모든 함수가 해당 군의 다른 모든 함수에 연관되어 있다면, `@family`을 사용한다. `@family` 값은 복수형이다.

합계(sum) 함수에 대해서, 상기 구성요소는 다음과 같다:

```{r}
#' @family aggregate functions
#' @seealso \code{\link{prod}} for products, \code{\link{cumsum}} for cumulative
#'   sums, and \code{\link{colSums}}/\code{\link{rowSums}} marginal sums over
#'   high-dimensional arrays.
```

다른 태그 두개로 사용자가 문서를 더 쉽게 찾을 수 있게 돕는다:

*   `@aliases alias1 alias2 ...` 태그는 주제(topic)에 추가적인 별명(alias)을 추가한다.
    별명은 `?`으로 사용될 수 있는 주제에 대한 또다른 명칭이다.

*   `@keywords keyword1 keyword2 ...` 태그는 표준화된 키워드를 추가한다.
    키워드는 선택옵션이다. 하지만, 만약 키워드가 있다면, `file.path(R.home("doc"), "KEYWORDS")` 명령어로 찾아지는 사전 정의된 목록에서 뽑혀진다.

    일반적으로, 키워드는 `@keywords internal` 예외를 제외하면 그다지 유용하지 않다.
    내부 키워드를 사용하게 되면 팩키지 인덱스에서 함수를 제거하고 
    테스트 자동화 일부가 비활성화된다. 대부분의 일반 사용자가 아니라 
    작성된 팩키지를 확장하려는 다른 개발자에게 흥미로운 함수에 대해서 
    `@keywords internal`을 사용하는 것이 일반적이다.
    
다른 태그는 상황에 따라 다르다: 문서화하는 객체 유형에 다양하게 나타난다.
다음 절에서 가장 흔하게 사용되는 태그를 기술한다: 함수, 팩키지, 세가지 R OO 시스템에서 사용되는 다양한 메쏘드, 제네릭, 객체.

## 함수 문서화 {#man-functions}

함수는 가장 흔하게 문서화되는 객체다.
소개 블록뿐만 아니라, 대부분의 함수는 태그를 세개 갖는다: `@param`, `@examples`, `@return`.


*   `@param name description` describes the function's inputs or parameters.
    The description should provide a succinct summary of the type of the
    parameter (e.g., string, numeric vector) and, if not obvious from
    the name, what the parameter does. 
    
    The description should start with a capital letter and end with a full stop. 
    It can span multiple lines (or even paragraphs) if necessary. All 
    parameters must be documented.

    You can document multiple arguments in one place by separating
    the names with commas (no spaces). For example, to document both
    `x` and `y`, you can write `@param x,y Numeric vectors.`.

*   `@examples` provides executable R code showing how to use the function in
    practice. This is a very important part of the documentation because
    many people look at the examples first. Example code must work without 
    errors as it is run automatically as part of `R CMD check`.

    For the purpose of illustration, it's often useful to include code
    that causes an error. `\dontrun{}` allows you to include code in the
    example that is not run. (You used to be able to use `\donttest{}` for
    a similar purpose, but it's no longer recommended because it actually
    __is__ tested.)

    Instead of including examples directly in the documentation, you can
    put them in separate files and use `@example path/relative/to/packge/root`
    to insert them into the documentation.

*   `@return description` describes the output from the function. This is
    not always necessary, but is a good idea if your function returns different 
    types of output depending on the input, or if you're returning an S3, S4 or 
    RC object.

We could use these new tags to improve our documentation of `sum()` as follows:

```{r}
#' Sum of vector elements.
#'
#' \code{sum} returns the sum of all the values present in its arguments.
#'
#' This is a generic function: methods can be defined for it directly
#' or via the \code{\link{Summary}} group generic. For this to work properly,
#' the arguments \code{...} should be unnamed, and dispatch is on the
#' first argument.
#'
#' @param ... Numeric, complex, or logical vectors.
#' @param na.rm A logical scalar. Should missing values (including NaN)
#'   be removed?
#' @return If all inputs are integer and logical, then the output
#'   will be an integer. If integer overflow
#'   \url{http://en.wikipedia.org/wiki/Integer_overflow} occurs, the output
#'   will be NA with a warning. Otherwise it will be a length-one numeric or
#'   complex vector.
#'
#'   Zero-length vectors have sum 0 by definition. See
#'   \url{http://en.wikipedia.org/wiki/Empty_sum} for more details.
#' @examples
#' sum(1:10)
#' sum(1:5, 6:10)
#' sum(F, F, F, T, T)
#'
#' sum(.Machine$integer.max, 1L)
#' sum(.Machine$integer.max, 1)
#'
#' \dontrun{
#' sum("a")
#' }
sum <- function(..., na.rm = TRUE) {}
```

Indent the second and subsequent lines of a tag so that when scanning the documentation it's easy to see where one tag ends and the next begins. Tags that always span multiple lines (like `@example`) should start on a new line and don't need to be indented.

## Documenting datasets {#man-data}

See [documenting data](#documenting-data).

## Documenting packages {#man-packages}

You can use roxygen to provide a help page for your package as a whole. This is accessed with `package?foo`, and can be used to describe the most important components of your package. It's a useful supplement to vignettes, as described in the next chapter. 

There's no object that corresponds to a package, so you need to document `NULL`, and then manually label it with `@docType package` and `@name <package-name>`. This is also an excellent place to use the `@section` tag to divide up page into useful categories.

```{r}
#' foo: A package for computating the notorious bar statistic.
#'
#' The foo package provides three categories of important functions:
#' foo, bar and baz.
#' 
#' @section Foo functions:
#' The foo functions ...
#'
#' @docType package
#' @name foo
NULL
```

I usually put this documentation in a file called `<package-name>.R`. It's also a good place to put the package level import statements that you'll learn about in [imports](#imports).

## Documenting classes, generics and methods {#man-classes}

It's relatively straightforward to document classes, generics and methods. The details vary based on the object system you're using. The following sections give the details for the S3, S4 and RC object systems.

### S3 {#man-s3}

S3 __generics__ are regular functions, so document them as such. S3 __classes__ have no formal definition, so document the constructor function. It is your choice whether or not to document S3 __methods__. You don't need to document methods for simple generics like `print()`. But if your method is more complicated or includes additional arguments, you should document it so people know how it works. In base R, you can see examples of documentation for more complex methods like `predict.lm()`, `predict.glm()`, and `anova.glm()`.

Older versions of roxygen required explicit `@method generic class` tags for all S3 methods. From version 3.0.0 onward, this is no longer needed as roxygen2 will figure it out automatically. If you are upgrading, make sure to remove these old tags. Automatic method detection will only fail if the generic and class are ambiguous. For example is `all.equal.data.frame()` the `equal.data.frame` method for `all`, or the `data.frame` method for `all.equal`?. If this happens, you can disambiguate with e.g. `@method all.equal data.frame`.

### S4 {#man-s4}

Document __S4 classes__ by adding a roxygen block before `setClass()`. Use `@slot` to document the slots of the class in the same way you use `@param` to describe the parameters of a function. Here's a simple example:

```{r}
#' An S4 class to represent a bank account.
#'
#' @slot balance A length-one numeric vector
Account <- setClass("Account",
  slots = list(balance = "numeric")
)
```

S4 __generics__ are also functions, so document them as such. S4 __methods__ are a little more complicated, however. Unlike S3, all S4 methods must be documented. You document them like a regular function, but you probably don't want each method to have its own documentation page. Instead, put the method documentation in one of three places:

* In the class. Most appropriate if the corresponding generic uses single
  dispatch and you created the class.

* In the generic. Most appropriate if the generic uses multiple dispatch
  and you have written both the generic and the method.

* In its own file. Most appropriate if the method is complex, or if
  you've written the method but not the class or generic.

Use either `@rdname` or `@describeIn` to control where method documentation goes. See [documenting multiple objects in one file](#multiple-man) for details.

Another consideration is that S4 code often needs to run in a certain order. For example, to define the method `setMethod("foo", c("bar", "baz"), ...)` you must already have created the `foo` generic and the two classes. By default, R code is loaded in alphabetical order, but that won't always work for your situation. Rather than relying on alphabetic ordering, roxygen2 provides an explicit way of saying that one file must be loaded before another: `@include`. The `@include` tag gives a space separated list of file names that should be loaded before the current file:

```{r, eval = FALSE}
#' @include class-a.R
setClass("B", contains = "A")
```

Often, it's easiest to put this at the top of the file. To make it clear that this tag applies to the whole file, and not a specific object, document `NULL`.

```{r, eval = FALSE}
#' @include foo.R bar.R baz.R
NULL

setMethod("foo", c("bar", "baz"), ...)
```

Roxygen uses the `@include` tags to compute a topological sort which ensures that dependencies are loaded before they're needed. It then sets the `Collate` field in `DESCRIPTION`, which overrides the default alphabetic ordering. A simpler alternative to `@include` is to define all classes and methods in `aaa-classes.R` and `aaa-generics.R`, and rely on these coming first since they're in alphabetical order. The main disadvantage is that you can't organise components into files as naturally as you might want.

Older versions of roxygen2 required explicit `@usage`, `@alias` and `@docType` tags for document S4 objects. However, as of version 3.0.0, roxygen2 generates the correct values automatically so you no longer need to use them. If you're upgrading from an old version, you can delete these tags.

### RC {#man-rc}

Reference classes are different to S3 and S4 because methods are associated with classes, not generics. RC also has a special convention for documenting methods: the __docstring__. The docstring is a string placed inside the definition of the method which briefly describes what it does. This makes documenting RC simpler than S4 because you only need one roxygen block per class.

```{r}
#' A Reference Class to represent a bank account.
#'
#' @field balance A length-one numeric vector.
Account <- setRefClass("Account",
  fields = list(balance = "numeric"),
  methods = list(
    withdraw = function(x) {
      "Withdraw money from account. Allows overdrafts"
      balance <<- balance - x
    }
  )
)
```

Methods with doc strings will be included in the "Methods" section of the class documentation. Each documented method will be listed with an automatically generated usage statement and its doc string. Also note the use of `@field` instead of `@slot`.

## Special characters {#man-special}

There are three special characters that need special handling if you want them to appear in the final documentation:

* `@`, which usually marks the start of a roxygen tag. Use `@@` to insert a
  literal `@` in the final documentation.
  
* `%`, which usually marks the start of a latex comment which continues to the
  end of the line. Use `\%` to insert a literal `%` in the output document. 
  The escape is not needed in examples.
  
* `\`, which usually marks the start of a latex escaping. Use `\\` to 
  insert a literal `\` in the documentation.

## Do repeat yourself {#dry2}

There is a tension between the DRY (don't repeat yourself) principle of programming and the need for documentation to be self-contained. It's frustrating to have to navigate through multiple help files in order to pull together all the pieces you need. Roxygen2 provides two ways to avoid repetition in the source, while still assembling everything into one documentation file:

* The ability to reuse parameter documentation with `@inheritParams`.

* The ability to document multiple functions in the same place with 
  `@describeIn` or `@rdname`

### Inheriting parameters from other functions

You can inherit parameter descriptions from other functions using `@inheritParams source_function`. This tag will bring in all documentation for parameters that are undocumented in the current function, but documented in the source function. The source can be a function in the current package, via `@inheritParams function`, or another package, via `@inheritParams package::function`. For example the following documentation:

```{r}
#' @param a This is the first argument
foo <- function(a) a + 10

#' @param b This is the second argument
#' @inheritParams foo
bar <- function(a, b) {
  foo(a) * 10
}
```

is equivalent to

```{r}
#' @param a This is the first argument
#' @param b This is the second argument
bar <- function(a, b) {
  foo(a) * 10
}
```

Note that inheritance does not chain. In other words, the `source_function` must always be the function that defines the parameter using `@param`.

### Documenting multiple functions in the same file {#multiple-man}

You can document multiple functions in the same file by using either `@rdname` or `@describeIn`. However, it's a technique best used with caution: documenting too many functions in one place leads to confusing documentation. You should use it when functions have very similar arguments, or have complementary effects (e.g., `open()` and `close()` methods).

`@describeIn` is designed for the most common cases:

* Documenting methods in a generic.
* Documenting methods in a class.
* Documenting functions with the same (or similar arguments).

It generates a new section, named either "Methods (by class)", "Methods (by generic)" or "Functions". The section contains a bulleted list describing each function. They're labelled so that you know what function or method it's talking about. Here's an example, documenting an imaginary new generic:

```{r}
#' Foo bar generic
#'
#' @param x Object to foo.
foobar <- function(x) UseMethod("foobar")

#' @describeIn foobar Difference between the mean and the median
foobar.numeric <- function(x) abs(mean(x) - median(x))

#' @describeIn foobar First and last values pasted together in a string.
foobar.character <- function(x) paste0(x[1], "-", x[length(x)])
```

An alternative to `@describeIn` is `@rdname`. It overrides the default file name generated by roxygen and merges documentation for multiple objects into one file. This gives you the complete freedom to combine documentation as you see fit. 

There are two ways to use `@rdname`. You can add documentation to an existing function:

```{r}
#' Basic arithmetic
#'
#' @param x,y numeric vectors.
add <- function(x, y) x + y

#' @rdname add
times <- function(x, y) x * y
```

Or, you can create a dummy documentation file by documenting `NULL` and setting an informative `@name`.

```{r}
#' Basic arithmetic
#'
#' @param x,y numeric vectors.
#' @name arith
NULL

#' @rdname arith
add <- function(x, y) x + y

#' @rdname arith
times <- function(x, y) x * y
```

## Text formatting reference sheet {#text-formatting}

Within roxygen tags, you use `.Rd` syntax to format text. This vignette shows you examples of the most important commands. The full details are described in [R extensions](http://cran.r-project.org/doc/manuals/R-exts.html#Marking-text).

Note that `\` and `%` are special characters in the Rd format. To insert a literal `%` or `\`, escape them with a backslash `\\`, `\%`.

### Character formatting

* `\emph{italics}`: _italics_.

* `\strong{bold}`: __bold__.

* `\code{r_function_call(with = "arguments")}`: 
  `r_function_call(with = "arguments")` (format inline code)

* `\preformatted{}`: format text as-is, can be used for multi-line code

### Links

To other documentation:

* `\code{\link{function}}`: function in this package.

* `\code{\link[MASS]{abbey}}`: function in another package.

* `\link[=dest]{name}`: link to dest, but show name.

* `\linkS4class{abc}`: link to an S4 class.

To the web:

* `\url{http://rstudio.com}`: a url.

* `\href{http://rstudio.com}{Rstudio}`:, a url with custom link text.

* `\email{hadley@@rstudio.com}` (note the doubled `@`): an email address.

### Lists

* Ordered (numbered) lists:

    ```{r}
    #' \enumerate{
    #'   \item First item
    #'   \item Second item
    #' }
    ```

* Unordered (bulleted) lists:

    ```{r}
    #' \itemize{
    #'   \item First item
    #'   \item Second item
    #' }
    ```

* Definition (named) lists:

    ```{r}
    #' \describe{
    #'   \item{One}{First item}
    #'   \item{Two}{Second item}
    #' }
    ```

### Mathematics

You can use standard LaTeX math (with no extensions). Choose between either inline or block display:

* `\eqn{a + b}`: inline equation.

* `\deqn{a + b}`: display (block) equation.

### Tables

Tables are created with `\tabular{}`. It has two arguments:

1. Column alignment, specified by letter for each column (`l` = left, `r` = right,
   `c` = centre.)

2. Table contents, with columns separated by `\tab` and rows by `\cr`.

The following function turns an R data frame into the correct format. It ignores column and row names, but should get you started.

```{r}
tabular <- function(df, ...) {
  stopifnot(is.data.frame(df))

  align <- function(x) if (is.numeric(x)) "r" else "l"
  col_align <- vapply(df, align, character(1))

  cols <- lapply(df, format, ...)
  contents <- do.call("paste",
    c(cols, list(sep = " \\tab ", collapse = "\\cr\n  ")))

  paste("\\tabular{", paste(col_align, collapse = ""), "}{\n  ",
    contents, "\n}\n", sep = "")
}

cat(tabular(mtcars[1:5, 1:5]))
```

### Notes
[^1]: `@title`와 `@description` 태그를 사용해서 암묵적이기 보다 명시적으로 제목과 기술을 갖는 "소개(introduction)" 절을 정의하는 것이 가능하다는 것에 주목한다.
다른 많은 팩키지 저자가 하듯이 이것을 피하는 관례를 저자는 따른다. 그래서 저자는 추천하지 않는다 - 하지만, 이러한 태그가 존재와 다른 팩키지 저작자 소스 코드에 나타날 수 있다는 것을 인지해야 한다.


