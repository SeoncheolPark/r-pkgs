---
title: R code
layout: default
output: bookdown::html_chapter
---

# R 코드 {#r}

팩키지 사용 첫번째 원칙은 모든 R 코드는 `R/` 디렉토리에 들어간다.
이번 장에서, `R/` 디렉토리를 학습하고, 함수를 파일로 정리하는 저자 나름의 방식을 추천하고, 좋은 스타일에 대한 일반적인 비법을 전수한다. 또한, 팩키지에 담기는 함수와 스크립트 함수 사이에 중요한 차이점도 학습할 것이다.


## R 코드 작업흐름(workflow) {#r-workflow}

팩키지를 사용하면 생기는 첫번째 실질적인 장점은 코드를 다시 적재하기 쉽다는 것이다.
`devtools::load_all()` 명령어를 실행하던가, RStudio에서 __Ctrl/Cmd + Shift + L__ 키를 누르게 되면 키입력 횟수도 줄고 열린 모든 파일을 저장할 수도 있다.

키보드 단축키를 활용으로 물 흐르듯한 개발 작업흐름이 된다:


1. R 파일을 편집한다.

1. Ctrl/Cmd + Shift + L 키를 누른다.

1. 콘솔에 코드를 탐색한다.

1. 코드를 깔끔하게 만들고, 과정을 반복한다.

축하합니다! 방금 첫번째 팩키지 개발 작업흐름을 학습했다. 
이 책에서 다른 어떤 것도 학습하지 못했을 지라도, R 코드를 편집하고 다시 적재하는 유용한 작업흐름(workflow)을 얻었다.


## 함수 정리하기 {#r-organising}

자유로이 함수를 파일에 정리할 수 있지만, 양 극단은 좋지 않다: 모든 함수를 파일 하나에 담거나, 각각의 함수를 별도 파일에 담는 것이다. (예외적인 상황으로 함수가 크거나 함수에 따린 문서가 많은 경우에 일부 파일이 함수 하나를 담을 수 있다) 파일 명칭은 유의미해야 하며, `.R`로 끝나야 된다.

```{r, eval = FALSE}
# 좋은 사례
fit_models.R
utility_functions.R

# 나쁜 사례
foo.r
stuff.r
```

개발자를 포함해서 동료 일부가 대소문자를 구분하는 파일 시스템을 갖는 운영체제(예를 들어, 마이크로소프트 윈도우 혹은 OS X) 때문에 대문자 사용에 주의한다. 단지 대문자만 다른 파일명칭을 사용하지 않아서 생기는 문제를 피하라.

저자 경험치에 따르면, 함수가 담기 파일 이름을 기억할 수가 없다면, 함수를 더 많은 파일로 쪼개던가 더 나은 기억하기 좋은 이름을 부여한다. (불행하게도 `R/` 내부에 하위디렉토리를 사용할 수는 없다. 차선책은 공통된 접두어를 사용하는 것으로 예를 들어, `abc-*.R`과 같다.)

만약 함수 정의로 바로 건너뛸 수 있는 RStudio 단축키 두개를 익힌다면 파일 내부 함수 정렬은 그다지 중요하지 않게 된다:

*   코드에 함수 명칭을 클릭하고 __F2__키를 누른다.

*   __Ctrl + .__ 키를 누루고 나서 명칭을 타이핑한다:

    ```{r, echo = FALSE}
    bookdown::embed_png("screenshots/file-finder.png", dpi = 220)
    ```

상기 방식중 하나를 사용해서 함수를 살펴본 다음에 편집기 상단 (`r bookdown::embed_png("screenshots/arrows.png", dpi = 240)`) 역방향 화살표를 클릭하거나 Ctrl/Cmd-F9 키를 눌러 되돌아 간다.

## 코드 스타일 (Code style) {#style}

좋은 코딩 스타일은 마치 올바른 구두점을 사용하는 것과 같다.
코딩 가이드 없이도 개발하는데 지장은 없지만, 코드를 훨씬 읽기 쉽게 하는 것은 사실이다.
구두점 스타일과 마찬가지로 다양한 변형이 있다. 다음 안내서에는 저자가 사용하는 스타일(이책 및 개발 팩키지에 적용)을 기술하고 있다. 구글 [R 스타일 안내서(R style guide)](https://google-styleguide.googlecode.com/svn/trunk/Rguide.xml)에 기반하여 일부 변형하여 사용하고 있다.

저자 스타일을 반듯이 사용할 필요는 없지만, 일관된 스타일을 사용해서 문서화하는 것을 강력히 추천한다.
만약 다른 개발자 작성한 코드에 작업한다면, 본인 스타일을 강제하지 마라. 대신에 다른 개발자 스타일 문서를 읽고 가능하면 가깝게 지킨다.

좋은 스타일은 중요한데 이유는 한 사람이 코드를 개발했다고 하더라도, 대체로 코들 읽는 독자는 다수다.
이러한 점은 특히 여러명과 공동작업을 할 때 더욱 그렇다.
이런 경우, 공통된 스타일을 앞서 선정하는 것은 좋은 생각이다.
어떤 스타일도 다른 스타일보다 엄밀한 의미에서 더 나을 수가 없기 때문에,
다른 사람과 함께 작업하는 것이 함의하는 것은 가장 좋아하는 자신만의 스타일 일부를 희생할 필요도 생긴다는 것이다.

Yihui Xie가 개발한 `formatR` 팩키지를 사용해서 형식이 엉망인 코드를 쉽게 깔끔하게 만든다.
팩키지가 모든 것을 수행하는 것은 아니지만, 엉망인 코드에서 매우 좋은 코드로 빨리 전환되게 할 수 있다.
팩키지를 사용하기 전에 [웹사이트 주의사항](http://yihui.name/formatR/)을 확실히 읽고 진행한다.
사용법은 쉽다:

```{r, eval = FALSE}
install.packages("formatR")
formatR::tidy_dir("R")
```

보완적인 접근법은 __코드 린터(linter)__를 사용하는 것이다.
자동으로 문제를 고쳐주기 보다는 코드린터는 문제에 대한 경고만 준다.
Jim Hester가 작성한 `lintr` 팩키지는 코딩 스타일 안내서 준수도를 점검하고 빠뜨린 점이 어딘지 알려준다.
`formatR`과 비교하여, `lintr`이 더 많은 잠재적 문제를 집어낸다. (이유는 문제를 고칠 필요가 없이 지적만 하면 되기 때문이다.) 하지만, 여전히 거짓 양성(false positives) 반응이 남아있다.


```{r, eval = FALSE}
install.packages("lintr")
lintr::lint_package()
```

### 객체 명칭

변수명칭과 함수명칭은 모두 소문자여야 한다.
명칭 내부 단어를 구분할 때는 밑줄(`_`)을 사용한다. 낙타대문자(Camel Case)는 적법한 대안이지만, 일관성을 갖춰라! 일반적으로 변수명칭은 명사, 함수명칭은 동사다. 간결하고 유의미한 작명에 노력하라 (쉽지 않아요!)

```{r, eval = FALSE}
# 좋은 사례
day_one
day_1

# 나쁜 사례
first_day_of_the_month
DayOne
dayone
djm1
```

가능하면, 기존 함수명과 변수명 사용을 자제하라.
코드를 읽는 독자에게 혼란을 줄 수 있다.

```{r, eval = FALSE}
# Bad
T <- FALSE
c <- 10
mean <- function(x) sum(x)
```

### 공백(Spacing)

`=`, `+`, `-`, `<-` 등 모든 이항 연산자(dyadic, infix operator) 주위는 공백을 둔다.
함수 호출에 `=`을 사용할 때도 동일한 규칙이 적용된다.
항상 콤마 뒤에는 공백을 두고, 일반적인 영어와 마찬가지로 앞에는 공백을 두지 않는다.

```{r, eval = FALSE}
# 좋은 사례
average <- mean(feet / 12 + inches, na.rm = TRUE)

# 나쁜 사례
average<-mean(feet/12+inches,na.rm=TRUE)
```

상기 규칙에 일부 예외가 있다: `:`, `::`, `:::`은 앞뒤로 공백이 필요없다.
(만약 아직 `::` 혹은 `:::`을 보지 못했다면, 걱정하지 마라 - [namespaces](#namespace)에서 학습할 것이다.)

```{r, eval = FALSE}
# Good
x <- 1:10
base::get

# Bad
x <- 1 : 10
base :: get
```

함수 호출을 제외하고, 왼쪽 괄호 앞에 공백을 둔다.

Place a space before left parentheses, except in a function call.

```{r, eval = FALSE}
# 좋은 사례
if (debug) do(x)
plot(x, y)

# 나쁜 사례
if(debug)do(x)
plot (x, y)
```

등호 혹은 대입(`<-`)할 때 일직선을 이룬다면, 여분의 공백(예를 들어, 연이은 공백인 경우)도 괜찮다. 

```{r, eval = FALSE}
list(
  total = a + b + c, 
  mean  = (a + b + c) / n
)
```

(콤마가 있지 않는다면) 괄호나 꺾쇠 괄호 내부 코드에 공백을 두지 않는다.

Do not place spaces around code in parentheses or square brackets (unless there's a comma, in which case see above).

```{r, eval = FALSE}
# 좋은 사례
if (debug) do(x)
diamonds[5, ]

# 나쁜 사례
if ( debug ) do(x)  # debug 앞뒤로 공백이 없어야 한다.
x[1,]   # 콤마 다음에 공백이 필요하다.
x[1 ,]  # 공백이 콤마 앞이 아닌 뒤에 와야 한다.
```

### 중괄호

여는 중괄호는 그 자체로 독립된 행을 구성하지 못하고 다음에는 항상 새줄이 시작된다.
`else`가 다음에 오지 않는다면, 닫는 중괄호는 그 자체로 독립된 행을 구성한다. 

항상 중괄호 내부 코드는 들여쓰기한다.

```{r, eval = FALSE}
# 좋은 사례

if (y < 0 && debug) {
  message("Y is negative")
}

if (y == 0) {
  log(x)
} else {
  y ^ x
}

# 나쁜 사례

if (y < 0 && debug)
message("Y is negative")

if (y == 0) {
  log(x)
} 
else {
  y ^ x
}
```

매우 짫은 문장을 동일한 행에 두는 것은 괜찮다:

```{r, eval = FALSE}
if (y < 0 && debug) message("Y is negative")
```

### 줄 길이 (Line length)

코드를 매 줄마다 문자 80개 이하로 만들어라.
이렇게 하면 일반적인 폰트 크기에 맞춰 출력도 괜찮다.
만약 여분의 공간이 부족하다고 느껴진다면, 별도 함수에 작업 일부를 캡슐화해야 된다는 좋은 표식이 된다.

### 들여쓰기 (Indentation)

코드를 들여쓰기 할 때, 공백을 두개 사용한다.
결코 탭 혹은 탭과 공백을 섞어 사용하지 마라.
코드 환경설정 창(code preference pane)에서 선택 옵션을 변경하라:

```{r, echo = FALSE}
bookdown::embed_png("screenshots/style-options.png", dpi = 220)
```

유일한 예외는 몇줄에 걸쳐 함수를 정의할 때다.
이 경우에, 두번째 줄을 함수가 시작하는 곳까지 들여쓴다:

```{r, eval = FALSE}
long_function_name <- function(a = "a long argument", 
                               b = "another argument",
                               c = "another long argument") {
  # As usual code is indented by two spaces.
}
```

### 대입(Assignment)

대입에는 `=` 대신, `<-`을 사용한다.

```{r}
# Good
x <- 5
# Bad
x = 5
```

### 주석 안내서 지침

코드에 주석을 단다.
주석 각 행은 주석 표식자(`# `)와 공백 하나로 시작한다.
주석은 무엇(what)이 아니고 이유(why)를 설명해야 한다. \index{comments}

`-` 와 `=` 으로 구성된 주석 행을 사용해서 파일을 가독성이 높은 코드 덩어리로 쪼갠다.

```{r, eval = FALSE}
# Load data ---------------------------

# Plot data ---------------------------
```

## 최상단 코드 {#r-differences}

지금까지 아마도 `source()` 명령어로 로딩되는 파일에 저장된 R 코드 즉, __스크립트(scripts)__를 작성해봣ㅇ르 것이다. 스크립트 코드와 팩키지 코드 사이에는 두가지 주된 차이가 있다:

* 스크립트는 코드가 적재될 때 실행된다. 팩키지에서 코드는 빌드될 때 실행된다.
  즉, 팩키지 코드는 대부분 함수로 이루어진 객체를 생성해야 되다는 의미다.

* 팩키지에 함수는 개발자가 상상하지 못한 상황에서 사용될 것이다.
  즉, 외부 세계와 상호작용할 수 있는 방식으로 함수는 사려깊이 개발될 필요가 있다.

다음 두절에 걸쳐 이러한 중요한 차이점을 상세히 다룬다.

### 코드 적재

`source()` 명령어로 스크립트를 적재하면, 모든 코드 라인은 실행되고 결과는 즉시 생성되어 이용가능하게 된다. 팩키지에는 차이가 있는데 이유는 두 단계로 적재되기 때문이다.
팩키지가 빌드될 때(예를 들어, CRAN에 의해), `R/` 디렉토리에 있는 코드가 실행되고 결과가 저장된다.
`library()` 혹은 `require()` 명령어로 팩키지가 적재될 때, 캐쉬된 결과가 사용자에게 생성되어 이용가능하게 된다. 만약 팩키지와 동일한 방식으로 스크립트를 적재한다면, 코드는 다음과 같을 것이다:


```{r, eval = FALSE}
# 스크립트를 신규 환경에 적재하고 저장한다.
env <- new.env(parent = emptyenv())
source("my-script.R", local = env)
save(envir = env, "my-script.Rdata")

# 또다른 R 세션에서 추후 적재
load("my-script.Rdata")
```

예를 들어, `x <- Sys.time()`을 사용해 보자.
만약 스크립트에 명령어를 넣으면, 스크립트가 `source()` 되는 시점 정보를 `x`가 알려준다.
하지만, 만약 팩키지에 동일 코드를 넣으면, `x`는 어느 시점에 _빌드_되는지 알려준다.

상기 실험결과가 갖는 의미는 팩키지 최상위 수준에서 코드를 결코 실행하지 말아야 한다: 팩키지 코드는 대부분 함수인, 객체를 생성해야만 한다. 예를 들어, `foo` 팩키지가 다음 코드를 담고 있다고 가정하자:


```{r, eval = FALSE}
library(ggplot2)

show_mtcars <- function() {
  qplot(mpg, wt, data = mtcars)
}
```

만약 누군가 다음과 같이 실행하려고 한다면:

```{r, eval = FALSE}
library(foo)
show_mtcars()
```

코드는 결코 작동하지 않는데, 이유는 ggplot2 팩키지 `qplot()` 함수를 이용할 수 없기 때문이다: 
`library(foo)` 라이브러리가 `library(gpplot2)`을 재실행하지 않기 때문이다.
팩키지 최상단 R 코드는 팩키지가 적재될 때가 아닌 빌드될 때만 실행된다.

상기 문제를 비겨가기 위해서, 다음과 같이 코드를 작성하고 싶은 유혹이 있을지도 모른다:

```{r, eval = FALSE}
show_mtcars <- function() {
  library(ggplot2)
  qplot(mpg, wt, data = mtcars)
}
```

또한, 아래에서 알 수 있듯이, 문제 소지가 다분히 있다.
대신에 `DESCRIPTION` 파일에 코드가 필요한 팩키지를 기술한다. [package dependencies](#dependencies)에서 학습할 예정이다.

### The R landscape

스크립트와 팩키지 사이 또다른 큰 차이점은 

Another big difference between a script and a package is that other people are going to use your package, and they're going to use it in situations that you never imagined. This means you need to pay attention to the R landscape, which includes not just the available functions and objects, but all the global settings. You have changed the R landscape if you've loaded a package with `library()`, or changed a global option with `options()`, or modified the working directory with `setwd()`. If the behaviour of _other_ functions differs before and after running your function, you've modified the landscape. Changing the landscape is bad because it makes code much harder to understand. 

There are some functions that modify global settings that you should never use because there are better alternatives:

* __Don't use `library()` or `require()`__. These modify the search path, 
  affecting what functions are available from the global environment. 
  It's better to use the `DESCRIPTION` to specify your package's requirements, 
  as described in the next chapter. This also makes sure those packages are 
  installed when your package is installed.
  
* __Never use `source()`__ to load code from a file. `source()` modifies the
  current environment, inserting the results of executing the code. Instead, rely 
  on `devtools::load_all()` which automatically sources all files in `R/`.
  If you're using `source()` to create a dataset, instead switch to `data/`
  as described in [datasets](#data).

Other functions need to be used with caution. If you use them, make sure to clean up after yourself with `on.exit()`:

* If you modify global `options()` or graphics `par()`, save the old values 
  and reset when you're done:
  
    ```{r, eval = FALSE}
    old <- options(stringsAsFactors = FALSE)
    on.exit(options(old), add = TRUE)
    ```

* Avoid modifying the working directory. If you do have to change it, make sure
  to change it back when you're done:

    ```{r, eval = FALSE}
    old <- setwd(tempdir())
    on.exit(setwd(old), add = TRUE)
    ```

* Creating plots and printing output to the console are two other ways of
  affecting the global R environment. Often you can't avoid these (because 
  they're important!) but it's good practice to isolate them in functions that
  __only__ produce output. This also makes it easier for other people to 
  repurpose your work for new uses. For example, if you separate data preparation
  and plotting into two functions, others can use your data prep work (which
  is often the hardest part!) to create new visualisations.

The flip side of the coin is that you should avoid relying on the user's landscape, which might be different to yours. For example, functions like `read.csv()` are dangerous because the value of `stringsAsFactors` argument comes from the global option `stringsAsFactors`. If you expect it to be `TRUE` (the default), and the user has set it to be `FALSE`, your code might fail. 

### When you __do__ need side-effects

Occasionally, packages do need side-effects. This is most common if your package talks to an external system --- you might need to do some initial setup when the package loads. To do that, you can use two special functions: `.onLoad()` and `.onAttach()`. These are called when the package is loaded and attached. You'll learn about the distinction between the two in [Namespaces](#namespace). For now, you should always use `.onLoad()` unless explicitly directed otherwise.

Some common uses of `.onLoad()` and `.onAttach()` are:

*   To display an informative message when the package loads. This might make 
    usage conditions clear, or display useful tips. Startup messages is one 
    place where you should use `.onAttach()` instead of `.onLoad()`. To display 
    startup messages, always use `packageStartupMessage()`, and not `message()`. 
    (This allows `suppressPackageStartupMessages()` to selectively suppress 
    package startup messages).

    ```{r, eval = FALSE}
    .onAttach <- function(libname, pkgname) {
      packageStartupMessage("Welcome to my package")
    }
    ```
    
*   To set custom options for your package with `options()`. To avoid conflicts
    with other packages, ensure that you prefix option names with the name
    of your package. Also be careful not to override options that the user
    has already set.
    
    I use the following code in devtools to set up useful options:
    
    ```{r, eval = FALSE}
    .onLoad <- function(libname, pkgname) {
      op <- options()
      op.devtools <- list(
        devtools.path = "~/R-dev",
        devtools.install.args = "",
        devtools.name = "Your name goes here",
        devtools.desc.author = '"First Last <first.last@example.com> [aut, cre]"',
        devtools.desc.license = "What license is it under?",
        devtools.desc.suggests = NULL,
        devtools.desc = list()
      )
      toset <- !(names(op.devtools) %in% names(op))
      if(any(toset)) options(op.devtools[toset])
    
      invisible()
    }
    ```
    
    Then devtools functions can use e.g. `getOption("devtools.name")` to 
    get the name of the package author, and know that a sensible default value
    has already been set.
    
*   To connect R to another programming language. For example, if you use rJava
    to talk to a `.jar` file, you need to call `rJava::.jpackage()`. To
    make C++ classes available as reference classes in R with Rcpp modules,
    you call `Rcpp::loadRcppModules()`. 

*   To register vignette engines with `tools::vignetteEngine()`.


As you can see in the examples, `.onLoad()` and `.onAttach()` are called with two arguments: `libname` and `pkgname`. They're rarely used (they're a holdover from the days when you needed to use `library.dynam()` to load compiled code). They give the path where the package is installed (the "library"), and the name of the package.

If you use `.onLoad()`, consider using `.onUnload()` to clean up any side effects. By convention, `.onLoad()` and friends are usually saved in a file called `zzz.R`. (Note that `.First.lib()` and `.Last.lib()` are old versions of `.onLoad()` and `.onUnload()` and should no longer be used.)
    
### S4 classes, generics and methods

Another type of side-effect is defining S4 classes, methods and generics. R packages capture these side-effects so they can be replayed when the package is loaded, but they need to be called in the right order. For example, before you can define a method, you must have defined both the generic and the class. This requires that the R files be sourced in a specific order. This order is controlled by the `Collate` field in the `DESCRIPTION`. This is described in more detail in [documenting S4](#man-s4).

## CRAN 주의사항 {#r-cran}

(Each chapter will finish with some hints for submitting your package to CRAN. If you don't plan on submitting your package to CRAN, feel free to ignore them!)

If you're planning on submitting your package to CRAN, you must use only ASCII characters in your `.R` files. You can still include unicode characters in strings, but you need to use the special unicode escape `"\u1234"` format. The easiest way to do that is to use `stringi::stri_escape_unicode()`:

```{r}
x <- "This is a bullet •"
y <- "This is a bullet \u2022"
identical(x, y)

cat(stringi::stri_escape_unicode(x))
```
