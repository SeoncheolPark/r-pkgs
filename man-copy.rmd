---
title: Object documentation
layout: default
output: bookdown::html_chapter
---

# 객체 문서화(Documentation) {#man}

문서(Documentation)는 좋은 팩키지가 갖춰야 되는 가장 중요한 측면 중 하나다.
문서가 없다면, 사용자는 여러분이 작성한 팩키지를 어떻게 사용하는지 알 길이 없다.
문서는 또한 미래 당신 즉, 개발자 본인(그래서 작성한 함수가 무슨 기능을 수행하도록 만들어졌는지 기억하기 편하다)에게도 유용하고 팩키지를 확장하려는 다른 개발자에게도 마찬가지다.

문서화에 대한 다수 형태가 존재한다.
이번 장에서 `?` 혹은 `help()` 명령어로 접근하는 객체 문서화에 대해 배울 것이다.
객체 문서화는 일종의 참조 문서다. 마치 사전과 같다: 단어가 의미하는 바를 알고자 한다면 사전이 도움이 될 수 있을지라도, 전혀 새로운 상황에서 올바른 단어를 찾는데는 도움이 되지 못한다. 유사하게, 이미 객체 명칭을 알고 있다면 객체 문서가 도움이 되지만, 주어진 문제 해결책을 찾는데 필요한 객체를 찾는데는 도움이 되지 못한다.
이런 역할을 하는 것이 소품문(vignette)의 역할이고 다음 장에서 학습할 것이다.

팩키지 객체를 문서화하는 표준 방식을 R에서 제공한다: `man/` 디렉토리에 `.Rd` 파일을 작성한다. 이런 파일은 느슨하게 LaTeX에 기반한 사용자 정의 구문(custom syntax)을 사용해서, HTML, 일반 텍스트, pdf로 번역하여 옮겨 볼 수 있다. 수작업으로 파일 각각을 작성하는 대신에, `roxygen2`를 사용해서 특별한 형식으로 된 주석을 `.Rd` 파일로 변환한다. `roxygen2` 목적은 코드 문서화 작업을 가능하면 쉽게 자동화하는데 있다.
`.Rd` 파일을 수작업으로 일일이 작성하는데 비해서 많은 장점을 갖는다:

* 코드와 문서가 섞여있어서, 코드를 변경할 때, 문서도 갱신하도록 상기된다.

* `Roxygen2`가 동적으로 문서화한 객체를 검사한다. 그렇게 함으로써 `Roxygen2`를 사용하지 않는다면 
  수작업으로 작성이 필요한 표준문안(boilerplate) 작업을 건너뛰게 돕는다.
  
* 다른 유형의 객체를 문서화에서 발생하는 차이점을 추상화한다. 
  그렇게 함으로써, 구체적인 사항에 대해서 좀더 덜 학습해도 된다.  

`.Rd` 파일을 생성할 때, `roxygen2`를 사용해서 `DESCRIPTION` 파일에 `NAMESPACE`와 `Collate` 필드를 관리할 수 있다. 이번 장에서 `.Rd` 파일과 `collate` 필드를 다룬다. 
[NAMESPACE](#namespace)에서 `NAMESPACE`를 관리하는데 `roxygen2`를 사용하는 방법을 기술하고, 왜 관심을 가져야 하는지도 살펴본다.

## 문서화 작업흐름(workflow) {#man-workflow}

이번 절에서 전체 문서화 작업흐름에 대한 대략적인 개요를 살펴볼 것이다. 그리고 나서, 개별적으로 각 단계별로 파고든다. 네가지 기본 단계가 있다:

1. `.R` 파일에 `roxygen` 주석을 추가한다.

1. roxygen 주석을 `.Rd` 파일로 변환하는데 `devtools::document()` 명령어를 실행한다. (혹은 
RStudio에서 Ctrl/Cmd + Shift + D 단축키를 누른다).  (`devtools::document()`가 
   `roxygen2::roxygenise()`을 호출해서 고된 작업을 수행한다.)

1. `?` 명령어로 문서 미리보기 기능을 활용한다.

1. 문서가 원하는 대로 작업이 될 때까지 반복작업한다.

`roxygen` 주석을 소스코드 파일에 추가할 때 문서화 개발과정이 시작된다: `roxygen` 주석은 `#'`으로 시작되어 일반 주석(`#`)과 구분된다. 다음에 간단한 함수에 대한 문서 예제가 있다:

```{r}
#' Add together two numbers.
#' 
#' @param x A number.
#' @param y A number.
#' @return The sum of \code{x} and \code{y}.
#' @examples
#' add(1, 1)
#' add(10, 1)
add <- function(x, y) {
  x + y
}
```

Ctrl/Cmd + Shift + D 단축키를 누르면 (혹은 `devtools::document()` 명령어를 실행하면) 다음과 같은 `man/add.Rd` 파일이 생성된다:

```
% Generated by roxygen2 (4.0.0): do not edit by hand
\name{add}
\alias{add}
\title{Add together two numbers}
\usage{
add(x, y)
}
\arguments{
  \item{x}{A number}

  \item{y}{A number}
}
\value{
The sum of \code{x} and \code{y}
}
\description{
Add together two numbers
}
\examples{
add(1, 1)
add(10, 1)
}
```

만약 LaTeX과 친숙하다면, 산출결과가 친숙해 보일 것이다. 왜냐하면 `.Rd` 형식이 LaTeX에 느슨하게 기반하기 때문이다. [R extensions](http://cran.r-project.org/doc/manuals/R-exts.html#Rd-format) 매뉴얼에서 `.Rd` 형식에 관해서 더 많은 정보를 얻을 수 있다. 파일 최상단 주석에 주목하라: 코드로 자동 생성되어서 변경되지 말아야 된다. 사실 `roxygen2`를 사용한다면, 거의 이런 파일을 열어 볼 필요는 없다.

`?add`, `help("add")`, 혹은 `example("add")` 명령어를 사용하면, R은 일단 `\alias{"add"}`가 포함하는 `.Rd` 파일을 찾는다. 그리고 나서, 파일을 파싱하고, HTML로 전환하고 화면에 출력한다.
RStudio에서 출력되는 결과가 나와 있다:


```{r, echo = FALSE}
bookdown::embed_png("screenshots/man-add.png", dpi = 220)
```

(`devtools`가 일반 도움말 함수에 우선하기 때문에 개발 문서를 미리보기 할 수 있다는 것에 주목한다.
만약 문서가 나타나지 않는다면, `devtools`를 사용하고 있는지 `devtools::load_all()` 명령어로 팩키지를 적재했는지 확인한다.)

## 문서화 작업흐름 다른 대안 {#man-workflow-2}

첫 문서화 작업흐름은 매우 빠르지만, 한가지 한계가 있다: 미리보기 문서 페이지에 페이지 사이에 어떤 링크도 보여주지 않는다. 만약 연결된 링크도 볼려면, 다음 작업흐름을 사용한다:

1. `roxygen` 주석을 작성한 `.R` 파일에 추가한다.

1. `build` 창에서 `r bookdown::embed_png("screenshots/build-reload.png", dpi = 220)`을 클릭하거나 Ctrl/Cmd + Shift + B 단축키를 누른다. 이 과정을 통해서 팩키지를 완전히 다시 빌드한다. 여기에는 모든 문서를 갱신하고, 문서를 정규 라이브러리에 설치하고 나서 R을 다시 시작하고 팩키지를 다시 적재한다. 느리지만 빈틈없다.

1. `?` 명령어로 문서를 미리보기(preview) 한다.

1. 문서가 원하는 대로 작업이 될 때까지 반복작업한다.

만약 상기 작업흐름이 동작하지 않는 것처럼 보인다면, RStudio에 프로젝트 선택옵션을 점검한다. 이전 `devtools`와 RStudio에서 팩키지가 다시 빌드될 때 문서를 자동으로 갱신하지 못하는 오류가 있다:

```{r, echo = FALSE}
bookdown::embed_png("screenshots/build-reload-opts-2.png", dpi = 220)
```

## `Roxygen` 주석 {#roxygen-comments}

Roxygen 주석은 `#'`으로 시작하고, 함수 앞에 놓인다.
함수에 앞선 모든 roxygen 행을 __블록(block)__이라고 한다.
각 행도 코드와 동일하게 일반적으로 문자 80자에 맞춰야 된다.

블록은 `@tagName details`처럼 __태그(tags)__로 쪼개진다. 
해당 태그 내용은 태그 명칭 끝에서부터 다음 태그 시작까지(혹은 블록 끝까지) 범위를 갖는다. `@` 기호가 roxygen에서 특별한 의미를 갖기 때문에, `@`를 문자 그대로 추가하려면
`@@`로 표현한다. (전자우편주소와 S4 객체 슬롯에 접근하는데 대체로 사용된다).

각 블록은 첫 태그[^1] 앞에 텍스트를 포함한다. 이것을 __소개(introduction)__라고 부르고, 특별하게 파싱된다:


* 첫 _문장(sentence)_는 문서 제목이 된다. `help(package = mypackage)` 명령어를 실행했을 때 보는 것이고, 각 도움말 파일 상단에 나타난다. 한 줄에 맞춰야 되고, 각 단어는 대문자로 표현되고, 마침표로 끝나야 된다.


* 두번째 _문단(paragraph)_은 기술이다: 문서 처음에 나오고, 간략하게 함수가 __무엇(what)__을 수행하는지 기술해야 한다.
  
* 세번째 그리고 후속 _문단(paragraphs)_은 상세로 들어간다: 인자 기술 다음에 나타나는
  (종종 장문) 부문으로 함수가 __어떻게(how)__ 동작하는지 상세한 내용이 나와있다.

모든 객체는 제목(title)과 기술(description)을 가져야만 된다. 상세 내용(detail)은 선택옵션이다.

`roxygen`으로 작성한다면, `sum()` 함수에 대한 소개가 어떤 느낌이 다음에 예제로 나와 있다:

```{r}
#' Sum of vector elements.
#' 
#' \code{sum} returns the sum of all the values present in its arguments.
#' 
#' This is a generic function: methods can be defined for it directly or via the
#' \code{\link{Summary}} group generic. For this to work properly, the arguments
#' \code{...} should be unnamed, and dispatch is on the first argument.
sum <- function(..., na.rm = TRUE) {}
```

`\code{}`와 `\link{}`는 [formatting](#text-formatting)에서 학습할 서식 명령어(formatting commands)다. 조심스럽게 `roxygen` 블록을 감싸서 문자 80자를 넘지않게 했다. RStudio에서 Ctrl/Cmd + Shift + / 명령어를 사용해서 자동으로 맞추게 한다. (혹은 메뉴에서 code | re-flow comment을 사용한다).

`@section` 태그로 임의 절(section)을 문서에 추가할 수도 있다.
이것이 유용한 이유는 상세한 설명을 담고 있는 장문 절을 도움되는 표제를 갖는 다수 덩어리로 쪼갤 수 있게 한다. 절 제목 각 단어는 대문자로 표현되고, 콜론이 다음에 오고, 한줄 길이로 표현될 수 있다.

```{r}
#' @section Warning:
#' Do not operate heavy machinery within 8 hours of using this function.
```

도움말 파일 사이를 쉽게 돌아다니게 도움이 되는 태그가 두개 있다:


* `@seealso` 태그는 `\url{http://www.r-project.org}` 웹상에, 
  `\code{\link{functioname}}` 팩키지에, `\code{\link[packagename]{functioname}}` 
  또 다른 팩키지에 다른 유용한 교재를 알려준다.
   
* 만약 연관된 함수군으로 모든 함수가 해당 군의 다른 모든 함수에 연관되어 있다면, `@family`을 사용한다. `@family` 값은 복수형이다.

합계(sum) 함수에 대해서, 상기 구성요소는 다음과 같다:

```{r}
#' @family aggregate functions
#' @seealso \code{\link{prod}} for products, \code{\link{cumsum}} for cumulative
#'   sums, and \code{\link{colSums}}/\code{\link{rowSums}} marginal sums over
#'   high-dimensional arrays.
```

다른 태그 두개로 사용자가 문서를 더 쉽게 찾을 수 있게 돕는다:

*   `@aliases alias1 alias2 ...` 태그는 주제(topic)에 추가적인 별명(alias)을 추가한다.
    별명은 `?`으로 사용될 수 있는 주제에 대한 또다른 명칭이다.

*   `@keywords keyword1 keyword2 ...` 태그는 표준화된 키워드를 추가한다.
    키워드는 선택옵션이다. 하지만, 만약 키워드가 있다면, `file.path(R.home("doc"), "KEYWORDS")` 명령어로 찾아지는 사전 정의된 목록에서 뽑혀진다.

    일반적으로, 키워드는 `@keywords internal` 예외를 제외하면 그다지 유용하지 않다.
    내부 키워드를 사용하게 되면 팩키지 인덱스에서 함수를 제거하고 
    테스트 자동화 일부가 비활성화된다. 대부분의 일반 사용자가 아니라 
    작성된 팩키지를 확장하려는 다른 개발자에게 흥미로운 함수에 대해서 
    `@keywords internal`을 사용하는 것이 일반적이다.
    
다른 태그는 상황에 따라 다르다: 문서화하는 객체 유형에 다양하게 나타난다.
다음 절에서 가장 흔하게 사용되는 태그를 기술한다: 함수, 팩키지, 세가지 R OO 시스템에서 사용되는 다양한 메쏘드, 제네릭, 객체.

## 함수 문서화 {#man-functions}

함수는 가장 흔하게 문서화되는 객체다.
소개 블록뿐만 아니라, 대부분의 함수는 태그를 세개 갖는다: `@param`, `@examples`, `@return`.


*   `@param name description` 태그를 통해 함수 입력 혹은 매개변수를 기술한다.
    명칭에서 명확하지 않다면 매개변수 역할과 매개변수 유형을 
    간결한 요약으로 기술한다.
    
    매개변수 기술은 대문자로 시작해서 마침표로 끝나다. 
    필요하면 여러 행에 걸쳐서 혹은 심지어 문단으로도 확장될 수 있다. 
    매개변수 모두를 문서화해야 한다.
    
    (공백 없이) 콤마로 명칭을 분리해서 한 장소에서 다수 인자를 문서화할 수 있다.
    예를 들어, `x`와 `y` 모두를 문서화하려면, 
    `@param x,y Numeric vectors.` 처럼 작성할 수 있다.


*   `@examples` 태그는 실행가능한 R 코드를 제공해서, 실전에서 어떻게 함수를
    사용하는지 알려준다. 
    이것이 문서에서 가장 중요한 부분이 되는데, 
    이유는 많은 사람들이 예제를 먼저 보기 때문이다.
    `R CMD check` 일부로 자동 실행되어, 예제 코드는 오류 없이 동작되야 된다.
    
    실례 목적으로 오류(error)를 발생시키는 코드를 포함하는 것이 종종 유용할 때가 있다.
    `\dontrun{}`을 사용해서 실행되지 않는 코드를 예제로 넣는다.
    (유사한 목적으로 `\dontrun{}`을 사용하곤 했는데, 더 이상 추천하지는 않는다. 
    왜냐하면 실제로 테스트가 __되기__ 때문이다).
    
    문서에 직접 예제를 포함하는 대신에, 예제를 별도 파일에 저장하고, 
    `@example path/relative/to/packge/root` 태그를 사용해서 문서에 삽입한다.
    

*   `@return description` 태그는 함수에서 나온 출력결과를 기술한다.
    항상 필요하는 것은 아니지만, 만약 작성한 함수가 입력에 따라 다른 유형의 
    출력을 반환하거나, S3, S4, RC 객체를 반환한다면 반환값을 기술하는 것이 좋다.

상기 신규 학습한 태그를 사용해서 다음과 같이 `sum()` 함수 문서를 개선한다:

```{r}
#' Sum of vector elements.
#'
#' \code{sum} returns the sum of all the values present in its arguments.
#'
#' This is a generic function: methods can be defined for it directly
#' or via the \code{\link{Summary}} group generic. For this to work properly,
#' the arguments \code{...} should be unnamed, and dispatch is on the
#' first argument.
#'
#' @param ... Numeric, complex, or logical vectors.
#' @param na.rm A logical scalar. Should missing values (including NaN)
#'   be removed?
#' @return If all inputs are integer and logical, then the output
#'   will be an integer. If integer overflow
#'   \url{http://en.wikipedia.org/wiki/Integer_overflow} occurs, the output
#'   will be NA with a warning. Otherwise it will be a length-one numeric or
#'   complex vector.
#'
#'   Zero-length vectors have sum 0 by definition. See
#'   \url{http://en.wikipedia.org/wiki/Empty_sum} for more details.
#' @examples
#' sum(1:10)
#' sum(1:5, 6:10)
#' sum(F, F, F, T, T)
#'
#' sum(.Machine$integer.max, 1L)
#' sum(.Machine$integer.max, 1)
#'
#' \dontrun{
#' sum("a")
#' }
sum <- function(..., na.rm = TRUE) {}
```

태그 두번째 이후 라인을 들여쓴다. 그렇게 해서, 문서를 일별할 때, 태그가 어디서 끝나고, 다음 태그가 어디서 시작하는지 식별하기 좋다. 
`@example`처럼 항상 다수 행을 잡아먹는 태그는 새줄(new line)에 시작하고 들여쓰기할 필요가 없다.


## 데이터셋(dataset) 문서화 {#man-data}

[documenting data](#documenting-data) 참조한다.

## 팩키지 문서화 {#man-packages}

`roxygen`을 사용해서 전체 작성한 팩키지 도움말 페이지를 생성한다.
`package?foo` 명령어로 접근되고, 작성한 팩키지의 가장 중요한 구성요소를 기술하는데 사용한다.
다음 장에서 기술되는 소품문(vignettes)에 대한 유용한 부록이다.

팩키지에 상응하는 객체는 없다. 그래서, `NULL`을 문서화할 필요가 있다.
그리고 나서, 수작업으로 `@docType package`와 `@name <package-name>` 태그로 라벨을 붙인다. `@section` 태그를 사용해서 페이지를 유용한 범주로 나누기에 더할나위 없이 좋은 장소다.


```{r}
#' foo: A package for computating the notorious bar statistic.
#'
#' The foo package provides three categories of important functions:
#' foo, bar and baz.
#' 
#' @section Foo functions:
#' The foo functions ...
#'
#' @docType package
#' @name foo
NULL
```

저자는 `<package-name>.R`로 불리는 파일에 이 문서를 저장한다.
[imports](#imports)에서 학습할 팩키지 레벨 `import` 문장을 두기도 좋은 장소다.


## 클래스, 제네릭, 메쏘드 문서화 {#man-classes}

클래스, 제네릭, 메쏘드를 문서화하는 것은 상대적으로 쉽다.
사용하는 객체 시스템에 따라 구체적인 내용은 변한다.
다음 절에서 S3, S4, RC 객체 시스템에 대한 구체적인 내용을 다룬다.

### S3 {#man-s3}

S3 __제네릭(generics)__은 정규 함수다. 그래서, 함수로 문서화한다.
S3 __클래스(classes)__는 어떤 정형화된 정의가 없다. 그래서 생성자 함수를 문서화한다.
S3 __메쏘드(methods)__를 문서화할지 하지 말지는 개발자 선택사항이다.
`print()`같은 간단한 제네릭에 대한 메쏘드를 문서화할 필요는 없다.
하지만, 만약 작성한 메쏘드가 더 복잡하거나 추가적인 인자가 포함된다면, 
문서화해서 사람들이 사용법을 알 수 있게 한다.
`predict.lm()`, `predict.glm()`, `anova.glm()` 같은 좀더 복잡한 메쏘드에 대한 문서 예제를 기반 R(R base)에서,볼 수 있다.

`roxygen` 이전 버젼에서 모든 S3 메쏘드에 대해서 `@method generic class` 태그가 명시적으로 필요하다. 3.0.0 버젼 이후로, 더 이상 필요하지는 않는데 이유는 
`roxygen2`가 자동으로 해결해주기 때문이다.
만약 업그레이드한다면, 이전 태그를 확실히 제거한다.
만약 제네릭과 클래스가 애매모호하다면 자동 메쏘드 탐지는 실패한다.
예를 들어, `all.equal.data.frame()`은 `all`에 대한 `equal.data.frame` 메쏘드인지 아니면 
`all.equal`에 대한 `data.frame` 메쏘드인가? 만약 이런 상황이 발생되면, 
예를 들어, `@method all.equal data.frame` 태그로 상황을 명확히 한다.


### S4 {#man-s4}

`setClass()` 앞에 `roxygen` 블록을 추가해서 __S4 클래스(classes)__를 문서화한다.
`@param`을 사용해서 함수 매개변수를 기술하는 동일한 방식으로 `@slot` 태그를 사용해서 클래스 슬롯을 문서화한다.

```{r}
#' An S4 class to represent a bank account.
#'
#' @slot balance A length-one numeric vector
Account <- setClass("Account",
  slots = list(balance = "numeric")
)
```

S4 __제네릭(generics)__도 함수다. 그래서 마찬가지로 문서화한다.
하지만, S4 __메쏘드(methods)__는 약간 더 복잡하다.
S3와 달리, S4 메쏘드는 문서화되어야 한다.
정규 함수처럼 S4 메쏘드를 문서화 하지만, 아마도 각 메쏘드에 대해 각자 문서 페이지를 배정하고 싶지는 않을 것이다. 대신에 다음 세 장소 중에서 한 곳에 메쏘드를 문서화하여 둔다:


* 클래스에 둔다. 만약 상응하는 제네릭이 단일 작업지정(dispatch)을 사용하고, 여러분이 클래스를 생성한다면 가장 적절하다.


* 제네릭에 둔다. 만약 제네릭이 다수 작업지정(dispatch)를 사용하고, 여러분이 메쏘드와 제네릭 둘다 작성했다면 가장 적절하다.

* 파일 자체에 둔다. 만약 메쏘드가 복잡하거나 만약 여러분이 메쏘드를 작성했지만, 클래스와 제네릭을 작성하지 않았다면 가장 적절하다.

`@rdname` 혹은 `@describeIn`을 사용해서 메쏘드 문서를 어느 장소에 위치할지 제어한다.
자세한 사항은 [documenting multiple objects in one file](#multiple-man)을 참조한다.

고려해봐야할 다른 점은 S4 코드가 종종 특정 순서로 실행될 필요가 있다는 점이다.
예를 들어, `setMethod("foo", c("bar", "baz"), ...)` 메쏘드를 정의하려면,
이미 `foo` 제네릭과 두 클래스를 생성해야 한다.
기본 설정으로 R 코드는 알파벳 순서로 적재되지만, 상황에 따라 항상 동작되지는 않는다.
알파벳 순서에 의존하기 보다, `roxygen2`를 사용해서 명시적으로 다른 파일 이전에 특정 파일이 적재되도록 순서를 정한다: `@include`. 현재 파일 이전에 적재되어야 되는 파일 목록을 공백으로 구분하여 `@include` 태그가 담고 있다:


```{r, eval = FALSE}
#' @include class-a.R
setClass("B", contains = "A")
```

종종, 파일 상단에 상기 코드를 위치시키는 것이 가장 쉽다.
상기 태그가 특정 객체가 아니라 전체 파일에 적용된다는 것을 명확히 하도록, `NULL` 문서화한다.

```{r, eval = FALSE}
#' @include foo.R bar.R baz.R
NULL

setMethod("foo", c("bar", "baz"), ...)
```

`roxygen`은 `@include` 태그를 사용해서 필요하기 전에 의존성이 확실히 적재되도록 위상정렬(topological sort)을 계산한다.
그리고 나서, `DESCRIPTION` 파일에 `Collate` 필드를 설정하는데 그렇게 되면 디폴트 기본 설정된 알파벳 정렬은 무시(override)된다. 
`@include`에 유사한 대안은 `aaa-classes.R`와 `aaa-generics.R` 파일에 모든 클래스와 메쏘드를 정의하고, 알파벳 순서로 정렬되어 있기 때문에 먼저 오는 것에 사용한다.
주된 단점은 원하는 만큼 자연스럽게 컴포넌트(components)를 파일에 조직화할 수 없다.

`roxygen2` 이전 버젼에서는 명시적으로  S4 객체 문서화에 `@usage`, `@alias`, `@docType`
태그가 필요하다.
하지만, 3.0.0 버젼부터 `roxygen2`가 자동으로 올바른 값을 생성해서 더 이상 필요가 없다.
만약 이전 버젼에서 업그레이드하면, 이런 태그를 삭제할 수 있다.

### 참조 클래스 (RC) {#man-rc}

참조 클래스(Reference Class, RC)는 S3, S4와 다르다. 왜냐하면 메쏘드가 제네릭이 아닌 클래스와 연계되기 때문이다. 또한 RC는 메쏘드를 문서화하는 특별한 관례가 있다: __docstring__. `docstring`은 메쏘드 정의 내부에 위치하는 문자열로, 간략하게 메쏘드가 무엇을 수행하는지 기술한다. 이것이 S4보다 RC를 더 문서화하기 단순하한다. 왜냐하면 클래스마다 한 `roxygen` 블록만 필요하기 때문이다.


```{r}
#' A Reference Class to represent a bank account.
#'
#' @field balance A length-one numeric vector.
Account <- setRefClass("Account",
  fields = list(balance = "numeric"),
  methods = list(
    withdraw = function(x) {
      "Withdraw money from account. Allows overdrafts"
      balance <<- balance - x
    }
  )
)
```

`docstring`을 갖는 메쏘드는 클래스 문서 "Methods" 절에 추가된다.
각기 문서화된 메쏘드는 자동 생성된 사용 문장(usage statement)과 `docstring`으로 목록으로 표시된다. `@slot` 대신 `@field` 사용하는 것에 주의한다.


## 특수 문자 {#man-special}

최종 문서에 표현하려면 특별한 처리가 필요한 특수문자(special character)가 세개 있다:


* `@` 특수문자는 보통 `roxygen`태그 시작을 명기한다. 
  `@@`을 사용해서 최종 문서 `@` 문자 그대로 찍는다.
  
* `%` 특수문자는 보통 행 마지막까지 계속되는 LaTeX 주석 시작을 명기한다.
  `\%`을 사용해서 `%` 문자 그대로 출력문서에 찍는다.
  예제에서는 이스케이프(`\`)가 필요없다.


* `\` 특수문자는 보통 LaTex 이스케이프 시작을 명기한다. 
  `\\`을 사용해서 `\` 문자 그대로 문서에 찍는다.

## 스스로 반복하라 {#dry2}

DRY (don't repeat yourself, 스스로 반복하지마라) 프로그래밍 원칙과 문서 자체로 포함되어야 되는 필요성 사이에 긴장이 있다. 필요한 모든 부분을 뽑아내기 위해서
다수 도움말 파일을 돌아다녀야 되는 것은 난감하다. 두가지 방식으로 `roxygen2`로 반복을 필할 수 있는 반면에, 여전히 모든 것을 한 문서 파일로 조립할 수 있다:

* `@inheritParams`으로 매개변수 문서를 재사용하는 기능.

* `@describeIn` 혹은 `@rdname` 태그로 동일한 장소에 다수 함수를 문서화하는 기능.

### 다른 함수에서 매개변수를 상속하기

`@inheritParams source_function` 태그를 사용해서 다른 함수의 매개변수 기술문서를 상속할 수 있다. 이 태그를 사용해서 현재 함수에서 문서화되지 않았지만, 소스 함수에서 무서화된 매개변수를 문서화한다. 소스(source)는 `@inheritParams function`를 경유해서 현재 팩키지에 있는, 혹은 `@inheritParams package::function`을 경유해서 또 다른 팩키지에 있는 함수다. 예를 들어, 다음과 같이 문서화하게 되면


```{r}
#' @param a This is the first argument
foo <- function(a) a + 10

#' @param b This is the second argument
#' @inheritParams foo
bar <- function(a, b) {
  foo(a) * 10
}
```

다음과 동치다.

```{r}
#' @param a This is the first argument
#' @param b This is the second argument
bar <- function(a, b) {
  foo(a) * 10
}
```

상속은 연쇄 사슬로 묶이지 않는 것에 주목한다. 다른 말로 표현하면, 
`source_function`는 항상 `@param`을 사용해서 매개변수를 정의한 함수여야만 한다.


### 동일 파일에 다수 함수를 문서화 {#multiple-man}

`@rdname` 혹은 `@describeIn` 태그를 사용해서 동일 파일에 다수 함수를 문서화한다.
하지만, 조심스럽게 사용되어야 되는 기술이다: 한 장소에 너무 많은 함수를 문서화하면 혼동스러운 문서가 될 수 있다. 함수가 비슷한 인자를 갖거나 예를 들어, `open()`과 `close()` 메쏘드처럼 보완 효과가 있을 때 사용한다.

`@describeIn`은 대부분의 경우 다음과 같은 경우를 염두에 뒀다:

* 제네릭에 있는 메쏘드 문서화.
* 클래스에 있는 메쏘드 문서화.
* 동일한 (혹은 유사한 인자)를 갖는 함수를 문서화.

상기 태그는 "메쏘드(Methods) (by class)", "메쏘드 (Methods) (by generic)" 혹은 "함수(Functions)"로 이름 붙여진 새로운 절(section)을 생성한다.
함수 각각을 기술하는 글머리 기호 목록이 이 절에 담겨진다.
라벨이 붙어서 무슨 함수 혹은 메쏘드를 의미하는지 알 수 있다.
가상의 신규 제네릭을 문서화한 예제가 다음에 있다:

```{r}
#' Foo bar generic
#'
#' @param x Object to foo.
foobar <- function(x) UseMethod("foobar")

#' @describeIn foobar Difference between the mean and the median
foobar.numeric <- function(x) abs(mean(x) - median(x))

#' @describeIn foobar First and last values pasted together in a string.
foobar.character <- function(x) paste0(x[1], "-", x[length(x)])
```

`@describeIn`에 대한 대안이 `@rdname`이다. 
`roxygen`으로 생성된 디폴트 기본 파일명칭을 재정의해서 객체 다수 문서를 한 파일에 병합한다. 이러한 기능이 문서를 조합하는 완전한 자유를 부여한다.

`@rdname`을 사용하는 두가지 방식이 있다. 기존 함수에 문서를 추가할 수 있다:

```{r}
#' Basic arithmetic
#'
#' @param x,y numeric vectors.
add <- function(x, y) x + y

#' @rdname add
times <- function(x, y) x * y
```

혹은 `NULL` 문서화하고 정보가 되는 `@name` 태그를 설정해서 가짜 더미 문서를 생성한다.

```{r}
#' Basic arithmetic
#'
#' @param x,y numeric vectors.
#' @name arith
NULL

#' @rdname arith
add <- function(x, y) x + y

#' @rdname arith
times <- function(x, y) x * y
```

## 텍스트 서식 참조 문서(sheet) {#text-formatting}

`roxygen` 태그 내부에 `.Rd` 구문을 사용해서 텍스트에 서식을 입힌다.
다음 소품문(vignette)에 가장 중요한 명령어 예제가 나와 있다.
자세한 사항은 [R 확장(extensions)](http://cran.r-project.org/doc/manuals/R-exts.html#Marking-text)에 기술되어 있다.

Rd 서식에서 `\`와 `%`은 특수문자라는 것에 주목한다.
`%` 혹은 `\`을 문자 그대로 찍기 위해서, 역슬래쉬로 다음과 같이 `\\`, `\%` 이스케이프(escape)해서 빠져나와야 한다.


### 문자 서식

* `\emph{italics}`: _이탤릭체(italics)_.

* `\strong{bold}`: __굵은 글씨(bold)__.

* `\code{r_function_call(with = "arguments")}`: 
  `r_function_call(with = "arguments")` (인라인(inline) 코드 서식)

* `\preformatted{}`: 텍스트를 있는 그대로 서식으로 표현하는데, 다중 행으로 된 코드에 사용.

### 링크 (Links)

다른 문서에 링크 연결:

* `\code{\link{function}}`: 팩키지에 있는 함수로.

* `\code{\link[MASS]{abbey}}`: 또다른 팩키지에 있는 함수로.

* `\link[=dest]{name}`: 목적지(dest)에 링크, 하지만 명칭을 나타낸다.

* `\linkS4class{abc}`: S4 클래스에 링크.

웹에 링크 연결:

* `\url{http://rstudio.com}`: url.

* `\href{http://rstudio.com}{Rstudio}`:, 사용자 정의 링크 텍스트가 있는 url.

* `\email{hadley@@rstudio.com}` (`@`가 중복된 것에 주의): 전자우편 주소.

### 목록 (Lists)

* 순서 있는 (숫자) 목록:

    ```{r}
    #' \enumerate{
    #'   \item First item
    #'   \item Second item
    #' }
    ```

* 순서없는 (글머리 기호) 목록:

    ```{r}
    #' \itemize{
    #'   \item First item
    #'   \item Second item
    #' }
    ```

* 정의 (이름) 목록:

    ```{r}
    #' \describe{
    #'   \item{One}{First item}
    #'   \item{Two}{Second item}
    #' }
    ```

### 수식 (Mathematics)

표준 LaTeX 수학 (하지만 확장없는) 표기를 사용한다.
인라인 혹은 블록 표시를 선택한다:

* `\eqn{a + b}`: 인라인 수식.

* `\deqn{a + b}`: (블록) 표시 수식.

### 표 (Tables)

`\tabular{}`로 표를 생성한다. 인자 두개가 필요하다:


1. 각 칼럼에 대해서 문자로 지정되는 칼럼 정렬 (`l` = 왼쪽 정렬, `r` = 오른쪽 정렬,
   `c` = 가운데 정렬.)

2. 칼럼을 구분하는 `\tab`, 열을 구분하는 `\cr`을 갖는 표 내용.

다음 한수가 R 데이터프레임을 올바른 서식으로 바꾼다. 칼럼과 행 명칭을 무시하지만, 표 서식을 작업 시작점이 된다.

```{r}
tabular <- function(df, ...) {
  stopifnot(is.data.frame(df))

  align <- function(x) if (is.numeric(x)) "r" else "l"
  col_align <- vapply(df, align, character(1))

  cols <- lapply(df, format, ...)
  contents <- do.call("paste",
    c(cols, list(sep = " \\tab ", collapse = "\\cr\n  ")))

  paste("\\tabular{", paste(col_align, collapse = ""), "}{\n  ",
    contents, "\n}\n", sep = "")
}

cat(tabular(mtcars[1:5, 1:5]))
```

### Notes
[^1]: `@title`와 `@description` 태그를 사용해서 암묵적이기 보다 명시적으로 제목과 기술을 갖는 "소개(introduction)" 절을 정의하는 것이 가능하다는 것에 주목한다.
다른 많은 팩키지 저자가 하듯이 이것을 피하는 관례를 저자는 따른다. 그래서 저자는 추천하지 않는다 - 하지만, 이러한 태그가 존재와 다른 팩키지 저작자 소스 코드에 나타날 수 있다는 것을 인지해야 한다.


